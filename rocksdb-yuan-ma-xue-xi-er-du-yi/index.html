<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="RocksDB源码学习(二): 读(一), SrcMiLeの杂货铺">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>RocksDB源码学习(二): 读(一) | SrcMiLeの杂货铺</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>


    

                <body>
                    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/avatar.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">SrcMiLeの杂货铺</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>放映室</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>破书架</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/avatar.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">SrcMiLeの杂货铺</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>放映室</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>破书架</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/sakura-ysy" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/sakura-ysy" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

                        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">RocksDB源码学习(二): 读(一)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%AD%98%E5%82%A8/">
                                <span class="chip bg-color">存储</span>
                            </a>
                        
                            <a href="/tags/rocksdb/">
                                <span class="chip bg-color">rocksdb</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%98%E5%82%A8/" class="post-category">
                                存储
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-10-19
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    5.8k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>注：本篇博客所用代码版本均为 <code>v7.7.3</code>。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RocksDB 的所有对记录 delete 和 update 操作，都不是就地删或者就地更新，而是新增一个记录表示这个操作，而这个记录也是一个 &lt;k, v&gt;，和其他所有的 &lt;k, v&gt; 按照同样的方式存储。看完 <a target="_blank" rel="noopener" href="https://yesiyuan.cn/">RocksDB源码学习(一)</a> 那一章就知道，key 实际上是存在 user_key =&gt; internal_key =&gt; memetable_key 这一个转化过程的，从 internl_key 开始，就可以通过 valueType 部分区分出这个 &lt;k, v&gt; 具体是什么操作类型，是插入、删除、更新还是别的什么。很直观的来看，我们只需要读取插入和更新的 &lt;k, v&gt;，删除的 &lt;k, v&gt; 就不用管了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum ValueType : unsigned char &#123;
  kTypeDeletion &#x3D; 0x0,
  kTypeValue &#x3D; 0x1,  &#x2F;&#x2F; 这个就是 put，表示插入或更新，即这个值是要读的
  kTypeMerge &#x3D; 0x2,
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同一个 key 通过 sequence num 区分不同记录的时间先后，就像一个时间戳一样。而我们的读操作，实际上就是如何读到一个 key 最新的记录，而且是带数据的记录。RocksDB中，数据是保存在两个地方，一个是 memtable（内存），一个是 sstable（磁盘），RocksDB 读数据也是主要从这两个地方读取。</p>
<ul>
<li><p><strong>writebatch</strong>：如果仍有 writebatch 还没有 commit，那么就先在这读，没读到在进入 DB 中读取。</p>
</li>
<li><p><strong>memtable</strong>：在 RocksDB 中 memtable 的默认实现是 skiplist，RocksDB 会将用户传入的 user_key 改变为memtable 内部的 key（internal_key_size+internal_key），然后再加上用户传入的 value 之后，作为一个element 加入到 skiplist，而我们读取的时候需要读取到最新的那条数据。</p>
</li>
<li><p><strong>sstable</strong>：除 L0 层之外，记录在每一层中有序，排序的依据依次是 user_key 升序，sequence num 降序，type 降序。除 L0 层之外，每一层中的各 sstable 所存储的 key 范围不会重叠，但 L0 层可能出现重叠。因此，在 L0 需要读取所有 sstable，在其他层只要读到一个就行。</p>
</li>
</ul>
<p>本篇博客分析读操作的框架以及在 memtable 中的读取，着急看结论可以直接跳到最后一张图。</p>
<hr>
<h3 id="从-GetImpl-开始分析"><a href="#从-GetImpl-开始分析" class="headerlink" title="从 GetImpl 开始分析"></a>从 GetImpl 开始分析</h3><p>我们知道，用户显示传入的 key 只是 user_key，它需要先被转换为 internal_key，其格式有两种，如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">user_key + sequence + type;
(user_key + ts) + sequence + type; &#x2F;&#x2F; (since v6.6.4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>转换函数为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">InternalKey(const Slice&amp; _user_key, SequenceNumber s, ValueType t) &#123;
    AppendInternalKey(&amp;rep_, ParsedInternalKey(_user_key, s, t));
&#125;
InternalKey(const Slice&amp; _user_key, SequenceNumber s, ValueType t, Slice ts) &#123;
    AppendInternalKeyWithDifferentTimestamp(
        &amp;rep_, ParsedInternalKey(_user_key, s, t), ts);
&#125;

void AppendInternalKey(std::string* result, const ParsedInternalKey&amp; key) &#123;
    result-&gt;append(key.user_key.data(), key.user_key.size());
    PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
&#125;

void AppendInternalKeyWithDifferentTimestamp(std::string* result,
                                             const ParsedInternalKey&amp; key,
                                             const Slice&amp; ts) &#123;
    assert(key.user_key.size() &gt;&#x3D; ts.size());
    result-&gt;append(key.user_key.data(), key.user_key.size() - ts.size());
    result-&gt;append(ts.data(), ts.size());
    PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们知道，RocksDB 按照 user_key 升序，seq 降序，type 降序，三者优先级依次降低的方式组织 internal_key。因此，只要读取到对应 user_key 的最大 seq，就算读取成功。internal_key 的比较器如下所示，返回 0 表示 a == b，-1 表示 a &lt; b，+1 表示 a &gt; b。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int InternalKeyComparator::Compare(const ParsedInternalKey&amp; a,
                                   const ParsedInternalKey&amp; b) const &#123;
  &#x2F;&#x2F; Order by:
  &#x2F;&#x2F;    increasing user key (according to user-supplied comparator)
  &#x2F;&#x2F;    decreasing sequence number
  &#x2F;&#x2F;    decreasing type (though sequence# should be enough to disambiguate)
  int r &#x3D; user_comparator_.Compare(a.user_key, b.user_key);
  if (r &#x3D;&#x3D; 0) &#123;
    if (a.sequence &gt; b.sequence) &#123;
      r &#x3D; -1;
    &#125; else if (a.sequence &lt; b.sequence) &#123;
      r &#x3D; +1;
    &#125; else if (a.type &gt; b.type) &#123;
      r &#x3D; -1;
    &#125; else if (a.type &lt; b.type) &#123;
      r &#x3D; +1;
    &#125;
  &#125;
  return r;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="LookupKey"><a href="#LookupKey" class="headerlink" title="LookupKey"></a>LookupKey</h4><p>当用户想要查找 user_key 时，RocksDB 会首先为本次查找构建一个 LookupKey，该类会在 DBImpl::Get() 中用的。LookupKey 和普通的 key 差不多，也是存在 user_key、 internal_key 和 memtable_key 的形式，其源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A helper class useful for DBImpl::Get()
class LookupKey &#123;
 public:
  &#x2F;&#x2F; Initialize *this for looking up user_key at a snapshot with
  &#x2F;&#x2F; the specified sequence number.
  LookupKey(const Slice&amp; _user_key, SequenceNumber sequence,
            const Slice* ts &#x3D; nullptr);

  ~LookupKey();

  &#x2F;&#x2F; Return a key suitable for lookup in a MemTable.
  Slice memtable_key() const &#123;
    return Slice(start_, static_cast&lt;size_t&gt;(end_ - start_));
  &#125;

  &#x2F;&#x2F; Return an internal key (suitable for passing to an internal iterator)
  Slice internal_key() const &#123;
    return Slice(kstart_, static_cast&lt;size_t&gt;(end_ - kstart_));
  &#125;

  &#x2F;&#x2F; Return the user key
  Slice user_key() const &#123;
    return Slice(kstart_, static_cast&lt;size_t&gt;(end_ - kstart_ - 8));
  &#125;

 private:
  &#x2F;&#x2F; We construct a char array of the form:
  &#x2F;&#x2F;    klength  varint32               &lt;-- start_
  &#x2F;&#x2F;    userkey  char[klength]          &lt;-- kstart_
  &#x2F;&#x2F;    tag      uint64
  &#x2F;&#x2F;                                    &lt;-- end_
  &#x2F;&#x2F; The array is a suitable MemTable key.
  &#x2F;&#x2F; The suffix starting with &quot;userkey&quot; can be used as an InternalKey.
  const char* start_;
  const char* kstart_;
  const char* end_;
  char space_[200];  &#x2F;&#x2F; Avoid allocation for short keys

  &#x2F;&#x2F; No copying allowed
  LookupKey(const LookupKey&amp;);
  void operator&#x3D;(const LookupKey&amp;);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，kstart_ 就是 internal_key，start_ 就是 memtable_key。注意到，LookupKey 的构造函数中，需要传入一个 user_key 、一个 seq 和一个 ts，其中 user_key 当然是要查询的 user_key，那么 seq 是哪里来的呢？</p>
<p>我们查看 LookupKey 的调用者，也就是 DBImpl::GetImpl()，其部分源码如下，我们只看和 seq 有关的部分。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status DBImpl::GetImpl(const ReadOptions&amp; read_options, const Slice&amp; key,
                       GetImplOptions&amp; get_impl_options) &#123;
  &#x2F;&#x2F; ...
  SequenceNumber snapshot;
  if (read_options.snapshot !&#x3D; nullptr) &#123;
    if (get_impl_options.callback) &#123;
      &#x2F;&#x2F; Already calculated based on read_options.snapshot
      snapshot &#x3D; get_impl_options.callback-&gt;max_visible_seq();
    &#125; else &#123;
      snapshot &#x3D;
          reinterpret_cast&lt;const SnapshotImpl*&gt;(read_options.snapshot)-&gt;number_;
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; Note that the snapshot is assigned AFTER referencing the super
    &#x2F;&#x2F; version because otherwise a flush happening in between may compact away
    &#x2F;&#x2F; data for the snapshot, so the reader would see neither data that was be
    &#x2F;&#x2F; visible to the snapshot before compaction nor the newer data inserted
    &#x2F;&#x2F; afterwards.
    snapshot &#x3D; GetLastPublishedSequence();
    if (get_impl_options.callback) &#123;
      &#x2F;&#x2F; The unprep_seqs are not published for write unprepared, so it could be
      &#x2F;&#x2F; that max_visible_seq is larger. Seek to the std::max of the two.
      &#x2F;&#x2F; However, we still want our callback to contain the actual snapshot so
      &#x2F;&#x2F; that it can do the correct visibility filtering.
      get_impl_options.callback-&gt;Refresh(snapshot);

      &#x2F;&#x2F; Internally, WriteUnpreparedTxnReadCallback::Refresh would set
      &#x2F;&#x2F; max_visible_seq &#x3D; max(max_visible_seq, snapshot)
      &#x2F;&#x2F;
      &#x2F;&#x2F; Currently, the commented out assert is broken by
      &#x2F;&#x2F; InvalidSnapshotReadCallback, but if write unprepared recovery followed
      &#x2F;&#x2F; the regular transaction flow, then this special read callback would not
      &#x2F;&#x2F; be needed.
      &#x2F;&#x2F;
      &#x2F;&#x2F; assert(callback-&gt;max_visible_seq() &gt;&#x3D; snapshot);
      snapshot &#x3D; get_impl_options.callback-&gt;max_visible_seq();
    &#125;
  &#125;
  &#x2F;&#x2F; If timestamp is used, we use read callback to ensure &lt;key,t,s&gt; is returned
  &#x2F;&#x2F; only if t &lt;&#x3D; read_opts.timestamp and s &lt;&#x3D; snapshot.
  &#x2F;&#x2F; HACK: temporarily overwrite input struct field but restore
  SaveAndRestore&lt;ReadCallback*&gt; restore_callback(&amp;get_impl_options.callback);
  const Comparator* ucmp &#x3D; get_impl_options.column_family-&gt;GetComparator();
  assert(ucmp);
  if (ucmp-&gt;timestamp_size() &gt; 0) &#123;
    assert(!get_impl_options
                .callback);  &#x2F;&#x2F; timestamp with callback is not supported
    read_cb.Refresh(snapshot);
    get_impl_options.callback &#x3D; &amp;read_cb;
  &#125;
  TEST_SYNC_POINT(&quot;DBImpl::GetImpl:3&quot;);
  TEST_SYNC_POINT(&quot;DBImpl::GetImpl:4&quot;);

  &#x2F;&#x2F; Prepare to store a list of merge operations if merge occurs.
  MergeContext merge_context;
  SequenceNumber max_covering_tombstone_seq &#x3D; 0;

  Status s;
  &#x2F;&#x2F; First look in the memtable, then in the immutable memtable (if any).
  &#x2F;&#x2F; s is both in&#x2F;out. When in, s could either be OK or MergeInProgress.
  &#x2F;&#x2F; merge_operands will contain the sequence of merges in the latter case.
  LookupKey lkey(key, snapshot, read_options.timestamp);
  &#x2F;&#x2F; ...
  if (!skip_memtable) &#123;
      &#x2F;&#x2F; ...
  &#125;
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 <a target="_blank" rel="noopener" href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-yi-shi-wu">RocksDB源码学习(一)</a> 中提到，RocksDB 的读实际上是快照读，即先生成一个 snapshot ，这个 snapshot 就是一个 seq，然后只读取该 seq 以及之前的记录，往后的均视为在读操作之后才发生的操作，所以不可见。而 GetImpl() 中就会生成这个 snapshot，然后把它视为 LookupKey 的 seq，然后只查找该 seq 之前的记录。</p>
<p>先不管 get_impl_options.callback 是什么。简单的来看，GetImpl() 首先会询问 read_options 中是否有对 snapshot 的要求，毕竟配置大于一切。如果没有，那么就通过 GetLastPublishedSequence() 获取到最新的 seq 作为 snapshot。该函数内容如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">virtual SequenceNumber GetLastPublishedSequence() const &#123;
    if (last_seq_same_as_publish_seq_) &#123;
        return versions_-&gt;LastSequence();
    &#125; else &#123;
        return versions_-&gt;LastPublishedSequence();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也就是，返回当前 version 的最新一个 seq。</p>
<p>GetImpl() 构造完 LookupKey 之后，会判断是否跳过 memtable，如果否，将会调用 MemTable::Get() 函数。该函数的部分内容如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool MemTable::Get(const LookupKey&amp; key, std::string* value,
                   PinnableWideColumns* columns, std::string* timestamp,
                   Status* s, MergeContext* merge_context,
                   SequenceNumber* max_covering_tombstone_seq,
                   SequenceNumber* seq, const ReadOptions&amp; read_opts,
                   bool immutable_memtable, ReadCallback* callback,
                   bool* is_blob_index, bool do_merge) &#123;
  &#x2F;&#x2F; ...
  bool bloom_checked &#x3D; false;
  if (bloom_filter_) &#123;
    &#x2F;&#x2F; when both memtable_whole_key_filtering and prefix_extractor_ are set,
    &#x2F;&#x2F; only do whole key filtering for Get() to save CPU
    if (moptions_.memtable_whole_key_filtering) &#123;
      may_contain &#x3D; bloom_filter_-&gt;MayContain(user_key_without_ts);
      bloom_checked &#x3D; true;
    &#125; else &#123;
      assert(prefix_extractor_);
      if (prefix_extractor_-&gt;InDomain(user_key_without_ts)) &#123;
        may_contain &#x3D; bloom_filter_-&gt;MayContain(
            prefix_extractor_-&gt;Transform(user_key_without_ts));
        bloom_checked &#x3D; true;
      &#125;
    &#125;
  &#125;

  if (bloom_filter_ &amp;&amp; !may_contain) &#123;
    &#x2F;&#x2F; iter is null if prefix bloom says the key does not exist
    PERF_COUNTER_ADD(bloom_memtable_miss_count, 1);
    *seq &#x3D; kMaxSequenceNumber;
  &#125; else &#123;
    if (bloom_checked) &#123;
      PERF_COUNTER_ADD(bloom_memtable_hit_count, 1);
    &#125;
    GetFromTable(key, *max_covering_tombstone_seq, do_merge, callback,
                 is_blob_index, value, columns, timestamp, s, merge_context,
                 seq, &amp;found_final_value, &amp;merge_in_progress);
  &#125;
  &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在截取的这部分代码中，会首先通过 bloom_filter 进行存在性检查，如果得到了阴性，那么就不会在往下进行读操作了，如果得到了阳性，那么就调用 MemTable::GetFromTable() 来进一步读取。所以，Get() 的核心就是使用 bloom_filter 进行存在性检查，之后的读操作由 GetFromTable() 来完成。</p>
<h4 id="Saver"><a href="#Saver" class="headerlink" title="Saver"></a>Saver</h4><p>GetFromTable() 的完整代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MemTable::GetFromTable(const LookupKey&amp; key,
                            SequenceNumber max_covering_tombstone_seq,
                            bool do_merge, ReadCallback* callback,
                            bool* is_blob_index, std::string* value,
                            PinnableWideColumns* columns,
                            std::string* timestamp, Status* s,
                            MergeContext* merge_context, SequenceNumber* seq,
                            bool* found_final_value, bool* merge_in_progress) &#123;
  Saver saver;
  saver.status &#x3D; s;
  saver.found_final_value &#x3D; found_final_value;
  saver.merge_in_progress &#x3D; merge_in_progress;
  saver.key &#x3D; &amp;key;
  saver.value &#x3D; value;
  saver.columns &#x3D; columns;
  saver.timestamp &#x3D; timestamp;
  saver.seq &#x3D; kMaxSequenceNumber;
  saver.mem &#x3D; this;
  saver.merge_context &#x3D; merge_context;
  saver.max_covering_tombstone_seq &#x3D; max_covering_tombstone_seq;
  saver.merge_operator &#x3D; moptions_.merge_operator;
  saver.logger &#x3D; moptions_.info_log;
  saver.inplace_update_support &#x3D; moptions_.inplace_update_support;
  saver.statistics &#x3D; moptions_.statistics;
  saver.clock &#x3D; clock_;
  saver.callback_ &#x3D; callback;
  saver.is_blob_index &#x3D; is_blob_index;
  saver.do_merge &#x3D; do_merge;
  saver.allow_data_in_errors &#x3D; moptions_.allow_data_in_errors;
  saver.protection_bytes_per_key &#x3D; moptions_.protection_bytes_per_key;
  table_-&gt;Get(key, &amp;saver, SaveValue);
  *seq &#x3D; saver.seq;
&#125;	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这一大堆代码只干了两件事，其一是构造 Saver，其二是将其交给 MemTableRep::Get() 来进一步执行读取。我们一个一个说，先看 Saver，这个结构用来保存读取时的上下文，比如 LookupKey、MemTable、SequenceNumber 等等，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Saver &#123;
  Status* status;
  const LookupKey* key;
  bool* found_final_value;  &#x2F;&#x2F; Is value set correctly? Used by KeyMayExist
  bool* merge_in_progress;
  std::string* value;
  PinnableWideColumns* columns;
  SequenceNumber seq;
  std::string* timestamp;
  const MergeOperator* merge_operator;
  &#x2F;&#x2F; the merge operations encountered;
  MergeContext* merge_context;
  SequenceNumber max_covering_tombstone_seq;
  MemTable* mem;
  Logger* logger;
  Statistics* statistics;
  bool inplace_update_support;
  bool do_merge;
  SystemClock* clock;

  ReadCallback* callback_;
  bool* is_blob_index;
  bool allow_data_in_errors;
  size_t protection_bytes_per_key;
  bool CheckCallback(SequenceNumber _seq) &#123;
    if (callback_) &#123;
      return callback_-&gt;IsVisible(_seq);
    &#125;
    return true;
  &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在构造 Saver 部分，先看这几个字段：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">saver.key &#x3D; &amp;key;
saver.value &#x3D; value;
saver.seq &#x3D; kMaxSequenceNumber;
saver.mem &#x3D; this;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，saver.key 就是传入的 LookupKey，saver.value 就是要保存值的地址，saver.mem 就是当前的 MemTable 类。需要注意的是，saver.seq 被设置为了 kMaxSequenceNumber，即最大的 seq。</p>
<h4 id="MemTableRep"><a href="#MemTableRep" class="headerlink" title="MemTableRep"></a>MemTableRep</h4><p>接下来，查看 MemTable::Get()，其完整代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MemTableRep::Get(const LookupKey&amp; k, void* callback_args,
                      bool (*callback_func)(void* arg, const char* entry)) &#123;
  auto iter &#x3D; GetDynamicPrefixIterator();
  for (iter-&gt;Seek(k.internal_key(), k.memtable_key().data());
       iter-&gt;Valid() &amp;&amp; callback_func(callback_args, iter-&gt;key());
       iter-&gt;Next()) &#123;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要知道的是，MemTableRep 这个类用来抽象不同的 MemTable 的实现，也就是说它是一个虚类，然后不同的MemTable 实现了它。实现它的数据结构有很多，每一个派生类都是一个实现方式，如下：</p>
<p><img src="https://s1.ax1x.com/2022/10/19/xsoPX9.png" alt="MemTableRep类关系"></p>
<p>但是注意，MemTableRep::Get() 没有被声明为 virtual ！也就说，具体使用哪一个函数体，将由调用者指针的类型决定，而非其指向的对象类型决定。在 MemTable::GetFromTable() 中，通过 table_ —&gt; Get(xx) 语句调用，而 table_ 的类型为 std::unique_ptr&lt; MemTable &gt;，即 MemTable*，所以不管 table_ 具体指向哪个派生类，其 Get() 的函数体均为 MemTableRep::Get() 中定义的函数体，而非派生类的函数体。</p>
<p>那么怎么区别不同的 MemTable 实现（也就是派生类）呢？关键在于迭代器的生成。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto iter &#x3D; GetDynamicPrefixIterator();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上述通过 GetDynamicPrefixIterator() 生成一个迭代器，其类型为 auto。而 GetDynamicPrefixIterator() 被声明为了 virtual，说明其函数体由 table_ 具体指向的对象类型决定，即由派生类决定。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MemTableRep &#123;
  &#x2F;&#x2F; ...
  virtual Iterator* GetIterator(Arena* arena &#x3D; nullptr) &#x3D; 0;

  virtual Iterator* GetDynamicPrefixIterator(Arena* arena &#x3D; nullptr) &#123;
    return GetIterator(arena);
  &#125;
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每个派生均有自己的迭代器，而 RocksDB 默认使用 SkipList，即 table_ 实际指向 SkipListRep 对象。</p>
<p><img src="https://s1.ax1x.com/2022/10/19/xsTi8S.png" alt="迭代器的不同实现"></p>
<p>迭代器的具体实现这里先不说，后续会专门进行 SkipList 的源码分析，那篇博客里会细说。但是不论怎么实现的， Seek() 和 Next() 的功能都是一致的，只是性能的差异罢了。继续回到 MemTableRep::Get() 中，有两个关键问题，我们一个一个分析。</p>
<ul>
<li>iter —&gt; Seek()</li>
<li>callback_func()</li>
</ul>
<h5 id="iter-gt-Seek"><a href="#iter-gt-Seek" class="headerlink" title="iter -&gt; Seek()"></a>iter -&gt; Seek()</h5><p>iter —&gt; Seek() 传递了两个参数，internal_key 和 memtable_key，也就是 kstart_ 和 start_。为了搞清楚这两个成员的内容，我们进入 LookupKey 的构造函数中看一看：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LookupKey::LookupKey(const Slice&amp; _user_key, SequenceNumber s,
                     const Slice* ts) &#123;
  size_t usize &#x3D; _user_key.size();
  size_t ts_sz &#x3D; (nullptr &#x3D;&#x3D; ts) ? 0 : ts-&gt;size();
  size_t needed &#x3D; usize + ts_sz + 13;  &#x2F;&#x2F; A conservative estimate
  char* dst;
  if (needed &lt;&#x3D; sizeof(space_)) &#123;
    dst &#x3D; space_;
  &#125; else &#123;
    dst &#x3D; new char[needed];
  &#125;
  start_ &#x3D; dst;
  &#x2F;&#x2F; NOTE: We don&#39;t support users keys of more than 2GB :)
  dst &#x3D; EncodeVarint32(dst, static_cast&lt;uint32_t&gt;(usize + ts_sz + 8));
  kstart_ &#x3D; dst;
  memcpy(dst, _user_key.data(), usize);
  dst +&#x3D; usize;
  if (nullptr !&#x3D; ts) &#123;
    memcpy(dst, ts-&gt;data(), ts_sz);
    dst +&#x3D; ts_sz;
  &#125;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst +&#x3D; 8;
  end_ &#x3D; dst;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>很明显，internal_key 就是 kstart_ ，memtable_key 就是start_。同样，LookupKey 也会选择是否给 internal_key 加上 ts，注意以下三行：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (nullptr !&#x3D; ts) &#123;
    memcpy(dst, ts-&gt;data(), ts_sz);
    dst +&#x3D; ts_sz;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，ts 由 readoptions 决定，为 readoption.timestamp。在 ReadOptions 结构体中，对该字段有如下注释：</p>
<blockquote>
<p>Timestamp of operation. Read should return the latest data visible to the specified timestamp. All timestamps of the same database must be of the same length and format. The user is responsible for providing a customized compare function via Comparator to order &lt;key, timestamp&gt; tuples.<br>For iterator, iter_start_ts is the lower bound (older) and timestamp serves as the upper bound. Versions of the same record that fall in the timestamp range will be returned. If iter_start_ts is nullptr, only the most recent version visible to timestamp is returned. The user-specified timestamp feature is still under active development, and the API is subject to change.<br>Default: nullptr</p>
</blockquote>
<p>前两句话就解释了它的作用。在读取时，可以提供一个 timestamp，然后读取操作只会返回 key 在该 ts 可见范围内最新的记录，也就是 ts 可见的且 seq 最大的记录。那么问题来了，什么叫 ts 可见？这个我现在还没弄清，猜测是小于等于 ts 的都可见，即在该时间点之前就已经成功提交的记录。</p>
<p>讨论完 ts，来看一下 type，可以看到其值为 kValueTypeForSeek，官方对它的介绍如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; kValueTypeForSeek defines the ValueType that should be passed when
&#x2F;&#x2F; constructing a ParsedInternalKey object for seeking to a particular
&#x2F;&#x2F; sequence number (since we sort sequence numbers in decreasing order
&#x2F;&#x2F; and the value type is embedded as the low 8 bits in the sequence
&#x2F;&#x2F; number in internal keys, we need to use the highest-numbered
&#x2F;&#x2F; ValueType, not the lowest).
const ValueType kValueTypeForSeek &#x3D; kTypeWideColumnEntity;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，它是所有 type 中最大的一个，值为 0x16。为什么要这么做呢？因为 type 是降序排列的，所以当 user_key、seq 都确定时，只有将 type 设为最大，LookupKey 才能成为最小的 key，然后开始向其他 type 的 key 迭代。</p>
<img src="https://s1.ax1x.com/2022/10/20/xyquHH.png" alt="简单示例" style="zoom: 67%;" />

<p>接着我们来分析源码，看看 Seek() 函数，位于 <code>memtable/skiplistrep.cc</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Advance to the first entry with a key &gt;&#x3D; target
void Seek(const Slice&amp; user_key, const char* memtable_key) override &#123;
    if (memtable_key !&#x3D; nullptr) &#123;
        iter_.Seek(memtable_key);
    &#125; else &#123;
        iter_.Seek(EncodeKey(&amp;tmp_, user_key));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先说明一点，第一个形参虽然叫 user_key，但它实际上是 LookupKey 的 internal_key。但是我们只考虑 memtable_key 不为空的情况下，即一般情况，所以 internal_key 没用了。一直追踪下去，发现它最后会调用 SkipList 的查找函数，名为 InlineSkipList&lt; Comparator &gt;::FindGreaterOrEqual()，从这一步起，开始正式在 MemTable 中查找记录。函数源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">InlineSkipList&lt;Comparator&gt;::FindGreaterOrEqual(const char* key) const &#123;
  &#x2F;&#x2F; Note: It looks like we could reduce duplication by implementing
  &#x2F;&#x2F; this function as FindLessThan(key)-&gt;Next(0), but we wouldn&#39;t be able
  &#x2F;&#x2F; to exit early on equality and the result wouldn&#39;t even be correct.
  &#x2F;&#x2F; A concurrent insert might occur after FindLessThan(key) but before
  &#x2F;&#x2F; we get a chance to call Next(0).
  Node* x &#x3D; head_;
  int level &#x3D; GetMaxHeight() - 1;
  Node* last_bigger &#x3D; nullptr;
  const DecodedKey key_decoded &#x3D; compare_.decode_key(key);
  while (true) &#123;
    Node* next &#x3D; x-&gt;Next(level);
    if (next !&#x3D; nullptr) &#123;
      PREFETCH(next-&gt;Next(level), 0, 1);
    &#125;
    &#x2F;&#x2F; Make sure the lists are sorted
    assert(x &#x3D;&#x3D; head_ || next &#x3D;&#x3D; nullptr || KeyIsAfterNode(next-&gt;Key(), x));
    &#x2F;&#x2F; Make sure we haven&#39;t overshot during our search
    assert(x &#x3D;&#x3D; head_ || KeyIsAfterNode(key_decoded, x));
    int cmp &#x3D; (next &#x3D;&#x3D; nullptr || next &#x3D;&#x3D; last_bigger)
                  ? 1
                  : compare_(next-&gt;Key(), key_decoded);
    if (cmp &#x3D;&#x3D; 0 || (cmp &gt; 0 &amp;&amp; level &#x3D;&#x3D; 0)) &#123;
      return next;
    &#125; else if (cmp &lt; 0) &#123;
      &#x2F;&#x2F; Keep searching in this list
      x &#x3D; next;
    &#125; else &#123;
      &#x2F;&#x2F; Switch to next list, reuse compare_() result
      last_bigger &#x3D; next;
      level--;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们先不具体分析这段源码，但可以看出它的目的。都知道 SkipList 是多层的结构，迭代起点为最高层的最小节点，然后通过二分慢慢往低层行进。在该函数中，一旦找到了相同的 memtable_key，或者在最底层找到了恰好大于该目标的 memtable_key，那么就返回，否则继续找。SkipList 的逻辑可以看这篇文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9d8296562806">SkipList数据结构</a>。该上段代码中，最为核心的就是 Next() 的实现以及 compare_() 的实现，这就涉及到 RocksDB 是如何实现 SkipList 的了，这里我们先不深入分析，后续会有一篇博客单独分析 SkipList 的源码实现：<a href="xxx">待填坑</a>。</p>
<p>得到查找结果后，我们还有两个问题需要解决：</p>
<ol>
<li>由于 memtable_key 是按照 user_key 是升序排列的，所以上述查找得到的 user_key 可能大于我们目标的 user_key，因此需要判断查找结果的 user_key 是否合目标吻合。</li>
<li>需要根据 type 的类型来判断这条记录是不是用来读值，如果是 delete 那当然不行。</li>
</ol>
<h5 id="SaveValue"><a href="#SaveValue" class="headerlink" title="SaveValue()"></a>SaveValue()</h5><p>callback_func() 就是解决这两个问题的，当然，不止解决他们。</p>
<p>注意在 MemTable::GetFromTable() 调用 MemTable::Get() 时，传递的参数为 (key, &amp;saver, SaveValue)。因此，callback_func() 实际长这样：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">SaveValue(&amp;saver, iter-&gt;key());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>SaveValue() 函数比较长，但 switch-case 占了大部分，而且实现逻辑也很简单，这里截取重要的部分：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static bool SaveValue(void* arg, const char* entry) &#123;
  Saver* s &#x3D; reinterpret_cast&lt;Saver*&gt;(arg);
    
  &#x2F;&#x2F; ...
    
  const char* key_ptr &#x3D; GetVarint32Ptr(entry, entry + 5, &amp;key_length);
  Slice user_key_slice &#x3D; Slice(key_ptr, key_length - 8);
  const Comparator* user_comparator &#x3D;
      s-&gt;mem-&gt;GetInternalKeyComparator().user_comparator();
  size_t ts_sz &#x3D; user_comparator-&gt;timestamp_size();
  if (ts_sz &amp;&amp; s-&gt;timestamp &amp;&amp; max_covering_tombstone_seq &gt; 0) &#123;
    &#x2F;&#x2F; timestamp should already be set to range tombstone timestamp
    assert(s-&gt;timestamp-&gt;size() &#x3D;&#x3D; ts_sz);
  &#125;
  if (user_comparator-&gt;EqualWithoutTimestamp(user_key_slice,
                                             s-&gt;key-&gt;user_key()))&#123;
    &#x2F;&#x2F; Correct user key
    const uint64_t tag &#x3D; DecodeFixed64(key_ptr + key_length - 8);
    ValueType type;
    SequenceNumber seq;
    UnPackSequenceAndType(tag, &amp;seq, &amp;type);
    &#x2F;&#x2F; If the value is not in the snapshot, skip it
    if (!s-&gt;CheckCallback(seq)) &#123;
      return true;  &#x2F;&#x2F; to continue to the next seq
    &#125;
      
    &#x2F;&#x2F; ...
      
    if (ts_sz &gt; 0 &amp;&amp; s-&gt;timestamp !&#x3D; nullptr) &#123;
      if (!s-&gt;timestamp-&gt;empty()) &#123;
        assert(ts_sz &#x3D;&#x3D; s-&gt;timestamp-&gt;size());
      &#125;
      &#x2F;&#x2F; TODO optimize for smaller size ts
      const std::string kMaxTs(ts_sz, &#39;\xff&#39;);
      if (s-&gt;timestamp-&gt;empty() ||
          user_comparator-&gt;CompareTimestamp(*(s-&gt;timestamp), kMaxTs) &#x3D;&#x3D; 0) &#123;
        Slice ts &#x3D; ExtractTimestampFromUserKey(user_key_slice, ts_sz);
        s-&gt;timestamp-&gt;assign(ts.data(), ts_sz);
      &#125;
    &#125;
    
    &#x2F;&#x2F; ...
   
    switch (type) &#123;
      &#x2F;&#x2F; ... case xxx
      case kTypeValue: &#123;
        if (s-&gt;inplace_update_support) &#123;
          s-&gt;mem-&gt;GetLock(s-&gt;key-&gt;user_key())-&gt;ReadLock();
        &#125;
        Slice v &#x3D; GetLengthPrefixedSlice(key_ptr + key_length);
        *(s-&gt;status) &#x3D; Status::OK();
        if (*(s-&gt;merge_in_progress)) &#123;
          if (s-&gt;do_merge) &#123;
            if (s-&gt;value !&#x3D; nullptr) &#123;
              *(s-&gt;status) &#x3D; MergeHelper::TimedFullMerge(
                  merge_operator, s-&gt;key-&gt;user_key(), &amp;v,
                  merge_context-&gt;GetOperands(), s-&gt;value, s-&gt;logger,
                  s-&gt;statistics, s-&gt;clock, nullptr &#x2F;* result_operand *&#x2F;, true);
            &#125;
          &#125; else &#123;
            &#x2F;&#x2F; Preserve the value with the goal of returning it as part of
            &#x2F;&#x2F; raw merge operands to the user
            merge_context-&gt;PushOperand(
                v, s-&gt;inplace_update_support &#x3D;&#x3D; false &#x2F;* operand_pinned *&#x2F;);
          &#125;
        &#125; else if (!s-&gt;do_merge) &#123;
          &#x2F;&#x2F; Preserve the value with the goal of returning it as part of
          &#x2F;&#x2F; raw merge operands to the user
          merge_context-&gt;PushOperand(
              v, s-&gt;inplace_update_support &#x3D;&#x3D; false &#x2F;* operand_pinned *&#x2F;);
        &#125; else if (s-&gt;value) &#123;
          if (type !&#x3D; kTypeWideColumnEntity) &#123;
            assert(type &#x3D;&#x3D; kTypeValue || type &#x3D;&#x3D; kTypeBlobIndex);
            s-&gt;value-&gt;assign(v.data(), v.size());
          &#125; else &#123;
            Slice value;
            *(s-&gt;status) &#x3D;
                WideColumnSerialization::GetValueOfDefaultColumn(v, value);
            if (s-&gt;status-&gt;ok()) &#123;
              s-&gt;value-&gt;assign(value.data(), value.size());
            &#125;
          &#125;
        &#125; else if (s-&gt;columns) &#123;
          if (type !&#x3D; kTypeWideColumnEntity) &#123;
            s-&gt;columns-&gt;SetPlainValue(v);
          &#125; else &#123;
            *(s-&gt;status) &#x3D; s-&gt;columns-&gt;SetWideColumnValue(v);
          &#125;
        &#125;

        if (s-&gt;inplace_update_support) &#123;
          s-&gt;mem-&gt;GetLock(s-&gt;key-&gt;user_key())-&gt;ReadUnlock();
        &#125;
        *(s-&gt;found_final_value) &#x3D; true;
        if (s-&gt;is_blob_index !&#x3D; nullptr) &#123;
          *(s-&gt;is_blob_index) &#x3D; (type &#x3D;&#x3D; kTypeBlobIndex);
        &#125;

        return false;
      &#125;
      case kTypeDeletion:
      case kTypeDeletionWithTimestamp:
      case kTypeSingleDeletion:
      case kTypeRangeDeletion: &#123;
        if (*(s-&gt;merge_in_progress)) &#123;
          if (s-&gt;value !&#x3D; nullptr) &#123;
            *(s-&gt;status) &#x3D; MergeHelper::TimedFullMerge(
                merge_operator, s-&gt;key-&gt;user_key(), nullptr,
                merge_context-&gt;GetOperands(), s-&gt;value, s-&gt;logger,
                s-&gt;statistics, s-&gt;clock, nullptr &#x2F;* result_operand *&#x2F;, true);
          &#125;
        &#125; else &#123;
          *(s-&gt;status) &#x3D; Status::NotFound();
        &#125;
        *(s-&gt;found_final_value) &#x3D; true;
        return false;
      &#125;
      case kTypeMerge: &#123;
          &#x2F;&#x2F; ...
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先，该函数判断找到的 user_key 是否为目标 user_key，使用的函数为 EqualWithoutTimestamp()，即在不考虑 ts 部分的情况下去比较两个 user_key 是否相同。接着，从找到的 user_key 中将其的 ts 提取出来，赋值给 saver 的 timestamp 字段。</p>
<p>在 switch-case 代码中，要注意，<strong>没有 break</strong>。</p>
<p>在 switch-case 代码中，我们先看 delete 相关。kTypeDeletion、kTypeDeletionWithTimestamp、kTypeSingleDeletion 都没有加 break，说明它们的操作都一样，交给 kTypeRangeDeletion 来做。简单的来看，当读到 delete 时，会触发一些 merge 操作，促使这个 user_key 被清理掉，或者直接返回 NotFound。</p>
<p>只有当 type 为 kTypeValue，才说明这条记录是被 Put 的，应该读值，所以我们重点关注它。在代码块中，有一些 merge 操作和 column 操作，我们不过，merge 会在另一篇博客中详细说明：<a href="xxx">待填坑</a>。但是，可以看出的是，这一块主要是把找到的 user_key 的 value 赋值给 saver 中的 value，来作为最终的 Get 结果，然后将 found_final_value 设为 true，代表成功读取到 value。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">else if (s-&gt;value) &#123;
    if (type !&#x3D; kTypeWideColumnEntity) &#123;
        assert(type &#x3D;&#x3D; kTypeValue || type &#x3D;&#x3D; kTypeBlobIndex);
        s-&gt;value-&gt;assign(v.data(), v.size());
    &#125; else &#123;
        Slice value;
        *(s-&gt;status) &#x3D;
            WideColumnSerialization::GetValueOfDefaultColumn(v, value);
        if (s-&gt;status-&gt;ok()) &#123;
            s-&gt;value-&gt;assign(value.data(), value.size());
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那现在问题来了，只有当 s-&gt;value != nullptr 的时候，才会进行其中执行赋值，可是 s-&gt;value 本身就是用来保存查询结果的，那么此时它不应该还是空吗？还真不是，它确实没有值，但它不是 nullptr，它明确的指向了一个变量，所以判断能够成立。</p>
<h3 id="从-Txn-复盘调用链"><a href="#从-Txn-复盘调用链" class="headerlink" title="从 Txn 复盘调用链"></a>从 Txn 复盘调用链</h3><p>接下来我们就追溯这个 saver.value，看看它到底指向谁。这里一直要追溯到最上层的调用者，不管是读是写，调用者均为事务，因此要从 Transaction 开始追溯。RocksDB 提供了一段关于事务的示例代码，位于 <code>examples/transaction_example.cc</code> 中。刚好，借这个机会，我们从头开始捋一遍读取的流程，一直到从 MemTable 中找到 user_key。</p>
<p>函数链太长了，直接用图来表示，画板地址：<a target="_blank" rel="noopener" href="https://www.yuque.com/u2153859/opg8lz/bq8l1y">读操作函数调用链（上）- memtable</a></p>
<p><img src="https://s1.ax1x.com/2022/10/20/x6nuSx.png" alt="读操作函数调用链（上）"></p>
<p>由此就可以回答上一章节遗留的问题了，saver.value 从始至终都指向了一个空值的 string，这个 string 是调用者用来保存读取结果 value 的，所以它并不是 nullptr。故 SaveValue 会在赋值前先判断 saver.value 是否为 nullptr，因为要确保调用者确确实实给它分配了一块空间用来存储，如果 saver.value 为 nullptr，则说明调用者根本没有分配空间来保存结果，当然不会在执行赋值了。</p>
<hr>
<p>至此，RocksDB 的读框架以及在 memtable 的读操作就大致理完了，下一篇博客将关注在 sstable 中的读取。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">SrcMiLe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/rocksdb-yuan-ma-xue-xi-er-du-yi/">http://example.com/rocksdb-yuan-ma-xue-xi-er-du-yi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">SrcMiLe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%AD%98%E5%82%A8/">
                                    <span class="chip bg-color">存储</span>
                                </a>
                            
                                <a href="/tags/rocksdb/">
                                    <span class="chip bg-color">rocksdb</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/rocksdb-yuan-ma-xue-xi-er-du-yi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="RocksDB源码学习(二): 读(一)">
                        
                        <span class="card-title">RocksDB源码学习(二): 读(一)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%98%E5%82%A8/" class="post-category">
                                    存储
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%98%E5%82%A8/">
                        <span class="chip bg-color">存储</span>
                    </a>
                    
                    <a href="/tags/rocksdb/">
                        <span class="chip bg-color">rocksdb</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/k8s-yuan-ma-xi-lie-wen-zhang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="k8s源码系列文章">
                        
                        <span class="card-title">k8s源码系列文章</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/k8s%E6%BA%90%E7%A0%81/" class="post-category">
                                    k8s源码
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">
                        <span class="chip bg-color">云计算</span>
                    </a>
                    
                    <a href="/tags/k8s/">
                        <span class="chip bg-color">k8s</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                            <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <span id="year">2022</span>
            <a href="/about" target="_blank">SrcMiLe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2022";
                    var startMonth = "1";
                    var startDate = "12";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/sakura-ysy" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2575633193@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2575633193" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2575633193" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        

                                                                                                
                                                                                                    
                                                                                                        <script
                                                                                                            type="text/javascript"
                                                                                                            size="150"
                                                                                                            alpha='0.6'
                                                                                                            zIndex="-1"
                                                                                                            src="/libs/background/ribbon-refresh.min.js"
                                                                                                            async="async"></script>
                                                                                                        

                                                                                                            

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        

                </body>

</html>

<!-- 樱花 -->
<script type="text/javascript" src="/js/sakura.js"></script>