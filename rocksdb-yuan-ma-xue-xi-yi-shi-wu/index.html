<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="RocksDB源码学习(一): 事务, SrcMiLeの杂货铺">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>RocksDB源码学习(一): 事务 | SrcMiLeの杂货铺</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>


    

                <body>
                    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/avatar.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">SrcMiLeの杂货铺</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>放映室</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>破书架</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/avatar.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">SrcMiLeの杂货铺</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>放映室</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>破书架</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/sakura-ysy" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/sakura-ysy" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

                        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">RocksDB源码学习(一): 事务</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%AD%98%E5%82%A8/">
                                <span class="chip bg-color">存储</span>
                            </a>
                        
                            <a href="/tags/rocksdb/">
                                <span class="chip bg-color">rocksdb</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%98%E5%82%A8/" class="post-category">
                                存储
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-10-16
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    6.9k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>本篇博客试图从宏观上理一下 RocksDB 有关事务的部分。内容包含 DB、Transaction、WriteBatch、Sequence Num、Snapshot、Lock 等等。</p>
<p>注：本篇博客除了另行说明的代码截图版本为<code>v5.18.4</code>，其余所有代码框里的代码版本均为 <code>v7.7.3</code>。</p>
<h2 id="事务类"><a href="#事务类" class="headerlink" title="事务类"></a>事务类</h2><p>首先，和事务有关的主要类关系，如下图所示（<a target="_blank" rel="noopener" href="https://www.yuque.com/u2153859/opg8lz/glq0ay/edit">画板地址</a>），图只罗列了部分，很不全，画板会更新。</p>
<p><img src="https://s1.ax1x.com/2022/10/16/xBaYq0.png" alt="事务类关系"></p>
<h3 id="DB-相关"><a href="#DB-相关" class="headerlink" title="DB 相关"></a>DB 相关</h3><p>这一部分的类会实现底层的读写等操作，提供 API 供真正的事务去调用，相当于整个事务模块的基石，由接口类 DB 派生而来。</p>
<img src="https://s1.ax1x.com/2022/10/18/xrmfnH.png" alt="DB类关系" style="zoom: 67%;" />

<p>其中，最重要的两个类为 TransactionDB 与 DBImpl，前者实现事务的管理，后者实现 DB 接口类中的各个函数。</p>
<h4 id="TransactionDB"><a href="#TransactionDB" class="headerlink" title="TransactionDB"></a>TransactionDB</h4><p>TransactionDB 声明于 <code>include\rocksdb\utilities\transaction_db.h</code> 中，其可以理解为 Transaction 的容器，一个 TransactionDB 内部可以有多个 Transaction，看下这个类的源码，其中就有创建和获取 Transaction。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class TransactionDB : public StackableDB &#123;
 public:
  &#x2F;&#x2F; Starts a new Transaction.
  &#x2F;&#x2F;
  &#x2F;&#x2F; Caller is responsible for deleting the returned transaction when no
  &#x2F;&#x2F; longer needed.
  &#x2F;&#x2F;
  &#x2F;&#x2F; If old_txn is not null, BeginTransaction will reuse this Transaction
  &#x2F;&#x2F; handle instead of allocating a new one.  This is an optimization to avoid
  &#x2F;&#x2F; extra allocations when repeatedly creating transactions.
  virtual Transaction* BeginTransaction(
      const WriteOptions&amp; write_options,
      const TransactionOptions&amp; txn_options &#x3D; TransactionOptions(),
      Transaction* old_txn &#x3D; nullptr) &#x3D; 0;

  virtual Transaction* GetTransactionByName(const TransactionName&amp; name) &#x3D; 0;
  virtual void GetAllPreparedTransactions(std::vector&lt;Transaction*&gt;* trans) &#x3D; 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="DBImpl"><a href="#DBImpl" class="headerlink" title="DBImpl"></a>DBImpl</h4><p>接下来关注 DBImpl，这个类声明于 <code>db\db_impl\db_impl.h</code> 中，可以说是整个事务框架中<strong>最重要</strong>的一个类，因为它才是真正实现所有读写以及 LSM-Tree 相关操作的实现类，先来看下官方的解释：</p>
<blockquote>
<p>While DB is the public interface of RocksDB, and DBImpl is the actual class implementing it. It’s the entrance of the core RocksdB engine. All other DB implementations, e.g. TransactionDB, BlobDB, etc, wrap a DBImpl internally. Other than functions implementing the DB interface, some public functions are there for other internal components to call. For example, TransactionDB directly calls DBImpl::WriteImpl() and BlobDB directly calls DBImpl::GetImpl(). Some other functions are for sub-components to call. For example, ColumnFamilyHandleImpl calls DBImpl::FindObsoleteFiles().</p>
<p>Since it’s a very large class, the definition of the functions is divided in several db_impl_*.cc files, besides db_impl.cc.</p>
</blockquote>
<p>也就是说，DB 这个类声明了整个 RocksDB 事务有关的接口，也就是接口类，而 DBImpl 真正实现了这些接口，相当于内部存储引擎的入口类。其他所有的相关实现类，包括 TransactionDB、BlobDB 等等，实际上都是在内部封装了 DBImpl 罢了。所以记住，这个类实现了最底层的读写。</p>
<p>这个类中的成员函数超级多，比如 PUT、Merge、Delete、Write、Get、MultiGet、NewIterator、CreateColumnFamilies、Flush 等等，这里有罗列几个，因为太多了。这些函数的定义大部分都位于同目录下的 <code>db_impl.cc</code> 中，进去就可以看见这些函数的函数体。</p>
<p>注意，我说的是大部分。DBImpl 中的函数太多太复杂了，因此 RocksDB 没有在一个文件中把他们全部定义完，而是又分出了两个派生类：DBImplSecondary 和 DBImplReadOnly，都是 DBImpl 的派生类，位于同级目录下。在 <code>db_impl.cc</code> 中没有定义的函数，均在两个派生类中以 override 的方式实现，定义于 <code>db_impl_secondary.h</code>、<code>db_impl_secondary.cc</code>、<code>db_impl_readonly.h</code>、<code>db_impl_readonly.cc</code> 中，这里不展示代码了。</p>
<p>因此，想要看事务的底层实现，那就着重去看 <code>db_impl_*.cc / .h </code> 。</p>
<h3 id="Transaction-相关"><a href="#Transaction-相关" class="headerlink" title="Transaction 相关"></a>Transaction 相关</h3><p>事务最直接的类就是 Transaction，声明于 <code>include\rocksdb\utilities\transaction.h</code> 中，其中声明了与 snapshot、lock、commit 有关的函数，还有基本的 Get 和 Put。当然，它的底层操作还是要基于 DB 的。</p>
<p>官方对该类的解释如下：</p>
<blockquote>
<p>Provides BEGIN/COMMIT/ROLLBACK transactions.</p>
<p>To use transactions, you must first create either an OptimisticTransactionDB or a TransactionDB.  See examples/[optimistic_]transaction_example.cc for more information.</p>
<p>To create a transaction, use [Optimistic]TransactionDB::BeginTransaction(). It is up to the caller to synchronize access to this object.</p>
<p>See examples/transaction_example.cc for some simple examples.</p>
</blockquote>
<p>可以看出，这个类的创建是基于 OptimisticTransactionDB 或 TransactionDB，所以在前文中说 TransactionDB 就是 Transaction 的容器。该类中的方法由派生类 TransactionBaseImpl 实现，其声明于 <code>utilities\transactions\transaction_base.h</code> 中，方法定义于同级目录下的 <code>transaction_base.cc</code> 中。</p>
<img src="https://s1.ax1x.com/2022/10/18/xrnCCV.png" alt="Transaction类关系.png" style="zoom:67%;" />

<p>事务分为悲观事务和乐观事务，分别为 PessimisticTransaction 和 OptimisticTransaction。其中，前者认为会通过加锁的方式解决写冲突，后者会通过 version 的方式来解决写冲突。</p>
<p>为了明晰两者的差别，我们先看一下 Transaction::Put 方法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status TransactionBaseImpl::Put(ColumnFamilyHandle* column_family,
                                const Slice&amp; key, const Slice&amp; value,
                                const bool assume_tracked) &#123;
  const bool do_validate &#x3D; !assume_tracked;
  Status s &#x3D; TryLock(column_family, key, false &#x2F;* read_only *&#x2F;,
                     true &#x2F;* exclusive *&#x2F;, do_validate, assume_tracked);

  if (s.ok()) &#123;
    s &#x3D; GetBatchForWrite()-&gt;Put(column_family, key, value);
    if (s.ok()) &#123;
      num_puts_++;
    &#125;
  &#125;

  return s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>细节我们先不深究，但是可以看出来，Put 操作，首先要对 key 进行 “加锁”，然后在把写操作写进 WriteBatch 中。Transaction 不会直接把写操作执行，而是写放进 WriteBatch 中，等 Commit 了之后一同写进去，这点和 TinyKV 类似。 至于 WriteBatch 的内容，后面会分析，这里先过掉。</p>
<p>实际上，不管是 PessimisticTransaction  还是 OptimisticTransaction，Put 的时候用到都是上面那个方法体，只不过，那个所谓的 “加锁” 操作变了，也就是 TryLock，直接区分了两种事务的核心。二者均重载了 TryLock，一个以 lock 的方式，一个以 version 的方式。</p>
<h4 id="PessimisticTransaction"><a href="#PessimisticTransaction" class="headerlink" title="PessimisticTransaction"></a>PessimisticTransaction</h4><p>其 TryLock 部分源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Attempt to lock this key.
&#x2F;&#x2F; Returns OK if the key has been successfully locked.  Non-ok, otherwise.
&#x2F;&#x2F; If check_shapshot is true and this transaction has a snapshot set,
&#x2F;&#x2F; this key will only be locked if there have been no writes to this key since
&#x2F;&#x2F; the snapshot time.
Status PessimisticTransaction::TryLock(ColumnFamilyHandle* column_family,
                                       const Slice&amp; key, bool read_only,
                                       bool exclusive, const bool do_validate,
                                       const bool assume_tracked) &#123;
  &#x2F;&#x2F; ...

  &#x2F;&#x2F; Lock this key if this transactions hasn&#39;t already locked it or we require
  &#x2F;&#x2F; an upgrade.
  if (!previously_locked || lock_upgrade) &#123;
    s &#x3D; txn_db_impl_-&gt;TryLock(this, cfh_id, key_str, exclusive);
  &#125;

  const ColumnFamilyHandle* const cfh &#x3D;
      column_family ? column_family : db_impl_-&gt;DefaultColumnFamily();
  assert(cfh);
  const Comparator* const ucmp &#x3D; cfh-&gt;GetComparator();
  assert(ucmp);
  size_t ts_sz &#x3D; ucmp-&gt;timestamp_size();

  SetSnapshotIfNeeded();

  &#x2F;&#x2F; Even though we do not care about doing conflict checking for this write,
  &#x2F;&#x2F; we still need to take a lock to make sure we do not cause a conflict with
  &#x2F;&#x2F; some other write.  However, we do not need to check if there have been
  &#x2F;&#x2F; any writes since this transaction&#39;s snapshot.
  &#x2F;&#x2F; TODO(agiardullo): could optimize by supporting shared txn locks in the
  &#x2F;&#x2F; future.
  SequenceNumber tracked_at_seq &#x3D;
      status.locked ? status.seq : kMaxSequenceNumber;
  if (!do_validate || (snapshot_ &#x3D;&#x3D; nullptr &amp;&amp;
                       (0 &#x3D;&#x3D; ts_sz || kMaxTxnTimestamp &#x3D;&#x3D; read_timestamp_))) &#123;
    if (assume_tracked &amp;&amp; !previously_locked &amp;&amp;
        tracked_locks_-&gt;IsPointLockSupported()) &#123;
      s &#x3D; Status::InvalidArgument(
          &quot;assume_tracked is set but it is not tracked yet&quot;);
    &#125;
    &#x2F;&#x2F; Need to remember the earliest sequence number that we know that this
    &#x2F;&#x2F; key has not been modified after.  This is useful if this same
    &#x2F;&#x2F; transaction later tries to lock this key again.
    if (tracked_at_seq &#x3D;&#x3D; kMaxSequenceNumber) &#123;
      &#x2F;&#x2F; Since we haven&#39;t checked a snapshot, we only know this key has not
      &#x2F;&#x2F; been modified since after we locked it.
      &#x2F;&#x2F; Note: when last_seq_same_as_publish_seq_&#x3D;&#x3D;false this is less than the
      &#x2F;&#x2F; latest allocated seq but it is ok since i) this is just a heuristic
      &#x2F;&#x2F; used only as a hint to avoid actual check for conflicts, ii) this would
      &#x2F;&#x2F; cause a false positive only if the snapthot is taken right after the
      &#x2F;&#x2F; lock, which would be an unusual sequence.
      tracked_at_seq &#x3D; db_-&gt;GetLatestSequenceNumber();
    &#125;
  &#125; else if (s.ok()) &#123;
    &#x2F;&#x2F; If a snapshot is set, we need to make sure the key hasn&#39;t been modified
    &#x2F;&#x2F; since the snapshot.  This must be done after we locked the key.
    &#x2F;&#x2F; If we already have validated an earilier snapshot it must has been
    &#x2F;&#x2F; reflected in tracked_at_seq and ValidateSnapshot will return OK.
    s &#x3D; ValidateSnapshot(column_family, key, &amp;tracked_at_seq);

    if (!s.ok()) &#123;
      &#x2F;&#x2F; Failed to validate key
      &#x2F;&#x2F; Unlock key we just locked
      if (lock_upgrade) &#123;
        s &#x3D; txn_db_impl_-&gt;TryLock(this, cfh_id, key_str, false &#x2F;* exclusive *&#x2F;);
        assert(s.ok());
      &#125; else if (!previously_locked) &#123;
        txn_db_impl_-&gt;UnLock(this, cfh_id, key.ToString());
      &#125;
    &#125;
  &#125;

  if (s.ok()) &#123;
    &#x2F;&#x2F; We must track all the locked keys so that we can unlock them later. If
    &#x2F;&#x2F; the key is already locked, this func will update some stats on the
    &#x2F;&#x2F; tracked key. It could also update the tracked_at_seq if it is lower
    &#x2F;&#x2F; than the existing tracked key seq. These stats are necessary for
    &#x2F;&#x2F; RollbackToSavePoint to determine whether a key can be safely removed
    &#x2F;&#x2F; from tracked_keys_. Removal can only be done if a key was only locked
    &#x2F;&#x2F; during the current savepoint.
    &#x2F;&#x2F;
    &#x2F;&#x2F; Recall that if assume_tracked is true, we assume that TrackKey has been
    &#x2F;&#x2F; called previously since the last savepoint, with the same exclusive
    &#x2F;&#x2F; setting, and at a lower sequence number, so skipping here should be
    &#x2F;&#x2F; safe.
    if (!assume_tracked) &#123;
      TrackKey(cfh_id, key_str, tracked_at_seq, read_only, exclusive);
    &#125; else &#123;
#ifndef NDEBUG
      if (tracked_locks_-&gt;IsPointLockSupported()) &#123;
        PointLockStatus lock_status &#x3D;
            tracked_locks_-&gt;GetPointLockStatus(cfh_id, key_str);
        assert(lock_status.locked);
        assert(lock_status.seq &lt;&#x3D; tracked_at_seq);
        assert(lock_status.exclusive &#x3D;&#x3D; exclusive);
      &#125;
#endif
    &#125;
  &#125;

  return s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，该函数的核心就是通过调用 txn_db_impl_-&gt;TryLock 来进行加锁。其中，txn_db_impl 的类型就是 PessimisticTransactionDB，这也反映了 xxxTransaction  调到最后都是 TransactionDB。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">PessimisticTransactionDB* txn_db_impl_;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那我们就看一下 PessimisticTransactionDB 的 TryLock 是什么样的，其源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status PessimisticTransactionDB::TryLock(PessimisticTransaction* txn,
                                         uint32_t cfh_id,
                                         const std::string&amp; key,
                                         bool exclusive) &#123;
    return lock_manager_-&gt;TryLock(txn, cfh_id, key, GetEnv(), exclusive);
&#125;

&#x2F;&#x2F; 补充
&#x2F;&#x2F; std::shared_ptr&lt;LockManager&gt; lock_manager_; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，最后实际执行加锁的其实是 LockManager 这个类，这个类我们先不管，到这只需要明白 PessimisticTransaction 是通过它来对 key 进行加锁的就行，细节之后再分析。</p>
<h4 id="OptimisticTransaction"><a href="#OptimisticTransaction" class="headerlink" title="OptimisticTransaction"></a>OptimisticTransaction</h4><p>不同于 PessimisticTransaction ，OptimisticTransaction 没有 lock 一说，用的是 version 的思想，也就是 MVCC，多版本并发控制。其 TryLock 全部源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Record this key so that we can check it for conflicts at commit time.
&#x2F;&#x2F;
&#x2F;&#x2F; &#39;exclusive&#39; is unused for OptimisticTransaction.
Status OptimisticTransaction::TryLock(ColumnFamilyHandle* column_family,
                                      const Slice&amp; key, bool read_only,
                                      bool exclusive, const bool do_validate,
                                      const bool assume_tracked) &#123;
  assert(!assume_tracked);  &#x2F;&#x2F; not supported
  (void)assume_tracked;
  if (!do_validate) &#123;
    return Status::OK();
  &#125;
  uint32_t cfh_id &#x3D; GetColumnFamilyID(column_family);

  SetSnapshotIfNeeded();

  SequenceNumber seq;
  if (snapshot_) &#123;
    seq &#x3D; snapshot_-&gt;GetSequenceNumber();
  &#125; else &#123;
    seq &#x3D; db_-&gt;GetLatestSequenceNumber();
  &#125;

  std::string key_str &#x3D; key.ToString();

  TrackKey(cfh_id, key_str, seq, read_only, exclusive);

  &#x2F;&#x2F; Always return OK. Confilct checking will happen at commit time.
  return Status::OK();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个 TryLock 就比较简单了，根本就没有锁，它会先生产一个新的 sequenceNum ，然后通过 TrackKey 将其和 key 整合起来。怎么整合的，以及整合后 key 的结构是什么，这些以后都会说，这里先不管这么细。</p>
<p>这个 sequenceNum ，会在 Commit 的时候用来检测冲突，检测操作封装在 CheckTransactionForConflict 中，Commit 会调用这个函数。该函数源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Returns OK if it is safe to commit this transaction.  Returns Status::Busy
&#x2F;&#x2F; if there are read or write conflicts that would prevent us from committing OR
&#x2F;&#x2F; if we can not determine whether there would be any such conflicts.
&#x2F;&#x2F;
&#x2F;&#x2F; Should only be called on writer thread in order to avoid any race conditions
&#x2F;&#x2F; in detecting write conflicts.
Status OptimisticTransaction::CheckTransactionForConflicts(DB* db) &#123;
  auto db_impl &#x3D; static_cast_with_check&lt;DBImpl&gt;(db);

  &#x2F;&#x2F; Since we are on the write thread and do not want to block other writers,
  &#x2F;&#x2F; we will do a cache-only conflict check.  This can result in TryAgain
  &#x2F;&#x2F; getting returned if there is not sufficient memtable history to check
  &#x2F;&#x2F; for conflicts.
  return TransactionUtil::CheckKeysForConflicts(db_impl, *tracked_locks_,
                                                true &#x2F;* cache_only *&#x2F;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>具体怎么检测的，我们先不管。</p>
<h3 id="WriteBatch-相关"><a href="#WriteBatch-相关" class="headerlink" title="WriteBatch 相关"></a>WriteBatch 相关</h3><p>如前文所述，事务会将所有的写操作追加进同一个 WriteBatch 中，直到 Commit 时才向 DB 中进行写入。与 WriteBatch 有关的主要为 4 个类，如下：</p>
<img src="https://s1.ax1x.com/2022/10/18/xrnP3T.png" alt="WriteBatch类关系.png" style="zoom:67%;" />

<h4 id="WriteBatchWithIndex"><a href="#WriteBatchWithIndex" class="headerlink" title="WriteBatchWithIndex"></a>WriteBatchWithIndex</h4><p>WriteBatchWithIndex 是 WriteBatch 的辅助结构，额外搞一个 skip-list 来记录每一个操作在 WriteBatch 中的 offset 等信息。其声明于 <code>include/rocksdb/utilities/write_batch_with_index.h</code> 中，官方对它的解释如下：</p>
<blockquote>
<p>A WriteBatchWithIndex with a binary searchable index built for all the keys inserted.<br>In Put(), Merge() Delete(), or SingleDelete(), the same function of the wrapped will be called. At the same time, indexes will be built.<br>By calling GetWriteBatch(), a user will get the WriteBatch for the data they inserted, which can be used for DB::Write().<br>A user can call NewIterator() to create an iterator.</p>
</blockquote>
<p>从上述可以得到两个信息：</p>
<ol>
<li>每一个写操作都会被赋予一个 index；</li>
<li>通过函数 GetWriteBatch()，可以得到这个事务的 WriteBatch；</li>
</ol>
<p>这里我们提下第二点。GetWriteBatch() 的定义很简单，就一句话，如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">WriteBatch* WriteBatchWithIndex::GetWriteBatch() &#123; return &amp;rep-&gt;write_batch; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也即，它会返回 WriteBatchWithIndex 中一个名为 rep 的成员的 write_batch 字段。而 rep 是一个 Rep 类型的结构指针，如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class WriteBatchWithIndex &#123;
    &#x2F;&#x2F; ...
    private:
    	struct Rep;
    	std::unique_ptr&lt;Rep&gt; rep;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟进 Rep 结构，其结构体如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct WriteBatchWithIndex::Rep &#123;
  explicit Rep(const Comparator* index_comparator, size_t reserved_bytes &#x3D; 0,
               size_t max_bytes &#x3D; 0, bool _overwrite_key &#x3D; false,
               size_t protection_bytes_per_key &#x3D; 0)
      : write_batch(reserved_bytes, max_bytes, protection_bytes_per_key,
                    index_comparator ? index_comparator-&gt;timestamp_size() : 0),
        comparator(index_comparator, &amp;write_batch),
        skip_list(comparator, &amp;arena),
        overwrite_key(_overwrite_key),
        last_entry_offset(0),
        last_sub_batch_offset(0),
        sub_batch_cnt(1) &#123;&#125;
  ReadableWriteBatch write_batch;
  WriteBatchEntryComparator comparator;
  Arena arena;
  WriteBatchEntrySkipList skip_list;
  bool overwrite_key;
  size_t last_entry_offset;
  &#x2F;&#x2F; The starting offset of the last sub-batch. A sub-batch starts right before
  &#x2F;&#x2F; inserting a key that is a duplicate of a key in the last sub-batch. Zero,
  &#x2F;&#x2F; the default, means that no duplicate key is detected so far.
  size_t last_sub_batch_offset;
  &#x2F;&#x2F; Total number of sub-batches in the write batch. Default is 1.
  size_t sub_batch_cnt;

  &#x2F;&#x2F; Remember current offset of internal write batch, which is used as
  &#x2F;&#x2F; the starting offset of the next record.
  void SetLastEntryOffset() &#123; last_entry_offset &#x3D; write_batch.GetDataSize(); &#125;

  &#x2F;&#x2F; In overwrite mode, find the existing entry for the same key and update it
  &#x2F;&#x2F; to point to the current entry.
  &#x2F;&#x2F; Return true if the key is found and updated.
  bool UpdateExistingEntry(ColumnFamilyHandle* column_family, const Slice&amp; key,
                           WriteType type);
  bool UpdateExistingEntryWithCfId(uint32_t column_family_id, const Slice&amp; key,
                                   WriteType type);

  &#x2F;&#x2F; Add the recent entry to the update.
  &#x2F;&#x2F; In overwrite mode, if key already exists in the index, update it.
  void AddOrUpdateIndex(ColumnFamilyHandle* column_family, const Slice&amp; key,
                        WriteType type);
  void AddOrUpdateIndex(const Slice&amp; key, WriteType type);

  &#x2F;&#x2F; Allocate an index entry pointing to the last entry in the write batch and
  &#x2F;&#x2F; put it to skip list.
  void AddNewEntry(uint32_t column_family_id);

  &#x2F;&#x2F; Clear all updates buffered in this batch.
  void Clear();
  void ClearIndex();

  &#x2F;&#x2F; Rebuild index by reading all records from the batch.
  &#x2F;&#x2F; Returns non-ok status on corruption.
  Status ReBuildIndex();
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意到，write_batch 的类型为 ReadableWriteBatch，字面意思就是可读的 WriteBatch，而整个类型里只有一个函数，专门用于通过 offset 来找到 WriteBatch 中某一条写操作，如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class ReadableWriteBatch : public WriteBatch &#123;
 public:
  explicit ReadableWriteBatch(size_t reserved_bytes &#x3D; 0, size_t max_bytes &#x3D; 0,
                              size_t protection_bytes_per_key &#x3D; 0,
                              size_t default_cf_ts_sz &#x3D; 0)
      : WriteBatch(reserved_bytes, max_bytes, protection_bytes_per_key,
                   default_cf_ts_sz) &#123;&#125;
  &#x2F;&#x2F; Retrieve some information from a write entry in the write batch, given
  &#x2F;&#x2F; the start offset of the write entry.
  Status GetEntryFromDataOffset(size_t data_offset, WriteType* type, Slice* Key,
                                Slice* value, Slice* blob, Slice* xid) const;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此，重现表述一下第 2 点。WriteBatchWithIndex 可以通过 GetWriteBatch() 获取到事务的 ReadableWriteBatch，进而凭借它来通过 offset 读取到 WriteBatch 中的某一条写操作。</p>
<p>总结一下，在事务没有 Commit 之前，数据还不在 Memtable 中，而是存在 WriteBatch 里，如果有需要，这时候可以通过 WriteBatchWithIndex 来拿到自己刚刚写入的但还没有提交的数据。</p>
<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p>RocksDB 提供了乐观事务和悲观事务，前者通过 MVCC 进行并发控制，后者采用锁机制，本节就大体介绍一下相关的内容。</p>
<h3 id="乐观事务"><a href="#乐观事务" class="headerlink" title="乐观事务"></a>乐观事务</h3><h4 id="sequence-number"><a href="#sequence-number" class="headerlink" title="sequence number"></a>sequence number</h4><p>RocksDB 中的每一条记录都有一个 sequence number, 这个 sequence number 存储在记录的 key 中，整合后的类名为 InternalKey，对应结构名为 ParsedInternalKey。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class InternalKey &#123;
 private:
  std::string rep_;
 public:
  InternalKey() &#123;&#125;  &#x2F;&#x2F; Leave rep_ as empty to indicate it is invalid
  InternalKey(const Slice&amp; _user_key, SequenceNumber s, ValueType t) &#123;
    AppendInternalKey(&amp;rep_, ParsedInternalKey(_user_key, s, t));
  &#125;
  InternalKey(const Slice&amp; _user_key, SequenceNumber s, ValueType t, Slice ts) &#123;
    AppendInternalKeyWithDifferentTimestamp(
        &amp;rep_, ParsedInternalKey(_user_key, s, t), ts);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，InternalKey 有两个构造函数，一个含有 ts（time stamp），一个没有。这里需要特别关注的是，ts 是从 v6.6.4 版本才开始有的，在 v5.18.4 以及之前的代码中，根本没有 ts 这个东西。</p>
<p><img src="https://s1.ax1x.com/2022/10/19/xsvnaQ.png" alt="xsvnaQ.png"></p>
<p>在这一小节，我们先不管 ts 是个啥，就按照没有 ts 的 InternalKey 来分析。</p>
<p>那么，rep_ 就是 string 形式的 ParsedInternalKey。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct ParsedInternalKey &#123;
  Slice user_key;
  SequenceNumber sequence;
  ValueType type;

  ParsedInternalKey()
      : sequence(kMaxSequenceNumber),
        type(kTypeDeletion)  &#x2F;&#x2F; Make code analyzer happy
  &#123;&#125;                         &#x2F;&#x2F; Intentionally left uninitialized (for speed)
  &#x2F;&#x2F; u contains timestamp if user timestamp feature is enabled.
  ParsedInternalKey(const Slice&amp; u, const SequenceNumber&amp; seq, ValueType t)
      : user_key(u), sequence(seq), type(t) &#123;&#125;
  std::string DebugString(bool log_err_key, bool hex) const;

  void clear() &#123;
    user_key.clear();
    sequence &#x3D; 0;
    type &#x3D; kTypeDeletion;
  &#125;

  void SetTimestamp(const Slice&amp; ts) &#123;
    assert(ts.size() &lt;&#x3D; user_key.size());
    const char* addr &#x3D; user_key.data() + user_key.size() - ts.size();
    memcpy(const_cast&lt;char*&gt;(addr), ts.data(), ts.size());
  &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出，InternalKey 的结构如下：</p>
<img src="https://s1.ax1x.com/2022/10/18/xrKhB4.png" alt="InternalKey结构" style="zoom: 67%;" />

<ul>
<li>user_key：key。</li>
<li>seq_num：全局递增 sequence number，用于给同一个 key 的不同操作区分先后。</li>
<li>value_type：这个和 &lt;key,value&gt; 中的 value 不一样，它实际指的是对这个 key 的操作类型，而不是值类型。比如 Delete、Merge、Rollback 等。</li>
</ul>
<p>接着，internl_key 会被封装为 memtable_key，与 memtable_value（这个结构我还没找到在哪）一起组成 &lt;key, value&gt; 写进 memtable 中。整个 &lt;key, value&gt; 结构如下：</p>
<p><img src="https://s1.ax1x.com/2022/10/18/xrMd8x.png" alt="memtable中的&lt;key,value&gt;"></p>
<p>对于同样的 user_key 记录，在 RocksDB 中可能存在多条，但他们的 sequence number 不同。</p>
<p>以我的理解，seq 的主要作用如下：</p>
<ul>
<li>区分对同一个 key 的所有操作的先后顺序；</li>
<li>用于快照；</li>
<li>无需加锁了；</li>
</ul>
<h4 id="time-stamp-since-v6-6-4"><a href="#time-stamp-since-v6-6-4" class="headerlink" title="time stamp (since v6.6.4)"></a>time stamp (since v6.6.4)</h4><p>自从 v6.6.4 开始，InternalKey 就加入了 ts 来进行多版本并发控制了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">InternalKey(const Slice&amp; _user_key, SequenceNumber s, ValueType t, Slice ts) &#123;
    AppendInternalKeyWithDifferentTimestamp(
        &amp;rep_, ParsedInternalKey(_user_key, s, t), ts);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是 ParsedInternalKey 的字段并没有变，只是在转化为 string 时，多整合了一个 ts，且是整合进 user_key 中。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void AppendInternalKeyWithDifferentTimestamp(std::string* result,
                                             const ParsedInternalKey&amp; key,
                                             const Slice&amp; ts) &#123;
  assert(key.user_key.size() &gt;&#x3D; ts.size());
  result-&gt;append(key.user_key.data(), key.user_key.size() - ts.size());
  result-&gt;append(ts.data(), ts.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意到，虽然加上了 ts，但 ts 使用的是原来 user_key 的末尾空间，也就是 internal_key 的大小并没有变，只是在 user_key 的末尾部分整合上了 ts。同时，在 ParsedInternalKey 中也加入了新的函数，名为 SetTimestamp() ，其功能就是把 ts 整合进 user_key 的末尾成为新的 user_key。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct ParsedInternalKey &#123;
  &#x2F;&#x2F; ...
  void SetTimestamp(const Slice&amp; ts) &#123;
    assert(ts.size() &lt;&#x3D; user_key.size());
    const char* addr &#x3D; user_key.data() + user_key.size() - ts.size();
    memcpy(const_cast&lt;char*&gt;(addr), ts.data(), ts.size());
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样一来，InternalKey 的结构就变成了下面这样：</p>
<img src="https://s1.ax1x.com/2022/10/20/xy7qbj.png" alt="xy7qbj.png" style="zoom: 50%;" />

<p>至于为什么要引入 ts，我现在也没有搞清除。但可以确定的是，它是用来解决并发冲突的，ts 可以充当 version，用来表明每一个记录的产生时间，从而区分出并发事务的先后。可以猜想，seq 做不到的一些并发控制，致使了 ts 的出现。但至于怎么用，这要到后面具体研究读写源码时才能清除，现在我也不知道。</p>
<p>同样的，既然 InternalKey _key 被加上了 ts，那么 memtale_key 中的 internal_key 也要加上对应的 ts。</p>
<p><img src="https://s1.ax1x.com/2022/10/20/xyTUtP.png" alt="新的&lt;key, value&gt;"></p>
<h4 id="snapshot"><a href="#snapshot" class="headerlink" title="snapshot"></a>snapshot</h4><p>snapshot 是 RocksDB 的快照信息，它实际就是对应一个 sequence number 。简单来讲，假设 snapshot 的 sequence number 为 sa，那么对于此 snapshot 来说，只能看到 sequence number &lt;= sa 的记录，其余的均看不见。</p>
<p>snapshot 没有复杂的类继承关系，主要就一条 Snapshot —&gt; SnapshotImpl。</p>
<p><img src="https://s1.ax1x.com/2022/10/18/xrQARx.png" alt="snapshot类关系"></p>
<p>其实现类如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Each SnapshotImpl corresponds to a particular sequence number.
class SnapshotImpl : public Snapshot &#123;
 public:
  SequenceNumber number_;  &#x2F;&#x2F; const after creation
  &#x2F;&#x2F; It indicates the smallest uncommitted data at the time the snapshot was
  &#x2F;&#x2F; taken. This is currently used by WritePrepared transactions to limit the
  &#x2F;&#x2F; scope of queries to IsInSnapshot.
  SequenceNumber min_uncommitted_ &#x3D; kMinUnCommittedSeq;

  SequenceNumber GetSequenceNumber() const override &#123; return number_; &#125;

  int64_t GetUnixTime() const override &#123; return unix_time_; &#125;

  uint64_t GetTimestamp() const override &#123; return timestamp_; &#125;

 private:
  friend class SnapshotList;

  &#x2F;&#x2F; SnapshotImpl is kept in a doubly-linked circular list
  SnapshotImpl* prev_;
  SnapshotImpl* next_;

  SnapshotList* list_;                 &#x2F;&#x2F; just for sanity checks

  int64_t unix_time_;

  uint64_t timestamp_;

  &#x2F;&#x2F; Will this snapshot be used by a Transaction to do write-conflict checking?
  bool is_write_conflict_boundary_;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>主要得到的信息如下：</p>
<ul>
<li>snapshot 核心成员为 sequence number，一旦创建就保持不变。</li>
<li>每个 snapshot 创建时都会分配个实际时间和时间戳，分别为 unix_time_ 和 timestmap_。</li>
<li>所有的 snapshot 通过全局双向链表来管理，snapshot 内部维护前后指针。</li>
</ul>
<p>我们知道，删除记录并不是直接删掉，而是追加一条 Delete 日志，原记录依旧保持。但是，老旧的无用记录不可能一直保存着，所以会在 Merge（又叫 Compact）时清除掉。清除的大致逻辑为，从全局双向链表中取出 sequence number 最小的 snapshot。 如果已删除的老记录 sequence number &lt;= 该snapshot， 那么这些老记录在 Merge 时可以清理掉。</p>
<h3 id="悲观事务"><a href="#悲观事务" class="headerlink" title="悲观事务"></a>悲观事务</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>悲观事务通过锁机制来进行并发控制，与其有关的有三大结构体：LockInfo、LockMapStripe、LockMap，三者均位于 <code>utilities/transactions/lock/point/point_lock_manager.cc</code> 中。</p>
<p>LockInfo：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct LockInfo &#123;
  bool exclusive;
  autovector&lt;TransactionID&gt; txn_ids;

  &#x2F;&#x2F; Transaction locks are not valid after this time in us
  uint64_t expiration_time;
  
  &#x2F;&#x2F; ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>LockInfo 代表一个锁，分为独占锁和共享锁，由 txn_ids 表示其被哪些事务持有。如果 exclusive 为 true，说明该锁为独占锁，那么仅由 txn_ids[0] 来持有该锁；如果 exclusive 为 false，说明该锁为共享锁，那么由 txn_ids 中的全部事务共同持有。expiration_time 为该锁的超时时间，超过该时间后锁失效。</p>
<p>LockMapStripe：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct LockMapStripe &#123;
  &#x2F;&#x2F; ...
  UnorderedMap&lt;std::string, LockInfo&gt; keys;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>LockMapStripe 维护一个 map，用来指明 key 与 lock 的对应关系，即哪个 key 被哪个 lock 锁住。</p>
<p>LockMap：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct LockMap &#123;
  &#x2F;&#x2F; ...
  &#x2F;&#x2F; Number of sepearate LockMapStripes to create, each with their own Mutex
  const size_t num_stripes_;

  &#x2F;&#x2F; Count of keys that are currently locked in this column family.
  &#x2F;&#x2F; (Only maintained if PointLockManager::max_num_locks_ is positive.)
  std::atomic&lt;int64_t&gt; lock_cnt&#123;0&#125;;

  std::vector&lt;LockMapStripe*&gt; lock_map_stripes_;

  size_t GetStripe(const std::string&amp; key) const;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个结构看上去就很奇怪，为什么还要费心思维护一个 LockMapStripe* 的 vector，难道一个 LockMapStripe 不够吗？</p>
<p>我是这样猜想的。LockMapStripe 内部就是 hash 映射，那么一旦 key 多起来了，那么就有可能发生 hash 冲突，导致两个不同的 key 映射到了一个 LockInfo 上，很显然是错的。为了减少冲突，RocksDB 采用了多个 LockMapStripe，先把每一个 key 按照自定义的 hash 分到某一个 LockMapStripe 中，然后才在其中 hash 映射到 LockInfo 里，两次不同的 hash，可以大大减少冲突率。</p>
<p>我为什么会这么猜想，来看看 TryLock 的定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status PointLockManager::TryLock(PessimisticTransaction* txn,
                                 ColumnFamilyId column_family_id,
                                 const std::string&amp; key, Env* env,
                                 bool exclusive) &#123;
  &#x2F;&#x2F; Lookup lock map for this column family id
  std::shared_ptr&lt;LockMap&gt; lock_map_ptr &#x3D; GetLockMap(column_family_id);
  LockMap* lock_map &#x3D; lock_map_ptr.get();
  if (lock_map &#x3D;&#x3D; nullptr) &#123;
    char msg[255];
    snprintf(msg, sizeof(msg), &quot;Column family id not found: %&quot; PRIu32,
             column_family_id);

    return Status::InvalidArgument(msg);
  &#125;

  &#x2F;&#x2F; Need to lock the mutex for the stripe that this key hashes to
  size_t stripe_num &#x3D; lock_map-&gt;GetStripe(key);
  assert(lock_map-&gt;lock_map_stripes_.size() &gt; stripe_num);
  LockMapStripe* stripe &#x3D; lock_map-&gt;lock_map_stripes_.at(stripe_num);

  LockInfo lock_info(txn-&gt;GetID(), txn-&gt;GetExpirationTime(), exclusive);
  int64_t timeout &#x3D; txn-&gt;GetLockTimeout();

  return AcquireWithTimeout(txn, lock_map, stripe, column_family_id, key, env,
                            timeout, std::move(lock_info));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>主要是三句：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_t stripe_num &#x3D; lock_map-&gt;GetStripe(key);
assert(lock_map-&gt;lock_map_stripes_.size() &gt; stripe_num);
LockMapStripe* stripe &#x3D; lock_map-&gt;lock_map_stripes_.at(stripe_num);
LockInfo lock_info(txn-&gt;GetID(), txn-&gt;GetExpirationTime(), exclusive);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后我们看下 GetStripe() 函数的定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_t LockMap::GetStripe(const std::string&amp; key) const &#123;
  assert(num_stripes_ &gt; 0);
  return FastRange64(GetSliceNPHash64(key), num_stripes_);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>该函数就是把 key 做了一遍 hash 映射，然后再转换为小于 num_stripes_ 的一个数，也就是致命 key 到底位于哪一个 LockMapStripe 中（实际上是指针，但为了直观就不写 * 了）。</p>
<p>再来看那三句话，首先通过 GetStripe() 找到 key 所处的 LockMapStripe 在 lock_map_stripes_ 中的下标，然后通过 lock_map_stripes_.at() 取出这个 LockMapStripe。这样一看，猜想应该是合理的。</p>
<p>明白了三大结构体之后，继续分析 TryLock() 函数，在获取到 LockMapStripe 之后，执行如下代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LockInfo lock_info(txn-&gt;GetID(), txn-&gt;GetExpirationTime(), exclusive);
int64_t timeout &#x3D; txn-&gt;GetLockTimeout();

return AcquireWithTimeout(txn, lock_map, stripe, column_family_id, key, env,
                          timeout, std::move(lock_info));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>它会为当前的事务创建一个 LockInfo，接着进入 AcquireWithTimeout 之中。AcquireWithTimeout 主要是进行 timeout 检查，检查通过之后调用另外的函数进行加锁申请，timeout 检查我们就先跳过。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Helper function for TryLock().
Status PointLockManager::AcquireWithTimeout(
    PessimisticTransaction* txn, LockMap* lock_map, LockMapStripe* stripe,
    ColumnFamilyId column_family_id, const std::string&amp; key, Env* env,
    int64_t timeout, LockInfo&amp;&amp; lock_info) &#123;
  
  &#x2F;&#x2F; ... timeout 检查
  &#x2F;&#x2F; 申请加锁
  result &#x3D; AcquireLocked(lock_map, stripe, key, env, std::move(lock_info),
                         &amp;expire_time_hint, &amp;wait_ids);
  &#x2F;&#x2F; ... 根据 result 继续操作
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>AcquireWithTimeout 通过 timeout 检查之后，调用 AcquireLocked 申请加锁。注意一下函数传入的最后一个参数 wait_ids，或者说变量 wait_ids。它用来指明当前事务正在等待哪些事务，可以通过它来表示事务之间的等待顺序，从而检测环路，避免死锁，这个后面会说。</p>
<p>重点来了，进入 AcquireLocked，看看锁是怎么加的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Try to lock this key after we have acquired the mutex.
&#x2F;&#x2F; Sets *expire_time to the expiration time in microseconds
&#x2F;&#x2F;  or 0 if no expiration.
&#x2F;&#x2F; REQUIRED:  Stripe mutex must be held.
Status PointLockManager::AcquireLocked(LockMap* lock_map, LockMapStripe* stripe,
                                       const std::string&amp; key, Env* env,
                                       LockInfo&amp;&amp; txn_lock_info,
                                       uint64_t* expire_time,
                                       autovector&lt;TransactionID&gt;* txn_ids) &#123;
  assert(txn_lock_info.txn_ids.size() &#x3D;&#x3D; 1);

  Status result;
  &#x2F;&#x2F; Check if this key is already locked
  auto stripe_iter &#x3D; stripe-&gt;keys.find(key);
  if (stripe_iter !&#x3D; stripe-&gt;keys.end()) &#123;
    &#x2F;&#x2F; Lock already held
    LockInfo&amp; lock_info &#x3D; stripe_iter-&gt;second;
    assert(lock_info.txn_ids.size() &#x3D;&#x3D; 1 || !lock_info.exclusive);

    if (lock_info.exclusive || txn_lock_info.exclusive) &#123;
      if (lock_info.txn_ids.size() &#x3D;&#x3D; 1 &amp;&amp;
          lock_info.txn_ids[0] &#x3D;&#x3D; txn_lock_info.txn_ids[0]) &#123;
        &#x2F;&#x2F; The list contains one txn and we&#39;re it, so just take it.
        lock_info.exclusive &#x3D; txn_lock_info.exclusive;
        lock_info.expiration_time &#x3D; txn_lock_info.expiration_time;
      &#125; else &#123;
        &#x2F;&#x2F; Check if it&#39;s expired. Skips over txn_lock_info.txn_ids[0] in case
        &#x2F;&#x2F; it&#39;s there for a shared lock with multiple holders which was not
        &#x2F;&#x2F; caught in the first case.
        if (IsLockExpired(txn_lock_info.txn_ids[0], lock_info, env,
                          expire_time)) &#123;
          &#x2F;&#x2F; lock is expired, can steal it
          lock_info.txn_ids &#x3D; txn_lock_info.txn_ids;
          lock_info.exclusive &#x3D; txn_lock_info.exclusive;
          lock_info.expiration_time &#x3D; txn_lock_info.expiration_time;
          &#x2F;&#x2F; lock_cnt does not change
        &#125; else &#123;
          result &#x3D; Status::TimedOut(Status::SubCode::kLockTimeout);
          *txn_ids &#x3D; lock_info.txn_ids;
        &#125;
      &#125;
    &#125; else &#123;
      &#x2F;&#x2F; We are requesting shared access to a shared lock, so just grant it.
      lock_info.txn_ids.push_back(txn_lock_info.txn_ids[0]);
      &#x2F;&#x2F; Using std::max means that expiration time never goes down even when
      &#x2F;&#x2F; a transaction is removed from the list. The correct solution would be
      &#x2F;&#x2F; to track expiry for every transaction, but this would also work for
      &#x2F;&#x2F; now.
      lock_info.expiration_time &#x3D;
          std::max(lock_info.expiration_time, txn_lock_info.expiration_time);
    &#125;
  &#125; else &#123;  &#x2F;&#x2F; Lock not held.
    &#x2F;&#x2F; Check lock limit
    if (max_num_locks_ &gt; 0 &amp;&amp;
        lock_map-&gt;lock_cnt.load(std::memory_order_acquire) &gt;&#x3D; max_num_locks_) &#123;
      result &#x3D; Status::Busy(Status::SubCode::kLockLimit);
    &#125; else &#123;
      &#x2F;&#x2F; acquire lock
      stripe-&gt;keys.emplace(key, std::move(txn_lock_info));

      &#x2F;&#x2F; Maintain lock count if there is a limit on the number of locks
      if (max_num_locks_) &#123;
        lock_map-&gt;lock_cnt++;
      &#125;
    &#125;
  &#125;

  return result;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>通过 LockMapStripe 来判断这个 key 是否已经被加锁了，如果是，进入2，如果否，进入 6。</li>
<li>key 已经被加锁，那么判断 key 的锁是否为独占锁，或者当前事务的锁是否为独占锁，两者任意一个通过，进入3，否则进入 5。</li>
<li>判断持有该 key 的锁的事务是否为当前事务，如果是，就按照事务的锁更新一些字段然后返回即可，如果不是，进入 4。</li>
<li>判断该 key 的锁是否超时，如果是，那么该锁会被当前事务的锁替代，该 key 成功由当前事务锁住，然后返回；如果不是，给个 kLockTimeout 错误状态，然后把 txn_ids（wait_ids）赋值为持有该 key 锁的所有事务id，表示当前事务要等他们释放锁，返回。</li>
<li>进入这一步说明 key 的锁和当前事务的锁其中至少有一个是共享锁。那么就直接把当前事务加入进 key 锁的事务 vector 中，一起共享这个锁，然后重算锁的超时时间，取两者之间的最大值，返回。</li>
<li>进入这一步说明 key 并没有被锁住。查看 LockMap 中的锁数量是否超过了限制，如果是，给个 kLockLimit 错误状态然后返回即可；如果否，就在 kLockTimeout 加一条映射，表示该 key 被当前事务锁住了，之后吧 LockMap 中的锁数量加一，返回。</li>
</ol>
<p>至此，加锁申请完毕，对锁的大致流程也有了一定的了解。</p>
<p>实际上，上述流程是以 CF 为单位的，一个 CF 拥有一个 LockMap。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class PointLockManager : public LockManager &#123;
  &#x2F;&#x2F; ...
 private:
  &#x2F;&#x2F; ...
  &#x2F;&#x2F; Map of ColumnFamilyId to locked key info
  using LockMaps &#x3D; UnorderedMap&lt;uint32_t, std::shared_ptr&lt;LockMap&gt;&gt;;
  LockMaps lock_maps_;
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来关注 wait_ids。当 AcquireWithTimeout 调用完 AcquireLocked 之后，在后续执行了如下一段代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; We are dependent on a transaction to finish, so perform deadlock
&#x2F;&#x2F; detection.
if (wait_ids.size() !&#x3D; 0) &#123;
    if (txn-&gt;IsDeadlockDetect()) &#123;
        if (IncrementWaiters(txn, wait_ids, key, column_family_id,
                             lock_info.exclusive, env)) &#123;
            result &#x3D; Status::Busy(Status::SubCode::kDeadlock);
            stripe-&gt;stripe_mutex-&gt;UnLock();
            return result;
        &#125;
    &#125;
    txn-&gt;SetWaitingTxn(wait_ids, column_family_id, &amp;key);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，函数通过 wait_ids 维护的事务等待队列来进行死锁检测。死锁检测的核心函数即为 IncrementWaiters()，其定义我们暂且先不看，后续会专门总结一篇博客分析 RocksDB 检测死锁的实现。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">SrcMiLe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/rocksdb-yuan-ma-xue-xi-yi-shi-wu/">http://example.com/rocksdb-yuan-ma-xue-xi-yi-shi-wu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">SrcMiLe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%AD%98%E5%82%A8/">
                                    <span class="chip bg-color">存储</span>
                                </a>
                            
                                <a href="/tags/rocksdb/">
                                    <span class="chip bg-color">rocksdb</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/rocksdb-yuan-ma-xi-lie-wen-zhang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="RocksDB源码系列文章">
                        
                        <span class="card-title">RocksDB源码系列文章</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-10-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%98%E5%82%A8/" class="post-category">
                                    存储
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%98%E5%82%A8/">
                        <span class="chip bg-color">存储</span>
                    </a>
                    
                    <a href="/tags/rocksdb/">
                        <span class="chip bg-color">rocksdb</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/sstable-jie-shao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="SSTable 介绍">
                        
                        <span class="card-title">SSTable 介绍</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%98%E5%82%A8/" class="post-category">
                                    存储
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%98%E5%82%A8/">
                        <span class="chip bg-color">存储</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                            <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <span id="year">2022</span>
            <a href="/about" target="_blank">SrcMiLe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2022";
                    var startMonth = "1";
                    var startDate = "12";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/sakura-ysy" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2575633193@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2575633193" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2575633193" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        

                                                                                                
                                                                                                    
                                                                                                        <script
                                                                                                            type="text/javascript"
                                                                                                            size="150"
                                                                                                            alpha='0.6'
                                                                                                            zIndex="-1"
                                                                                                            src="/libs/background/ribbon-refresh.min.js"
                                                                                                            async="async"></script>
                                                                                                        

                                                                                                            

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        

                </body>

</html>

<!-- 樱花 -->
<script type="text/javascript" src="/js/sakura.js"></script>