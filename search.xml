<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LevelDB单元测试</title>
      <link href="/leveldb-dan-yuan-ce-shi/"/>
      <url>/leveldb-dan-yuan-ce-shi/</url>
      
        <content type="html"><![CDATA[<p>在学习 leveldb 源码的过程中，肯定少不了对特定函数或结构的测试。LevelDB几乎给每个关键的数据结构都写好了测试代码，我们可以直接使用，或者根据他的框架自己编写新的测试体，很方便。</p><p>但是，我不会用。。。</p><p>我看的源码是截止写这篇博客时的最新版，commit：aa5479bbf47e9df86e0afbb89e6246085f22cdd4。当我深究 filter_block 时，需要用到它的单元测试，测试代码位于 filter_block_test.cc 中，测试函数体如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">TEST_F</span><span class="token punctuation">(</span>FilterBlockTest<span class="token punctuation">,</span> SingleChunk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  FilterBlockBuilder <span class="token function">builder</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>policy_<span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">StartBlock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">StartBlock</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">StartBlock</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Slice block <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FilterBlockReader <span class="token function">reader</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>policy_<span class="token punctuation">,</span> block<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span><span class="token operator">!</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"missing"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span><span class="token operator">!</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"other"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数体很容易理解，但问题来了，我不知道怎么运行它。TEST_F 是 google 下的一个单元测试框架<code>gtest</code>，我从来没用过甚至也没听说过，对它的使用很懵逼，连这个函数的声明方式都看不懂。并且，这个 filter_block_test.cc 文件没有 main 函数，说明我连编译都进行不了。另外，即使可以编译也不能只编译这一个文件，因为它链接了整个 leveldb 中的很多库。也就是说：</p><ol><li>gtest 是一点都没用过，TEST_F 是啥？</li><li>没 main 函数我怎么进去？</li><li>咋编译？</li></ol><p>带着这三个问题我去搜了很多资料，直到碰见了这一篇：<a href="https://zhuanlan.zhihu.com/p/71722510">测试代码编译</a>。让我有方向的这篇文章的最后一部分：</p><p><img src="https://s1.ax1x.com/2023/02/04/pSyRSC8.png"></p><p>这两段话解答了我的第3个问题，如何编译。也就是说，要么先编译整个 leveldb 生成 libleveldb.a 然后再编译单元测试，要么直接将测试随着整个 leveldb 一同编译了。如果经常更改单元测试，肯定是前者要好很多，但这里我只是用一下，所以干脆直接选后者了。</p><p>问题来了，我查找 CMakeLists.txt 中的相关代码，发现了如下内容：</p><p><img src="https://s1.ax1x.com/2023/02/04/pSyRn8U.png" alt="CMakeLists.txt"></p><p>这段注释发布于13个月前，核心为：</p><blockquote><p>Remove main() from most tests.</p><p>This gives some flexibility to embedders.</p><p>Currently, embedders have to build a binary for each test file.</p></blockquote><p>这样就解答第2个问题了，main 函数在哪。从注释中可以看到，在该版本中，main() 被剥离了，因为想让测试变的更容易扩展，但这样就需要使用者自己去构建。被剥离了，说明之前存在过，于是我 pull 了之前的版本（v1.23），重新查看  filter_block_test.cc ，部分内容如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">TEST_F</span><span class="token punctuation">(</span>FilterBlockTest<span class="token punctuation">,</span> SingleChunk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  FilterBlockBuilder <span class="token function">builder</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>policy_<span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">StartBlock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">StartBlock</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">StartBlock</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  builder<span class="token punctuation">.</span><span class="token function">AddKey</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Slice block <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FilterBlockReader <span class="token function">reader</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>policy_<span class="token punctuation">,</span> block<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span><span class="token operator">!</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"missing"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span><span class="token operator">!</span>reader<span class="token punctuation">.</span><span class="token function">KeyMayMatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"other"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  testing<span class="token double-colon punctuation">::</span><span class="token function">InitGoogleTest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">RUN_ALL_TESTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点来了，这个版本的 xxx_test.cc 是有 main 入口的，说明可以直接编译生成可执行文件来使用。具体的流程为 RUN_ALL_TESTS() 会执行上面的所有 TEST_F，代码都在项目中写有，这里就不展示了。</p><p>CMakeLists.txt，不同于最新的版本，该版本把每一个 xxx_test.cc 的编译都考虑进去了，如下图所示：</p><img src="https://s1.ax1x.com/2023/02/04/pSyRbGT.png" alt="CMakeLists.txt" style="zoom:50%;" /><p>此时，只需要按照正常流程编译 leveldb，这些测试文件即可一同被编译：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p build <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> buildcmake -DCMAKE_BUILD_TYPE<span class="token operator">=</span>Release <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> cmake --build <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成的可执行文件位于 bulid/ 目录下：</p><img src="https://s1.ax1x.com/2023/02/04/pSyWSd1.png" alt="build目录" style="zoom:50%;" /><p>只需运行即可：</p><img src="https://s1.ax1x.com/2023/02/04/pSyWPJK.png" alt="运行单元测试" style="zoom:67%;" /><p>至此，leveldb 如何进行单元测试的问题就解决了。</p><p>开发者将 main 函数从 xxx_test.cc 中移出，固然有它的道理，但由于我对 gtest 并不了解，所以还是习惯于使用旧版的测试。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksMash</title>
      <link href="/rocksmash/"/>
      <url>/rocksmash/</url>
      
        <content type="html"><![CDATA[<h1 id="RocksMash-本地与云相结合的高效益存储系统"><a href="#RocksMash-本地与云相结合的高效益存储系统" class="headerlink" title="RocksMash | 本地与云相结合的高效益存储系统"></a>RocksMash | 本地与云相结合的高效益存储系统</h1><blockquote><p>如何利用本地存储与云存储相得益彰的特性，优化 LSM-Tree 云存储的成本与性能？</p></blockquote><p>现如今采用云存储是大势所趋，应用程序爆炸式的增长致使存储的数据量不断扩大，这就要求<strong>成本效益</strong>成为底层数据库的必要设计目标。现行基于 LSM-Tree 的键值存储系统通常使用单盘的模式，要么采用快速但空间小且昂贵的本地存储（如 SSD），要么采用成本较低但速度较慢的云存储盘（如 AWS gp2），难以做到兼顾成本与性能。下图很明显地描述了本地存储和云存储之间的成本与性能差异。其中，左图为不同存储设备的成本-性能分布，SSD 为实例自带的 SSD ，gp2 和 st1 均是 AWS EBS 云盘，前者为 SSD 后者为 HDD。右图为内存耗尽时 RocksDB 在本地 SSD 和 gp2 上的读写性能。</p><img src="https://s1.ax1x.com/2023/01/02/pSP8Fh9.png" style="zoom: 50%;" /><p>可以看到，两种存储设备具有成本-性能互补的关系，如果能利用这种特性，集成本地存储与云存储，就能打造一个兼具<strong>低成本</strong>与<strong>高性能</strong>的存储系统。然而这种双盘分离的设计存在着<strong>数据重组</strong>、<strong>元数据开销</strong>与<strong>可靠性</strong>的问题，目前尚未有其他工作能够在本地存储与云存储之间很好地解决这些问题。</p><p>因此，我们设计了 RocksMash。</p><h2 id="RocksMash-总览"><a href="#RocksMash-总览" class="headerlink" title="RocksMash 总览"></a>RocksMash 总览</h2><p>RocksMash 是基于 RocksDB 设计的一种结合本地存储与云存储的冷热分离存储系统，其重心在于成本的节省、冷区读性能的优化与快速恢复。不同于普通的冷热分离结构，RocksMash 将会在本地盘中对云盘上的元数据进行缓存，<strong>降低</strong>了对云存储的 <strong>I/O 请求</strong>数量，优化了读取性能。同时，RocksMash  重新设计了云盘上 SST 的元数据块结构，使<strong>元数据体积变小</strong>且过滤器的<strong>假阳性率降为 0</strong>，以此来优化空间利用率和读取性能。此外，RocksMash 使用扩展的 WAL 日志来实现快速的数据<strong>并行恢复</strong>，保证了可靠性。</p><p>与最先进的方案相比，RocksMash 的性能提高了 <strong>1.7</strong> 倍，且具有高可靠性、高成本效益和快速恢复的特性。</p><h2 id="RocksMash-架构"><a href="#RocksMash-架构" class="headerlink" title="RocksMash 架构"></a>RocksMash 架构</h2><p>RocksMash 使用小型、快速但通常昂贵的本地存储来存储频繁访问的 LSM-Tree 上层（top-k），而 LSM-Tree 的其余部分则由大型、缓慢但通常便宜的云存储来维护。这是因为上层的大小要远小于下层的大小，SST 的热度也高很多，将顶层放在本地存储中能很好利用其空间小但性能强的特性。上层 SST 存储在本地存储上以实现快速访问，而其余的 SST 存储在云上以实现低存储成。这样可以节省大部分本地存储空间用于缓存，来提高读性能。</p><p>为了加速读取存储在云存储上的数据，我们为 RocksMash 设计了 LAP Cache，由 MetaCache 和 DataCache 组成，均使用本地存储，前者负责对 SST 的元数据进行缓存，后者负责完成能够感知 Compaction 的动态数据块缓存。LAP Cache 减少了数据块对云的 I/O，并消除了对云存储中元数据访问。此外，我们为 RocksMash 设计了全新的 SST 元数据结构，称为 MashMeta。MashMeta 显著减少了 SST 元数据的大小，并将假阳性率降为 0。</p><p>此外，为了确保本地和云存储混合的数据恢复机制，RocksMash 以几乎可以忽略不计的开销扩展了 WAL（Extended WAL），并将它们存储在专用的、快速的、小型的云存储上，以将本地数据暴露给远程节点。在恢复过程中，提出的扩展 WAL 消除了耗时的上层 Compaction 操作，显著加速了恢复速度。</p><p>综上，RocksMash 由如下四部分构成：</p><ul><li><p><strong>冷热分离</strong>：上层 SST 由本地存储维护，下层 SST 由云存储维持，平衡性能与成本开销。</p></li><li><p><strong>LAP Cache</strong>：分为 MetaCache 与 DataCache，以有效地使用空闲的本地存储空间作为 SST 元数据和热数据块的高性能持久缓存。</p></li><li><p><strong>MashMeta</strong>：为 SST 设计的一种节省空间的高性能元数据结构，可以显著降低元数据开销，并消除不必要的 I/O 请求。</p></li><li><p><strong>并行恢复</strong>：使用并行的方式快速恢复 L0~Li 的 SST。</p></li></ul><p>下图展示了 RocksMash 的整体架构：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8ApR.png" style="zoom: 67%;" /><h2 id="RocksMash-组件设计"><a href="#RocksMash-组件设计" class="headerlink" title="RocksMash 组件设计"></a>RocksMash 组件设计</h2><p>接下来将介绍 RocksMash 三大组件的详细设计</p><h3 id="LAP-Cache"><a href="#LAP-Cache" class="headerlink" title="LAP Cache"></a>LAP Cache</h3><p>在介绍 LAP Cache 之前，先来看看 RocksDB 的传统 Cache。</p><p>RocksDB 的 Cache 通常包含多个 CacheFile，它们被组织在一个 LRU 列表中。新缓存的 k-v 对将被追加进最近使用过的 CacheFile 中，如果该 CacheFile 没满的话。一旦某个 CacheFile 写满了，它会立刻变成只读，此时一个新的 CacheFile 将会被创建并加入到 LRU 列表中。当整个 Cache 满时，最久未被访问的 CacheFile 将会被删除。</p><p>这种 Cache 设计是无法感知 Compaction 的，这会浪费大量的缓存空间。比如，在 Cache 中的 k1-v1 原本位于 LSM-Tree 中的 SST1 中，当 SST1 被 Compact 之后，k1-v1 已经过时了，可其仍然存在于 Cache 中，占用了很多空间。</p><p>为了解决这个问题，我们提出了 LAP Cache，其由 MetaCache 和 DataCache 两部分组成。</p><h4 id="MetaCache"><a href="#MetaCache" class="headerlink" title="MetaCache"></a>MetaCache</h4><p>MetaCache 将云存储中所有 SST 的所有元数据块缓存在本地存储中，以此来消除对云端元数据的访问。元数据的总大小对于通常上百 GiB 的本地存储而言很小，因此不会占用过多的空间。由于 SST 自创建后仅仅可读，MetaCache 将云端 SST 的所有元数据块组织在一个 Hash 表中，如下图所示。</p><img src="https://s1.ax1x.com/2023/01/02/pSP8E11.png" alt="" style="zoom:50%;" /><p>为了减少空间占用，RocksMash 重新设计了 SST 的元数据块结构，这将在 MashMeta 部分详细介绍。</p><p>使用 MetaCache，RocksMash 可以防止元数据块从本地存储中驱逐出去，这使得 RocksMash 在最坏的情况下只需要一个对本地存储的 I/O 即可访问到云端的 SST 元数据。</p><h4 id="DataCache"><a href="#DataCache" class="headerlink" title="DataCache"></a>DataCache</h4><p>不同于 RocksDB 的 Cache，DataCache 可以感知到 Compaction 操作。下图描述了其设计方案：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8V6x.png" alt="" style="zoom: 67%;" /><p>DataCache 将缓存的 k-v 对组织在 LRU 列表中，并把其中位于过时 SST 中的 k-v 对在 bitmap 中进行标记。如上图，当 SST2 被 Compact 时，DataCache 中的 sst2_key3 和 sst2_key1 均会在 bitmap 中被标记，而当新的 k-v 对需要缓存时（sst1_key2 和 sst1_key3），将会把被标记的 k-v 对覆盖掉，以此来提高缓存的空间利用率。</p><p>DataCache 被划分为多个 bucket，每个 bucket 维护来自不同 SST 的多个数据块，通过对数据块所在的 SST 的文件名进行 Hash 来决定其会被分配入哪个 bucket。每一个 bucket 均配备有一个 bitmap，其中的每一个 bit 均唯一对应 bucket 中某个数据块。如果 bit 被置位，即说明该数据块包含的是一个有效的 k-v 对。</p><p>使用 DataCache，过时的 SST 数据块通过 bitmap 来删除，这样并不会影响有效数据，提高了空间利用率。</p><h3 id="MashMeta"><a href="#MashMeta" class="headerlink" title="MashMeta"></a>MashMeta</h3><p>为了进一步优化 MetaCache，RocksMash 重构了云存储中的 SST 结构，基于 Succinct-Tree 设计了一种空间高效的索引方法。这种结构将大大减少元数据块的大小，为 SST 节省出更多的空间来存放数据块，从而提高 Cache 的命中率。同时， 该结构支持快速查询，将更快的把 key 从元数据快定位到数据块中。</p><p>对云存储中的每一个 SST，RocksMash 构建了一个<strong>compressed trie</strong>，并将其进行编码，然后用它替代了 SST 中的索引与布隆过滤器。下图展示了一个 10 节点的 trie 示例：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8ZX6.png" alt="" style="zoom: 67%;" /><p>该 SST 一共存放了 6 条 k-v，key 分别为 “hello”、“hunda”、“hundred”、“hunk”、“huntee”、“hunter”，这些 k-v 存放在三个数据块之中。trie 中的每一个节点都关联一个字符和编号，比如根节点就是 “h” 和 0，其中，节点的编号是其在深度优先遍历中的访问顺序，“$“ 代表空。每一条边也关联着一个字符，比如根节点的两条出边关联 “e” 和 “u”。每一条由根节点到叶子节点的路径均代表一个 key，每一个叶子节点代表一个 key 的结尾。</p><p>trie 以 DFUDS 进行编码。在深度优先遍历时，每当访问到一个节点，i 个左括号 “(“ 就会被加入序列，其中 i 指该节点的孩子数目。当节点访问完毕后，一个右括号 “)” 会被加入序列。以上图为例，节点 0 访问完毕后会加入字符串 “( ( )”，节点 2 访问完毕后会加入字符串 “( ( ( )”。当所有节点访问完毕后，会形成一个具有 10 对括号的序列，其中，最左侧的 “(“ 是为了平衡括号额外加进去的。在该序列中，从开始到每一个叶子节点的 “)” 或 “]”，即为所对应 key 的编码。</p><p>因为 SST 中的 key 是有序的，因此只要知道每一个数据块的起始 key 即可快速定位到 key 所在的数据块。为了做到快速定位，MashMeta 将每个数据块的起始 key 进行了特殊编码。对于每一个起始 key，MashMeta 将其编码中的结尾 “)” 替换成了 “]”。比如 “hello” 的编码结尾本来是 “)”，现在被替换为了 “]”，这就是为什么在上图中节点 2 对应的编码是 “]”。因此，在序列中搜索 key 时，经过的 “]” 数量就代表其位于第几个数据块。比如，在 key “huntee” 的检索过程中遇到了 3 个 “]”，那么其就在第 3 个数据块中。</p><p> 很显然，这种结构可以完全替代布隆过滤器，并做到 0 假阳性率。因为不存在的 key 是不会在 trie 中有着正确的访问路径的。</p><h3 id="并行恢复"><a href="#并行恢复" class="headerlink" title="并行恢复"></a>并行恢复</h3><p>实际上，云存储具有较低的年化故障率，因此快速恢复针对于本地存储。</p><p>对于常规的 RocksDB WAL。当 WAL 大小较大且覆盖了 L0 ~ Li 的 k-v 对时，其在 CPU 和 I/O 方面均很低效。首先，恢复时没有必要重新构建 Memtable，因为该操作仅仅能生产 L0，而其余层均不可以，这样浪费了 CPU 周期。其次，突然恢复的大量 k-v 必将产生很多 L0~Li 的 Compaction，导致大量的额外 I/O。此外，恢复时的 Compaction 并不是并行的，这进一步拉低了恢复性能。</p><p>RocksMash 设计了 L0~Li 的并行恢复方案，以解决上述大尺寸 WAL 带来的问题。</p><img src="https://s1.ax1x.com/2023/01/02/pSP8mnK.png" alt="" style="zoom:67%;" /><h4 id="Extended-WAL"><a href="#Extended-WAL" class="headerlink" title="Extended WAL"></a>Extended WAL</h4><p>RocksMash 扩展了 WAL 使其包含 L0<del>Li 中 SST 的所有数据。当 L0</del>Li 中的 SST 生成时，RocksMash 会将该操作记录进 MANIFEST 中，同时将其中的所有 key 记录在 WAL 中，以此来快速确定 SST 中所含的 key。为了节省 I/O，恢复时 RoctksMash 可以将 SST 中的所有 k-v 打包成 batch 进行批量写。Compaction 时要被删除的 SST 中的 key 并不会被 Extended WAL 记录，因为这些 SST 都不在 MANIFEST 所记录的最新状态中。通过这种方式，RocksMash 可以确保安全的回滚到最新的状态。</p><h4 id="逆时序搜索"><a href="#逆时序搜索" class="headerlink" title="逆时序搜索"></a>逆时序搜索</h4><p>每个需要被恢复的 SST 都会被 RocksMash 分配一个 worker，每个 worker 将会<strong>从新至旧</strong>搜索 WAL，以确保最先碰到的都是每个 k-v 的最新版本。对于非 L0 的 Li，RocksMash 允许 worker 恢复其中任意版本的 k-v，而非只能是最新的。实际上，Li（i != 0）层中过时版本的 k-v，并不会之后读结果的正确性。假设在 Lx（x != 0）中某一个 SST 中恢复了一条过时的 k-v，不妨称作 k-v_old。可肯定的是在 Lx 中 k-v_old 是该 key 唯一的一条记录，因为除 L0 之外 key 不重合。此外，在 L0~Lx-1 层中一定有比 k-v_old 更新的版本，不放称作 k-v_new，这是因为新版的 k-v 一定会在旧版的 k-v 上层。这样的话，在 LSM-Tree 中进行读取时，就会止步于 k-v_new，而读不到 k-v_old。这种特性与逆时序搜索相结合，将使 RocksMash 从逻辑上截断 WAL。</p><h4 id="并行构建-SST"><a href="#并行构建-SST" class="headerlink" title="并行构建 SST"></a>并行构建 SST</h4><p>当实例节点故障时，RockMash 将使用一个新的示例去恢复原节点 L0~Li 上的 SST。通过读取 MANIFEST 和 Extended WAL 来获得最新状态的 SST 列表。接着，通过记录的每个 SST 的 key 列表，RockMash 从 Extended WAL 中获得每个 SST 中的 k-v 对，随后并行地重建这些 SST。下图展示了该恢复流程：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8n0O.png" alt="" style="zoom: 67%;" /><ul><li><strong>Step 1</strong>：RocksMash 将 L0~Li 中所有 SST 的 key 列表以及所有的 WAL 拉取到新实例中。</li><li><strong>Step 2</strong>：为每一个 SST 分配一个 worker，由新至旧扫描 WAL 以此获取到该 SST 应有的 k-v 对。需要注意的是，由于 L0 各 SST 之间是可能重叠的，因此 L0 中较老的 SST 的扫描指针一定不能超过较新的 SST 的扫描指针，以此来保证 L0 中较新的 SST 中一定是较新的 k-v。在 L0 的所有 worker 完成之后，L1~Li 的所有 worker 即开始工作，从 WAL 中拉取 k-v。</li><li><strong>Step 3</strong>：当 worker 获取了该 SST 中的所有 k-v 对后，该 SST 将会被重建。</li><li><strong>Step 4</strong>：创建 Memtable。RocksMash 通过 L0 中最新的 SST 来判断 WAL 中的 k-v 是否已经持久化，以此来减少写入 Memtable 的大小。L0 中最新的 SST 中最新的 key 可以用作分界线，在该 key 之前的所有 key 都已经被持久化到 SST 中，而该 key 之后的所有 key 还留存在原示例的 Memtable 或 immutable Memtable 中。因此，RocksMash 仅仅将该 key 之后的 key 重放入 Memtable，来恢复内存中的数据。</li></ul><p>在以上步骤之后，RocksMash 将崩溃实例的内存和本地存储中的数据恢复到最新的一致状态。</p><h2 id="RocksMash-性能评估"><a href="#RocksMash-性能评估" class="headerlink" title="RocksMash 性能评估"></a>RocksMash 性能评估</h2><p>该部分分为两节：</p><ul><li>RocksMash 整体性能评估。</li><li>RocksMash 组件性能评估。</li></ul><p>采用 YCSB 的 6 个负载和 db_bench 进行压测，对比 RocksMash、RocksDB、Mutant 三者的性能差异。其中，db_bench 集成了六种模式：随机/顺序写、随机/顺序读，将其记作 “FR”、“FS”、“RR”、“SR”。而YCSB 的 6 个负载如下图所示：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8u7D.png" alt="pSP8u7D.png" style="zoom:67%;" /><h3 id="整体性能"><a href="#整体性能" class="headerlink" title="整体性能"></a>整体性能</h3><p>下图显示了在 YCSB 下三种存储系统的 I/O 性能对比。</p><img src="https://s1.ax1x.com/2023/01/02/pSP8MAe.png" style="zoom:67%;" /><p>可以看到，RocksMash 在所有六种工作负载下都实现了最高吞吐量。例如，在工作负载 C 下，RocksMash的吞吐量比 RocksDB 提高了2倍。这是因为 RocksDB 将所有数据都存储在云存储上，而负载 C 是 100% 读，说明 RocksMash 的读性能要远优于 RocksDB。而与 Mutant 相比，RocksMash在负载 F 下的吞吐量提高了 1.6 倍，因为 Mutant 采用的 Cache 性能要劣与 RocksMash 采用的 LAP Cache。</p><p>对于负载 E，RocksMash 比 RocksDB 和 Mutant 分别提高了 2.2 倍和 1.7 倍。原因如下。首先，与 RocksDB 相比，RocksMash 将热数据存储在快速的本地存储上，这减少了从云端频繁检索的请求，因此提高了整个系统的性能。其次，虽然 Mutant 在本地存储中缓存热数据，但它向缓存中是进行文件级迁移的，这种方式很重，并且它的缓存空间效率不佳。</p><p>接下来测试 RocksMash 在分布式系统中的性能。我们将 RockMash 集成在 TiDB 中，集群一共包含 5 个节点。测试结果显示，在 YCSB 的六种负载下，RocksMash 的性能均优于 RocksDB 和 Mutant。</p><img src="https://s1.ax1x.com/2023/01/02/pSP8QtH.png" alt="pSP8QtH.png" style="zoom:50%;" /><h3 id="LAP-Cache-性能"><a href="#LAP-Cache-性能" class="headerlink" title="LAP Cache 性能"></a>LAP Cache 性能</h3><p>因为读请求最能反应 Cache 性能，因此该部分测试选用 YCSB 负载 C。与 RocksDB 的对比结果如下：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8lhd.png" style="zoom: 50%;" /><p>可以看到，LAP Cache 比 RocksDB 的 Cache 拥有更高且更稳定的总体吞吐量。与 RocksDB 相比，RocksMash 的 LAP Cache 由于其高空间效率和高缓存命中率，为用户提供了更高的读吞吐量，将测试完成的时间缩短了一半。</p><h3 id="MeshMeta-性能"><a href="#MeshMeta-性能" class="headerlink" title="MeshMeta 性能"></a>MeshMeta 性能</h3><p>为了评估 MashMeta 的效果，我们使用只配备了 MashMeta 的 RocksMash 并与 RocksDB 进行比较。在这个测试中，我们将所有数据存储在本地存储中，以缩小元数据结构之间的差异，并加速实验。这里将首先评估 MashMeta 在内存空间上的增益，然后衡量它对读写性能的影响。</p><img src="https://s1.ax1x.com/2023/01/02/pSP8Gct.png" style="zoom:67%;" /><p>图（a）显示了加载 10M 随机写入后所有 SST 元数据的总大小。与传统的基于块的 SST 元数据相比，MashMeta最多减少 62% 的元数据大小，并将过滤器假阳性率降低到零。</p><p>图（b）显示，RocksMash 使用空闲的 32 MB 空间（如图（a）所示）来补偿表和块缓存。因此，在内存耗尽且没有存储空间用于表和块缓存的情况下，随机读性能（图上条形柱）比 RocksMash 和 RocksDB 提高了2倍。</p><p>图（c）显示，MashMeta 不会带来显著的开销。这是因为数据传输主导了 Compaction 开销，并且在 Compaction 期间为 SST 构建 MashMeta 只占用了一小部分时间。此外，底层 SST 中 key 之间的长共享前缀有助于减少计算开销。</p><p>图（d）显示，RocksMash 提高了所有范围大小的范围查询性能，当范围大小为 64 时，增益最大，达到 1.2 倍。随着范围大小的增长，数据块传输开销占主导地位，MashMeta 的优势逐渐降低。</p><h3 id="恢复性能"><a href="#恢复性能" class="headerlink" title="恢复性能"></a>恢复性能</h3><p>在本部分将首先评估将 WAL 放在云存储上是否会影响写入性能，然后分析 RocksMash 的并行恢复性能。分别使用本地存储和 AWS EBS-gp3 来存放 WAL。写入吞吐量如下图所示：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8JjP.png" alt="pSP8JjP.png" style="zoom: 50%;" /><p>可以看到，在云存储上存放 WAL 对写性能影响很小。</p><p>用 db_bench 测试了 RocksMash 并会恢复方案的速度，并于 RocksDB 的恢复方案进行对比，结果如下图：</p><img src="https://s1.ax1x.com/2023/01/02/pSP8tnf.png" style="zoom:67%;" /><p>图（a）显示，对于 FR 和 FS 工作负载，RocksMash 的并行恢复方案比基本恢复方案快 8.6 ~ 10.1 倍。</p><p>图（b）显示，当 FR 值尺寸较大时，RocksMash 的恢复增益下降到 2.5 倍。</p><p>图（c）显示，当 RocksMash 为恢复分配三个线程时，查找属于 SST 的 k-v 对的时间缩短了，而这也是整个恢复过程中最耗时的操作。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>RocksMash 是一个快速高效的基于 LSM-Tree 的存储系统，可以有效地在本地存储和云存储之间分割 LSM-Tree，从而实现成本效益。此外，为了减少元数据的空间占用并提高读取性能，RocksMash 使用了 MetaCache 以节省空间的方式存储元数据，并使用可感知 Compaction 的 DataCache 来缓存有效的数据块。此外，RocksMash 扩展了 WAL，用于快速并行数据恢复。</p><p>评估结果表明，与 RocksDB 相比，RocksMash 具有更好的性能、更高的可靠性和成本效益。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EFS测试笔记</title>
      <link href="/efs-ce-shi-bi-ji/"/>
      <url>/efs-ce-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>本篇针对 EFS 的三种吞吐量模式进行测试，并对结果进行一定的分析与思考。EC2 实例类型采用 m5d.2xlarge，EFS 均为 Standard，由于测试时间短，因此和 IA 无关。关于 EFS 三种模式，官网有大体的介绍：<a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#bursting">EFS 性能</a>。不过测了之后发现，官网给出的只适合于商业模式下巨量的数据存储，而在实验环境下（数据量少），性能是真的烂。</p><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><p>采用 db_bench 进行客户端压测，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">sudo</span> <span class="token punctuation">..</span>/db_bench -benchmarks<span class="token operator">=</span><span class="token string">"fillrandom,levelstats,stats"</span> <span class="token punctuation">\</span>-perf_level<span class="token operator">=</span><span class="token number">5</span> <span class="token punctuation">\</span>-compression_type<span class="token operator">=</span>none <span class="token punctuation">\</span>-histogram<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>-statistics <span class="token punctuation">\</span>-num<span class="token operator">=</span><span class="token number">10000000</span> <span class="token punctuation">\</span>-threads<span class="token operator">=</span>X <span class="token punctuation">\</span>-writes<span class="token operator">=</span><span class="token number">10000000</span>/X <span class="token punctuation">\</span>-max_background_jobs<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">\</span>-subcompactions<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>-max_bytes_for_level_base<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span><span class="token number">256</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token variable">))</span></span> <span class="token punctuation">\</span>-write_buffer_size<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token variable">))</span></span> <span class="token punctuation">\</span>-writable_file_max_buffer_size<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token variable">))</span></span> <span class="token punctuation">\</span>-target_file_size_base<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token variable">))</span></span> <span class="token punctuation">\</span>-key_size<span class="token operator">=</span><span class="token number">16</span> <span class="token punctuation">\</span>-value_size<span class="token operator">=</span><span class="token number">256</span> <span class="token punctuation">\</span>-bloom_bits<span class="token operator">=</span><span class="token number">10</span> <span class="token punctuation">\</span>-keys_per_prefix<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">\</span>-cache_index_and_filter_blocks<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">\</span>-seek_nexts<span class="token operator">=</span><span class="token number">100</span> <span class="token punctuation">\</span>-use_direct_io_for_flush_and_compaction<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>-use_direct_reads<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>--db<span class="token operator">=</span>/mnt/efs/ysy1/db <span class="token punctuation">\</span>--wal_dir<span class="token operator">=</span>/mnt/efs/ysy1/wal <span class="token punctuation">\</span><span class="token operator">></span> testX.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="突增模式"><a href="#突增模式" class="headerlink" title="突增模式"></a>突增模式</h2><p>该模式是 EFS 默认的模式，也是成本相对较低的模式，所以首先测了它，不过结果并不好。</p><h3 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h3><p>该模式下测试了 X = 1、2、4、8 的情况，部分数据如下：</p><img src="https://s1.ax1x.com/2022/12/07/zgQD74.png" alt="测试数据1" style="zoom:80%;" /><p>可以看到，不管用户线程数为多少，总的平均 IO 只有 50 MiB/s 左右，和之前 io2 测的 200~300 MiB/s 相比，性能非常差。</p><p>在 EFS 控制台中，可以监控到四次压测的实时吞吐量利用率，峰值已经达到 80%+，触发报警，说明已经完全利用了 EFS，达到了吞吐量瓶颈。</p><p><img src="https://s1.ax1x.com/2022/12/07/zgQ6hR.png" alt="吞吐量利用率"></p><p>为什么会这样呢？原因在于突发吞吐量模式的吞吐量限制问题。首先，吞吐量利用率指某一刻的吞吐量与允许吞吐量（PermittedThroughput）的比值，该比值不会超过 100%，因为突发吞吐量模式下，PermittedThroughput 就是最大的吞吐量。官方对该限制的描述如下：</p><p><img src="https://s1.ax1x.com/2022/12/07/zgl25j.png" alt="吞吐量限制描述"></p><p>其中，PermittedThroughput 就是允许的最大吞吐量，该值直接由文件系统大小决定。即使使用了突增积分，使吞吐量变大，那这个吞吐量仍然会被限制在这个范围内。</p><p>这里说一下突增积分，每当文件系统处于<strong>非活动状态或驱动吞吐量低于其基线计量速率</strong>时，它就会累积突发积分。但是这个基线基线计量速率极低，与文件系统大小有关，基量为 1MiB/s，每 GiB 提供的基线速率（基线吞吐量）为 50 KB/s，也就是说即使 1 TB 的文件系统也只有 50 MiB/s 的基线速率，对比 io2，少的可怜。因此，在存储大小很低的情况下，稍微来一点压力，就需要用突增积分了 。更何况，我的实验环境为新创建的 EFS，总大小很小，基线速率为最低的 1MiB/s ，因此整个压测过程基本都在用突增积分。</p><p>那突增积分是哪来的？除了随着非活动的时间增加而积累，新创建的 EFS 会直接赠送 2.3TB 的突增积分，上述实验用的就是这些积分。在 CloudWatch 中可以监控突增积分的变化，随着四次压测，突增积分降了四次，如下：（最后两次由于压测间隔小于采样间隔，所以没有水平线）</p><p><img src="https://s1.ax1x.com/2022/12/07/zgGDYQ.png" alt="突增积分变化"></p><p>因此，虽然它叫作 <em>突增</em> 积分，但文件系统较小时，由于基线速率太小了，所以基本都在用突增积分，变成一种常态。那问题来了，为什么用了突增积分，吞吐量还是这么少。因为该模式下的吞吐量会被 PermittedThroughput 限制住，只要它不提高，那么吞吐量就一直上不去，IOPS 也就上不去。</p><p>PermittedThroughput 的值由文件系统大小决定，其计算方法如下：</p><p><img src="https://s1.ax1x.com/2022/12/07/zgJWjI.png" alt="PermittedThroughput与基线速率的计算方法"></p><p>其中，红框内的前者就是 PermittedThroughput ，后者就是前文提到的基线速率。最低的 PermittedThroughput 为 105MB（1MiB = 1.048 MB），在 CloudWatch 中可以监控到，如下：</p><img src="https://s1.ax1x.com/2022/12/07/zgYSET.png" alt="zgYSET.png" style="zoom: 67%;" /><p>总而言之，如果不提高 PermittedThroughput，那么该模式下 EFS 的吞吐量就上不去。而提高它的唯一办法就是提高文件系统存储量，且要 TB 级的提高才能看到明显的效果，可以说是纯商业级使用了，全是钱。而像官网描述的最高 GiB/s 级的吞吐量，要 10+ TB 才能达到，这在商业使用中很容易做到，但实验中就很难。</p><h3 id="成本估计"><a href="#成本估计" class="headerlink" title="成本估计"></a>成本估计</h3><p>以首尔地区为例，在不考虑 IA 的情况下，Standard EFS 收费为 0.33 USD GiB/月，One Zone 收费为 0.176 USD，访问不另收费。因为采用的是突增吞吐量模式，所以无需为高吞吐量额外计费，所有的成本来自于文件系统的存储大小。</p><p>以一年为时间单位，从两个极端进行估计：</p><ol><li>压力是波动的，突增积分随时都够用；</li><li>压力是持久的，突增积分用光了，吞吐量维持在基线速率以下。</li></ol><p>以 io2 作为对比，EFS 能够支持的最大吞吐量设为 300MiB/s。io2 采用默认配置，3000 预置 IOPS，大小与 EFS 配置相同。</p><h4 id="最优场景"><a href="#最优场景" class="headerlink" title="最优场景"></a>最优场景</h4><p>EFS 设置 PermittedThroughput 为 300 MiB/s，则需要 3TB 的存储大小，一年成本为：</p><ul><li>Standard：3000 * 12 * 0.33 = 11880 USD。</li><li>One Zone：3000 * 12 * 0.176 = 6336 USD。</li></ul><p>默认 3TB 的 io2 一年成本为：</p><ul><li>3000 * 12 * 0.1278（存储） + 3000 * 12 * 0.067（预置IOPS） = 7012.8 USD。</li></ul><h4 id="最差场景"><a href="#最差场景" class="headerlink" title="最差场景"></a>最差场景</h4><p>EFS 设置基线速率为 300 MiB/s，则需要 6TB 的存储大小，一年成本为：</p><ul><li>Standard：6000 * 12 * 0.33 = 23760 USD。</li><li>One Zone：6000 * 12 * 0.176 = 12672 USD。</li></ul><p>默认 6TB 的 io2 一年成本为：</p><ul><li>6000 * 12 * 0.1278（存储） + 3000 * 12 * 0.067（预置IOPS） = 11613.6USD。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果想要该模式下的 EFS 性能赶上 io2，那么必须要 TB 级别的存储量才行。由于高存储大小下，突增积分的积攒速是比较快的（比如 3TB 下的增速是 150 MiB/s），且大部分应用场景下的大压力都是波动而非持久的，因此可以凭借场景1来预测成本。可以看到，如果存储量为 3TB，One Zone EFS成本是低于io2的。</p><p>实际上，AWS 推出 EFS 旨在提供<strong>PiB级</strong>的共享文件系统，达到这个存储量级之后，EFS 最大写吞吐量能达到 3 GiB/s，每个客户端的写能达到 500 MiB/s，性能是要由于 io2 的。最重要的，io2 的最大容量只有 64TiB，所以 PiB 的文件存储只能用 EFS。</p><ul><li>EFS 适用于 TiB 级甚至 PiB 级的<strong>共享</strong>存储，但性能不如io2。</li><li>如果要做到 PiB 级的存储，只能用 EFS。</li></ul><h2 id="弹性模式"><a href="#弹性模式" class="headerlink" title="弹性模式"></a>弹性模式</h2><p>对于使用弹性吞吐量的文件系统，EFS 会自动向上或向下扩展吞吐量性能以满足工作负载的需求。弹性吞吐量是最佳吞吐量模式，适用于具有难以预测的性能要求的尖峰或不可预测的工作负载，或者驱动吞吐量平均为峰值吞吐量的 5% 或更低（平均峰值比）的应用程序。</p><p>由于具有弹性吞吐量的文件系统的吞吐量性能会自动扩展，因此无需指定或配置吞吐量容量来满足应用程序需求。但是需为读取或写入的数据量付费，并且在弹性吞吐量模式下不会累积或消耗突发信用。在所有 AWS 区域中，弹性吞吐量可为每个文件系统驱动高达 3 GiBps 的读取操作和 1 GiBps 的写入操作。</p><p>但是我不清楚这个弹性是怎么弹的，测出来的性能依然很弱，可能还是和文件系统的存储大小有关吧，和上一节的 突发吞吐量模式性能差不多。</p><p><img src="https://s1.ax1x.com/2022/12/07/zgcTaQ.png" alt="测试数据2"></p><h2 id="预置模式"><a href="#预置模式" class="headerlink" title="预置模式"></a>预置模式</h2><blockquote><p>这部分测试直接否定了我前面的所有想法。</p></blockquote><p>预置模式吞吐量理应和文件系统大小无关。为了对应 io2 的效果，这里将预置值设为 300MiB/s，也就是 PermittedThroughput 。如果真的是 PermittedThroughput 限制了吞吐量，那么此时测试结果应该可以达到 200+ MiB/s，但结果并不是这样。</p><p><img src="https://s1.ax1x.com/2022/12/07/zghOz9.png" alt="测试数据3"></p><p>可以看到，整体的 IO 和之前的都差不多，并没有达到 200+ MiB/s。在监控面板中查看吞吐量利用率，如下：</p><img src="https://s1.ax1x.com/2022/12/07/zg4meP.png" alt="吞吐量利用率" style="zoom: 67%;" /><p>PermittedThroughput 如设置的那样达到了 300 MiB/s，但利用率却很低，峰值也不过 30%。说明这个db_bench 压测的吞吐量并不是受 PermittedThroughput 所限，而是在 EFS 上只能达到 50+ MiB/s。</p><p>但是，同样的压测在 io2 上能轻松达到 200+ MiB/s，这不免让我怀疑是 EFS 的性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EC2挂载使用EFS注意点</title>
      <link href="/ec2-gua-zai-shi-yong-efs-zhu-yi-dian/"/>
      <url>/ec2-gua-zai-shi-yong-efs-zhu-yi-dian/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB: Version &amp; VersionSet</title>
      <link href="/rocksdb-version-versionset/"/>
      <url>/rocksdb-version-versionset/</url>
      
        <content type="html"><![CDATA[<p>由于 SST 是生成后就不可变的，所以 LSM-Tree 的合并就是生成 Compact 后的新 SST 并删除旧的 SST，{17，40} {12，19} {22，45} =&gt; {12，45} 这个样子。可问题来了，因为 RocksDB 支持多客户端线程，所以如果在执行 Compact 时，{17 40} {12 19} {22 45} 正在被某个客户端读时，怎么办？</p><p>很显然，此时不能删除。RocksDB 在删除 SST 时，需要等到它/它们的引用 ref == 0 时才可以删除，即其上没有任何读操作了。</p><p>所以实际上，刚刚 Compact 完的结构是这样的：{17，40} {12，19} {22，45} =&gt; {17 ，40} {12，19} {22，45} {12，45}，也就是新旧暂时都存在 LSM-Tree 中。</p><p><img src="https://s1.ax1x.com/2022/11/30/zwXUO0.png" alt="新旧SST共存"></p><p>这样就又有问题了。此时如果有新的范围在 12~45 间的读取，到底是去旧的 SST 读还是去新的 SST 读，当然是要去新的 SST 中读。那么就需要一个办法，来区分出旧的 SST 和新的 SST，Version 就是干这个的。</p><ul><li>旧有的 SST 组成一个 Version。</li><li>Compact 操作称为 VersionEdit，一个 VersionEdit 就是一次 Compact。VerionEdit 记录了哪些 SST 要被删除，哪些 SST 被新建。Version + VersionEdit =&gt; NewVersion。</li><li>Compact 后不着急删除旧有的 Version，而是让生成一个新的 Version，包括新的 SST 和未被 Compact 的 SST，新旧 Version 是共存的。</li><li>假设 Version1 在生成 Version2 的时候，Version1 正在服务很多读请求，那 Version1 自然不能丢。<ul><li>当 Version2 生成好了之后，Version2 也开始服务很多读请求。</li><li>Version2 到达某一时刻，也会开始进行 Compact，生成Version3。此时若 Version2 也在服务读请求，那自然也不能丢。</li><li>整体形成 {Version1、Version2、Version3} 的局面。</li></ul></li></ul><p>当前 DB 的所有 Version 集合，就是 VersionSet。</p><p><img src="https://s1.ax1x.com/2022/11/30/zwXIte.jpg" alt="VersionSet"></p><p>因为新来的读请求都是交给最新的 Version 去读的，所以旧的 Version 终会有一刻不再被读，此时该 Version 就会被清理掉，其中老旧的 SST 即会被删除。</p><p>万一旧的 Version 正在被写，怎么办呢？开玩笑，SST 一旦生成，只能读和删，是不可能再去写入的。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>db_bench源码(一)：random下单个thread的key生成方式与写入</title>
      <link href="/db-bench-yuan-ma-yi-random-xia-dan-ge-thread-de-key-sheng-cheng-fang-shi-yu-xie-ru/"/>
      <url>/db-bench-yuan-ma-yi-random-xia-dan-ge-thread-de-key-sheng-cheng-fang-shi-yu-xie-ru/</url>
      
        <content type="html"><![CDATA[<p>先说结论：</p><ul><li>-num 指每个线程生成 key 的范围，-writes 指实际写入 kv 的数量，默认情况下 -writes=-1，指 writes==num。生成一条 kv 就写入一条 kv，所以实际上只生成了 writes 个 kv。</li><li>每个线程随机都在 1~num 之间随机生成 key，基于 C++ 的随机数生成器 mt19937_64。每个线程用于随机的 seed 稍有不同：<ul><li>seed_base + total_thread_count_ 为每个线程的最终 seed，其中前者都一样，但后者逐个相差 1，因为每设一个线程时该值会++。</li><li>如果不指定 -seed（值为0），那么 seed_base 取自系统时间。</li><li>如果指定 -seed，那么 seed_base 就是指定的值，不过一般不指定。</li></ul></li><li>如果指定了 -keys_per_prefix，即给 key 加前缀。那么每一个 key 的前缀仍然为随机数，随机prefix = （上述 key 的随机数 % 一个固定值）。</li></ul><hr><p>以最常见的 db_bench 配置为例进行分析，如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">sudo</span> <span class="token punctuation">..</span>/db_bench  <span class="token punctuation">\</span>--benchmarks<span class="token operator">=</span><span class="token string">"fillrandom,stats,levelstats"</span> <span class="token punctuation">\</span>--max_background_jobs<span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">\</span>--compression_type<span class="token operator">=</span>none <span class="token punctuation">\</span>--num<span class="token operator">=</span><span class="token number">1000000</span> <span class="token punctuation">\</span>--threads<span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">\</span>--writes<span class="token operator">=</span><span class="token number">250000</span><span class="token punctuation">\</span>--db<span class="token operator">=</span>/home/nvme0/ysy/db_bench_test <span class="token punctuation">\</span>--wal_dir<span class="token operator">=</span>/home/nvme0/ysy/db_bench_test <span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="db-bench-tool"><a href="#db-bench-tool" class="headerlink" title="db_bench_tool()"></a>db_bench_tool()</h3><p>从入口 db_bench_tool() 开始分析，该函数用来解析命令行参数，首先由 ParseCommandLineFlags() 进行初步解析，相应参数放入对应的 FLAGS_xxx 中。</p><p>之后，会根据参数设置一些全局变量，seed_base 就在其中设定，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// db_bench_tool()</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>FLAGS_seed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint64_t</span> now <span class="token operator">=</span> FLAGS_env<span class="token operator">-></span><span class="token function">GetSystemClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">NowMicros</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    seed_base <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int64_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"Set seed to %"</span> PRIu64 <span class="token string">" because --seed was 0\n"</span><span class="token punctuation">,</span>            seed_base<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    seed_base <span class="token operator">=</span> FLAGS_seed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，此时还未进入多线程，且 seed_base 是全局变量，所以不管有没有指定 -seed，之后的每个线程的 seed_base 初值均一样。</p><p>该函数的其他部分暂时与 key 的生成无关了，直接进入 benchmark.Run()。</p><h3 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h3><p>Run() 会首先调用 Open()，然后进一步调用 InitializeOptionsFromFlags()，其作用就是通过 FLAGS_xxx 初始化 options 中的相关字段。</p><p>接着，Run() 会进入一个很大的循环体，从 -benchmark 中选出参数逐个执行：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Run()</span><span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>benchmark_stream<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>拿本示例为例，fillrandom、stats、levelstats 会依次执行循环体。但是呢，后两者实际执行的内容仅仅是输出一些 DB 信息，所以这里不管，接下来的所有分析都只针对于 fillrandom。</p><p>首先会初始化一些变量，部分如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Run()</span>num_ <span class="token operator">=</span> FLAGS_num<span class="token punctuation">;</span>reads_ <span class="token operator">=</span> <span class="token punctuation">(</span>FLAGS_reads <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> FLAGS_num <span class="token operator">:</span> FLAGS_reads<span class="token punctuation">)</span><span class="token punctuation">;</span>writes_ <span class="token operator">=</span> <span class="token punctuation">(</span>FLAGS_writes <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> FLAGS_num <span class="token operator">:</span> FLAGS_writes<span class="token punctuation">)</span><span class="token punctuation">;</span>deletes_ <span class="token operator">=</span> <span class="token punctuation">(</span>FLAGS_deletes <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> FLAGS_num <span class="token operator">:</span> FLAGS_deletes<span class="token punctuation">)</span><span class="token punctuation">;</span>value_size <span class="token operator">=</span> FLAGS_value_size<span class="token punctuation">;</span>key_size_ <span class="token operator">=</span> FLAGS_key_size<span class="token punctuation">;</span>entries_per_batch_ <span class="token operator">=</span> FLAGS_batch_size<span class="token punctuation">;</span>writes_before_delete_range_ <span class="token operator">=</span> FLAGS_writes_before_delete_range<span class="token punctuation">;</span>writes_per_range_tombstone_ <span class="token operator">=</span> FLAGS_writes_per_range_tombstone<span class="token punctuation">;</span>range_tombstone_width_ <span class="token operator">=</span> FLAGS_range_tombstone_width<span class="token punctuation">;</span>max_num_range_tombstones_ <span class="token operator">=</span> FLAGS_max_num_range_tombstones<span class="token punctuation">;</span><span class="token comment">// ...</span><span class="token keyword">int</span> num_threads <span class="token operator">=</span> FLAGS_threads<span class="token punctuation">;</span><span class="token keyword">int</span> num_repeat <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> num_warmup <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要注意以下变量：</p><ul><li>num_：就是 -num</li><li>writes_ ：如果指定 -writes，那么就是指定的值。如果没指定，FLAGS_writes==-1，所以此时 writes_ ==FLAGS_num==num_，符合官方声明</li></ul><blockquote><p>-writes (Number of write operations to do. If negative, do –num writes.)<br>type: int64 default: -1</p></blockquote><ul><li>entries_per_batch_：就是 –batch_size，指一个 WriteBatch 多少条 kv，默认为 1，一般不会另行指定</li><li>num_threads：就是 0-threads</li><li>num_repeat 和 num_warmup：这俩一直都是初值，1和0</li></ul><p>接下来设置 fillrandom 的 method，为 WriteRandom，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Run()</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token string">"fillrandom"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fresh_db <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    method <span class="token operator">=</span> <span class="token operator">&amp;</span>Benchmark<span class="token double-colon punctuation">::</span>WriteRandom<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后会进行一些 DB 的初始化什么的，然后调用 RunBenchmark()：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Run()</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num_repeat<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Stats stats <span class="token operator">=</span> <span class="token function">RunBenchmark</span><span class="token punctuation">(</span>num_threads<span class="token punctuation">,</span> name<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>    combined_stats<span class="token punctuation">.</span><span class="token function">AddStats</span><span class="token punctuation">(</span>stats<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>FLAGS_confidence_interval_only<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        combined_stats<span class="token punctuation">.</span><span class="token function">ReportWithConfidenceIntervals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        combined_stats<span class="token punctuation">.</span><span class="token function">Report</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// ....</span>Stats <span class="token function">RunBenchmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> Slice name<span class="token punctuation">,</span>                   <span class="token keyword">void</span> <span class="token punctuation">(</span>Benchmark<span class="token double-colon punctuation">::</span><span class="token operator">*</span>method<span class="token punctuation">)</span><span class="token punctuation">(</span>ThreadState<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>num_repeat == 1，所以仅调用一次。其中 name==“fillrandom”，method=”WriteRandom”。</p><h3 id="RunBenchmark"><a href="#RunBenchmark" class="headerlink" title="RunBenchmark()"></a>RunBenchmark()</h3><p>进入 RunBenchmark()，从此处开始和多线程相关。其会给每个线程创建 ThreadArg 和 ThreadState，保存相关的状态，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// RunBenchmark()</span>ThreadArg<span class="token operator">*</span> arg <span class="token operator">=</span> <span class="token keyword">new</span> ThreadArg<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>bm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>method <span class="token operator">=</span> method<span class="token punctuation">;</span>    arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>shared <span class="token operator">=</span> <span class="token operator">&amp;</span>shared<span class="token punctuation">;</span>    total_thread_count_<span class="token operator">++</span><span class="token punctuation">;</span>    arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ThreadState</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> total_thread_count_<span class="token punctuation">)</span><span class="token punctuation">;</span>    arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread<span class="token operator">-></span>stats<span class="token punctuation">.</span><span class="token function">SetReporterAgent</span><span class="token punctuation">(</span>reporter_agent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread<span class="token operator">-></span>shared <span class="token operator">=</span> <span class="token operator">&amp;</span>shared<span class="token punctuation">;</span>    FLAGS_env<span class="token operator">-></span><span class="token function">StartThread</span><span class="token punctuation">(</span>ThreadBody<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，核心为 arg[i].thread 的创建：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">total_thread_count_<span class="token operator">++</span><span class="token punctuation">;</span>arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ThreadState</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> total_thread_count_<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入 Thread 的构造函数，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Per-thread state for concurrent executions of the same benchmark.</span><span class="token keyword">struct</span> <span class="token class-name">ThreadState</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tid<span class="token punctuation">;</span>             <span class="token comment">// 0..n-1 when running in n threads</span>    Random64 rand<span class="token punctuation">;</span>         <span class="token comment">// Has different seeds for different threads</span>    Stats stats<span class="token punctuation">;</span>    SharedState<span class="token operator">*</span> shared<span class="token punctuation">;</span>    <span class="token keyword">explicit</span> <span class="token function">ThreadState</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> my_seed<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">tid</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span>seed_base <span class="token operator">+</span> my_seed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，核心就是 thread.rand，为 Random64 对象，它是一个随机数生成器，基于 C++ 的 mt19937_64 随机数生成器，完整代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Random64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>mt19937_64 generator_<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Random64</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">generator_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// Generates the next random number</span>    <span class="token keyword">uint64_t</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">generator_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// Returns a uniformly distributed value in the range [0..n-1]</span>    <span class="token comment">// REQUIRES: n > 0</span>    <span class="token keyword">uint64_t</span> <span class="token function">Uniform</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">uniform_int_distribution</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span>generator_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Randomly returns true ~"1/n" of the time, and false otherwise.</span>    <span class="token comment">// REQUIRES: n > 0</span>    <span class="token keyword">bool</span> <span class="token function">OneIn</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Uniform</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// Skewed: pick "base" uniformly from range [0,max_log] and then</span>    <span class="token comment">// return "base" random bits.  The effect is to pick a number in the</span>    <span class="token comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span>    <span class="token keyword">uint64_t</span> <span class="token function">Skewed</span><span class="token punctuation">(</span><span class="token keyword">int</span> max_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">Uniform</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">Uniform</span><span class="token punctuation">(</span>max_log <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，线程用于随机数生成的种子为 seed_base + total_thread_count_ 。而 total_thread_count_ 是随着循环递增的，所以每个线程的种子都不同，相互之间差 1。</p><p>接着，每个线程进入 ThreadBody()，并行执行 method。从此往后，所有的分析都基于独立的线程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ThreadBody()</span>thread<span class="token operator">-></span>stats<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>thread<span class="token operator">-></span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>arg<span class="token operator">-></span>bm<span class="token operator">-></span><span class="token operator">*</span><span class="token punctuation">(</span>arg<span class="token operator">-></span>method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际上就是 DoWrite()，指定写入类型为 RANDOM：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">WriteRandom</span><span class="token punctuation">(</span>ThreadState<span class="token operator">*</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">DoWrite</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> RANDOM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="DoWrite"><a href="#DoWrite" class="headerlink" title="DoWrite()"></a>DoWrite()</h3><p>进入 DoWrite 后，首先会定义一个变量 num_ops，值如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">const</span> <span class="token keyword">int64_t</span> num_ops <span class="token operator">=</span> writes_ <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> num_ <span class="token operator">:</span> writes_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很显然，它就是实际执行的写操作数量，除非指定 -writes=0，那么它就等于 writes_，在本例中就是 250000。</p><p>接下来，DoWrite() 会创建一个 vector<key_gen>，为 key 生成器，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span>size_t num_key_gens <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>db_<span class="token punctuation">.</span>db <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    num_key_gens <span class="token operator">=</span> multi_dbs_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread %ld 's num_key_gens is : %ld"</span><span class="token punctuation">,</span>thread<span class="token operator">-></span>tid<span class="token punctuation">,</span>num_key_gens<span class="token punctuation">)</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>KeyGenerator<span class="token operator">>></span> <span class="token function">key_gens</span><span class="token punctuation">(</span>num_key_gens<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int64_t</span> max_ops <span class="token operator">=</span> num_ops <span class="token operator">*</span> num_key_gens<span class="token punctuation">;</span><span class="token keyword">int64_t</span> ops_per_stage <span class="token operator">=</span> max_ops<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>FLAGS_num_column_families <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> FLAGS_num_hot_column_families <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ops_per_stage <span class="token operator">=</span> <span class="token punctuation">(</span>max_ops <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>FLAGS_num_column_families <span class="token operator">/</span>                                     FLAGS_num_hot_column_families<span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Duration <span class="token function">duration</span><span class="token punctuation">(</span>test_duration<span class="token punctuation">,</span> max_ops<span class="token punctuation">,</span> ops_per_stage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">uint64_t</span> num_per_key_gen <span class="token operator">=</span> num_ <span class="token operator">+</span> max_num_range_tombstones_<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num_key_gens<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    key_gens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">KeyGenerator</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>thread<span class="token operator">-></span>rand<span class="token punctuation">)</span><span class="token punctuation">,</span> write_mode<span class="token punctuation">,</span>                                       num_per_key_gen<span class="token punctuation">,</span> ops_per_stage<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，db_.db 一般不会为 nullptr，故 num_key_gens==1，即只有 1 个 key 生成器。如果不确定的话可以打日志看一下，本示例就是 1 。</p><p>max_ops 就是最大的写入次数，由于 num_key_gens==1，所以其值等于 num_ops，即250000。CF_num 默认就是 1，一般也不会指定，所以后面这个 if 体不用管。</p><p>num_per_key_gen 指一个 key_gen 要生成的 key 数量，如果不指定 -max_num_range_tombstones 选项的话，其值就是 num_，本例中为 1000000。</p><p>接下来就是创建 key_gen 了，其构造器如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">KeyGenerator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">KeyGenerator</span><span class="token punctuation">(</span>Random64<span class="token operator">*</span> rand<span class="token punctuation">,</span> WriteMode mode<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> num<span class="token punctuation">,</span>                 <span class="token keyword">uint64_t</span> <span class="token comment">/*num_per_set*/</span> <span class="token operator">=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">rand_</span><span class="token punctuation">(</span>rand<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode_</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">num_</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mode_ <span class="token operator">==</span> UNIQUE_RANDOM<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                values_<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>num_<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num_<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    values_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">RandomShuffle</span><span class="token punctuation">(</span>values_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>seed_base<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 mode==RANDOM，所以函数体都没用，仅仅赋值了成员变量，核心就是 rand，也就是上文的 thread-&gt;rand。</p><p>生成完 key 的构造器后，开始生成 value 的构造器：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">RandomGenerator gen<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个构造器和 key_gen 不同，它主要依据 Distribution 来决定 value，分为 uniform、normal、fixed，不过我们这里只讨论 key 的生成，所以该构造器不详细说明。</p><p>接着，DoWrite() 会定义一个 batch，并给 key 分配空间，相关代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span>WriteBatch <span class="token function">batch</span><span class="token punctuation">(</span><span class="token comment">/*reserved_bytes=*/</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">/*max_bytes=*/</span><span class="token number">0</span><span class="token punctuation">,</span>                 FLAGS_write_batch_protection_bytes_per_key<span class="token punctuation">,</span>                 user_timestamp_size_<span class="token punctuation">)</span><span class="token punctuation">;</span>Status s<span class="token punctuation">;</span><span class="token keyword">int64_t</span> bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> key_guard<span class="token punctuation">;</span>Slice key <span class="token operator">=</span> <span class="token function">AllocateKey</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key_guard<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> begin_key_guard<span class="token punctuation">;</span>Slice begin_key <span class="token operator">=</span> <span class="token function">AllocateKey</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>begin_key_guard<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> end_key_guard<span class="token punctuation">;</span>Slice end_key <span class="token operator">=</span> <span class="token function">AllocateKey</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>end_key_guard<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后面有一长段代码是关于 disposable/persistent keys simulation 的，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">bool</span> skip_for_loop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> is_disposable_entry <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span> <span class="token function">disposable_entries_index</span><span class="token punctuation">(</span>num_key_gens<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span> <span class="token function">persistent_ent_and_del_index</span><span class="token punctuation">(</span>num_key_gens<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread %d 's disposable_entries_batch_size is : %ld\n"</span><span class="token punctuation">,</span>thread<span class="token operator">-></span>tid<span class="token punctuation">,</span> FLAGS_disposable_entries_batch_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread %d 's persistent_entries_batch_size is : %ld\n"</span><span class="token punctuation">,</span>thread<span class="token operator">-></span>tid<span class="token punctuation">,</span> FLAGS_persistent_entries_batch_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">uint64_t</span> kNumDispAndPersEntries <span class="token operator">=</span>    FLAGS_disposable_entries_batch_size <span class="token operator">+</span>    FLAGS_persistent_entries_batch_size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方对其说明如下：</p><blockquote><p>— Variables used in disposable/persistent keys simulation:</p><p>The following variables are used when disposable_entries_batch_size is &gt;0. We simualte a workload where the following sequence is repeated multiple times: “A set of keys S1 is inserted (‘disposable entries’), then after some delay another set of keys S2 is inserted (‘persistent entries’) and the first set of keys S1 is deleted. S2 artificially represents the insertion of hypothetical results from some undefined computation done on the first set of keys S1. The next sequence can start as soon as the last disposable entry in the set S1 of this sequence is inserted, if the delay is non negligible”</p></blockquote><p>实际上我们一般不会用这个，至少在本例中，FLAGS_disposable_entries_batch_size 和 FLAGS_persistent_entries_batch_size 均为 0，故 kNumDispAndPersEntries，所以后续所有要求 （kNumDispAndPersEntries &gt; 0）的操作均不用看。</p><p>在进入真正的写入循环之前，DoWrite() 定义了一些变量：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">int64_t</span> stage <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int64_t</span> num_written <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int64_t</span> next_seq_db_at <span class="token operator">=</span> num_ops<span class="token punctuation">;</span>size_t id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int64_t</span> num_range_deletions <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>着重关注两个变量：</p><ul><li>num_written：已经写入的 kv 数量。</li><li>id：key_gen 的 id，即 vector<key_gen> 的元素下标。</li></ul><p>接着，DoWrite() 将正式进入写循环，该循环有两层，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num_per_key_gen <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>duration<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span>entries_per_batch_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int64_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> entries_per_batch_<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，外层用来判断是否所有的写操作都已结束，内层用来把每一条写入 Put 进 batch 中。首先看外层，循环的结束标志为 duration.Done() 返回 true，其函数体如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token keyword">int64_t</span> increment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>increment <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> increment <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// avoid Done(0) and infinite loops</span>    ops_ <span class="token operator">+=</span> increment<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>max_seconds_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Recheck every appx 1000 ops (exact iff increment is factor of 1000)</span>        <span class="token keyword">auto</span> granularity <span class="token operator">=</span> FLAGS_ops_between_duration_checks<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ops_ <span class="token operator">/</span> granularity<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ops_ <span class="token operator">-</span> increment<span class="token punctuation">)</span> <span class="token operator">/</span> granularity<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">uint64_t</span> now <span class="token operator">=</span> FLAGS_env<span class="token operator">-></span><span class="token function">NowMicros</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> start_at_<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token operator">>=</span> max_seconds_<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ops_ <span class="token operator">></span> max_ops_<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很简单，每写完一个 batch，ops_ 都会加 increment，后者就是 batch 的 kv 数，一旦达到了 max_ops_ ，就返回 true。因此，外层循环的结束标志是，writes_ 个 kv 全部写完。</p><p>大循环首先会确定 key_gen 的 id，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num_per_key_gen <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>duration<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span>entries_per_batch_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>write_mode <span class="token operator">!=</span> SEQUENTIAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        id <span class="token operator">=</span> thread<span class="token operator">-></span>rand<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> num_key_gens<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 num_key_gens==1，所以 id 始终为 0。</p><p>直接看内层循环，它会先生成一个 key，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int64_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> entries_per_batch_<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int64_t</span> rand_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>write_mode <span class="token operator">==</span> UNIQUE_RANDOM<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ... 跳过</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>kNumDispAndPersEntries <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ... 跳过</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          rand_num <span class="token operator">=</span> key_gens<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token operator">-></span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">GenerateKeyFromInt</span><span class="token punctuation">(</span>rand_num<span class="token punctuation">,</span> FLAGS_num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，Next() 代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">KeyGenerator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint64_t</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>mode_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> SEQUENTIAL<span class="token operator">:</span>                <span class="token keyword">return</span> next_<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> RANDOM<span class="token operator">:</span>                <span class="token keyword">return</span> rand_<span class="token operator">-></span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> num_<span class="token punctuation">;</span>            <span class="token keyword">case</span> UNIQUE_RANDOM<span class="token operator">:</span>                <span class="token function">assert</span><span class="token punctuation">(</span>next_ <span class="token operator">&lt;</span> num_<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> values_<span class="token punctuation">[</span>next_<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在 Random 模式下，通过 Random64（也就是 mt19937_64）来生成一个随机数然后取模来保证范围。</p><p>GenerateKeyFromInt() 将用该随机数生成 key，部分代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">GenerateKeyFromInt</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> v<span class="token punctuation">,</span> <span class="token keyword">int64_t</span> num_keys<span class="token punctuation">,</span> Slice<span class="token operator">*</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>key<span class="token operator">-></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> pos <span class="token operator">=</span> start<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keys_per_prefix_ <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int64_t</span> num_prefix <span class="token operator">=</span> num_keys <span class="token operator">/</span> keys_per_prefix_<span class="token punctuation">;</span>        <span class="token keyword">int64_t</span> prefix <span class="token operator">=</span> v <span class="token operator">%</span> num_prefix<span class="token punctuation">;</span>        <span class="token keyword">int</span> bytes_to_fill <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>prefix_size_<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>port<span class="token double-colon punctuation">::</span>kLittleEndian<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes_to_fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prefix <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes_to_fill <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>prefix<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes_to_fill<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix_size_ <span class="token operator">></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// fill the rest with 0s</span>            <span class="token function">memset</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">,</span> prefix_size_ <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pos <span class="token operator">+=</span> prefix_size_<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> bytes_to_fill <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>key_size_ <span class="token operator">-</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pos <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>port<span class="token double-colon punctuation">::</span>kLittleEndian<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes_to_fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>v <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes_to_fill <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes_to_fill<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pos <span class="token operator">+=</span> bytes_to_fill<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key_size_ <span class="token operator">></span> pos <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">,</span> key_size_ <span class="token operator">-</span> <span class="token punctuation">(</span>pos <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分两部分来看，存在 prefix 和不存在 prefix。当指定了 -keys_per_perfix 后，将通过刚才的随机数生成一个前缀，然后把它插入 key 之前：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// GenerateKeyFromInt()</span><span class="token keyword">int64_t</span> num_prefix <span class="token operator">=</span> num_keys <span class="token operator">/</span> keys_per_prefix_<span class="token punctuation">;</span><span class="token keyword">int64_t</span> prefix <span class="token operator">=</span> v <span class="token operator">%</span> num_prefix<span class="token punctuation">;</span><span class="token comment">// ...</span><span class="token function">memcpy</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>prefix<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes_to_fill<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不存在 prefix，那么就是单纯把随机数放进去，然后不足补0：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>port<span class="token double-colon punctuation">::</span>kLittleEndian<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes_to_fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>v <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes_to_fill <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes_to_fill<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pos <span class="token operator">+=</span> bytes_to_fill<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>key_size_ <span class="token operator">></span> pos <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">,</span> key_size_ <span class="token operator">-</span> <span class="token punctuation">(</span>pos <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到 DoWrite()，生成完 key 后，开始生成 value，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span>Slice val<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>kNumDispAndPersEntries <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 跳过</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    val <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">Generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 FLAGS_num_column_families==1，所以进入如下代码块，直接将 key-value 插入 batch。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>FLAGS_num_column_families <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    batch<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>插入完成后，num_written 自增，不过注意此时 batch 还未写入 DB。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token operator">++</span>num_written<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-use_blob_db 指定是否使用 BlobDB，默认为 false，不使用。所以一路来到如下代码块：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DoWrite()</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>use_blob_db_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Not stacked BlobDB</span>    s <span class="token operator">=</span> db_with_cfh<span class="token operator">-></span>db<span class="token operator">-></span><span class="token function">Write</span><span class="token punctuation">(</span>write_options_<span class="token punctuation">,</span> <span class="token operator">&amp;</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里开始就进入了 RocksDB 的 Write 入口了，接下来的操作就如 <a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-wu-xie-yi-kuang-jia/">RocksDB源码：写</a> 系列中所述了。至此，一个 bacth 中 kv 的写入基本就结束了，然后回到外层循环，通过 duration.Done() 判断是否继续。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>db_bench笔记</title>
      <link href="/db-bench-bi-ji/"/>
      <url>/db-bench-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>–threads 指什么</p></blockquote><p>这里只看写。thread 就是执行写的客户端线程，但是这个线程不仅仅是提交一个写请求，而是直接走完 RocksDB 的写流程，包括 WAL 和 Memtable 这些前台写入。深入 db-bench 代码可以看到，一个 thread 就是一个 ThreadBody()，而每一个用于写的 ThreadBody 最后都会执行 batch.Put(）然后 db-&gt;Write(write_options_, &amp;batch) 写入 DB，这个就是 RocksDB 的写入口，随后继续执行所有的前台写工作。</p><blockquote><p> –num 和 –threads</p></blockquote><p>当指定 –num = 1000 -threads = 4 时，不是指开四个线程合作写 1000 条，而是指每一条都写 1000，一共写 4000 条，这个可以在 ThreadBody() 中打日志看出来。所以如果想要确保总 num 一定，就要进行一次除，–num=250 – threads=4 这样。</p><blockquote><p>多线程的 key 分布问题</p></blockquote><p>当采取上述方法后，就面临了一个新的问题。每一个线程都会自己随机 key，这就导致了线程之间会有一定概率的 key 重合，而线程越多，重合的 key 也就越多。– num=1000 –threads=1 和 –num=250 –threads=4 虽然生成的总 kv 数一致，但是前者是在 [0,1000) 之间随机生成 key，后者是在 [0,250) 之间随机生成 key，且 4 线程并发生成。后者的随机范围小，所以重合的概率就高很多。</p><blockquote><p>用 –writes 解决上述问题</p></blockquote><p>–writes 指实际写入多少条 kv，默认情况下和 –num 同值。为了保证 key 的随机分布，可以让所有线程都在同一范围内生成 key，然后写入时整除就行。比如，– num=1000 –threads=1 –writes=1000 和 –num=1000 –threads=4 –writes=250，二者都是总共写入 1000 条 kv。不同于 –num=250 – threads=4，新的方式可以保证每个线程生成的 key 都是在 1~1000 间随机的，然后从其中选出 250 个进行写。极大降低了线程间的重合率。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UserThread &amp; BackgroundThread</title>
      <link href="/rocksdb-userthread-backgroundthread/"/>
      <url>/rocksdb-userthread-backgroundthread/</url>
      
        <content type="html"><![CDATA[<p>这两天在复现 P2KV 的测试，其中提到了两个概念：user thread 和 background thread。其中，user thread 是客户端的写线程，从下发写请求开始，一直涵盖写 WAL、Memtable 这些前台任务。background thread 更容易理解，就是后台执行 Flush 和 Compact 的线程。</p><p>理解了之后，具体该怎么针对的测不同类线程占用的 CPU 呢，这就要改 RocksDB 的源码了。核心思想有两个：</p><ul><li>获取线程 ID</li><li>绑核</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>这里可以借助两个工具： <code>mpstat</code> 和 <code>htop</code>。</p><p>其中，mpstat 可以测试某一个 CPU 核的负载，很适合绑核测试方法，htop 则相当于 Linux 下的任务管理器，以线程为单位（严格来说是轻量级进程 lwp） 监控 CPU、Mem 等的占用，很适合第一种测试方法。</p><p>mpstat：</p><p><img src="https://s1.ax1x.com/2022/11/22/z3SaWT.png" alt="mpstat"></p><p>htop：</p><p><img src="https://s1.ax1x.com/2022/11/22/z3SfSO.png" alt="htop"></p><h2 id="User-Thread"><a href="#User-Thread" class="headerlink" title="User Thread"></a>User Thread</h2><p>采用 db_bench 进行压测，一个 user thread 就是一个写线程，比如下面这条命令就是 8 个 user thread：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./db_bench --benchmarks<span class="token operator">=</span><span class="token string">"fillrandom,stats,levelstats"</span> --threads<span class="token operator">=</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>db_bench 有关的源码位于 <code>tools/db_bench_tool.cc</code>下，又 db_bench_tool() 函数为入口，首先完成对参数的初始化核 Benchmark 的创建，然后开始运行 Benchmark。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ROCKSDB_NAMESPACE<span class="token double-colon punctuation">::</span>Benchmark benchmark<span class="token punctuation">;</span>benchmark<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入 Run() 之后，可以看到它会根据参数选择写入的方式，放入变量 method ：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ...</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token string">"fillbatch"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fresh_db <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    entries_per_batch_ <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    method <span class="token operator">=</span> <span class="token operator">&amp;</span>Benchmark<span class="token double-colon punctuation">::</span>WriteSeq<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token string">"fillrandom"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fresh_db <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    method <span class="token operator">=</span> <span class="token operator">&amp;</span>Benchmark<span class="token double-colon punctuation">::</span>WriteRandom<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不管是哪种写模式，都是封装的 DoWrite() ，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">WriteSeq</span><span class="token punctuation">(</span>ThreadState<span class="token operator">*</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">DoWrite</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> SEQUENTIAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">WriteRandom</span><span class="token punctuation">(</span>ThreadState<span class="token operator">*</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">DoWrite</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> RANDOM<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是多线程的实现不是在这里的。继续 Run() 函数，看到下面这句话：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">RunBenchmark</span><span class="token punctuation">(</span>num_threads<span class="token punctuation">,</span> name<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，num_threads 就是客户端线程数，在这里是 8。RunBenchmark() 会创建 num_threads 个 ThreaedArg，每个代表一个线程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Stats <span class="token function">RunBenchmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> Slice name<span class="token punctuation">,</span>                   <span class="token keyword">void</span> <span class="token punctuation">(</span>Benchmark<span class="token double-colon punctuation">::</span><span class="token operator">*</span>method<span class="token punctuation">)</span><span class="token punctuation">(</span>ThreadState<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    ThreadArg<span class="token operator">*</span> arg <span class="token operator">=</span> <span class="token keyword">new</span> ThreadArg<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>bm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>method <span class="token operator">=</span> method<span class="token punctuation">;</span>        arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>shared <span class="token operator">=</span> <span class="token operator">&amp;</span>shared<span class="token punctuation">;</span>        total_thread_count_<span class="token operator">++</span><span class="token punctuation">;</span>        arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ThreadState</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> total_thread_count_<span class="token punctuation">)</span><span class="token punctuation">;</span>        arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread<span class="token operator">-></span>stats<span class="token punctuation">.</span><span class="token function">SetReporterAgent</span><span class="token punctuation">(</span>reporter_agent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>thread<span class="token operator">-></span>shared <span class="token operator">=</span> <span class="token operator">&amp;</span>shared<span class="token punctuation">;</span>        FLAGS_env<span class="token operator">-></span><span class="token function">StartThread</span><span class="token punctuation">(</span>ThreadBody<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arg<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RocksDB 是使用线程池进行线程管理的，而线程池的入口为一个名为 Env 的类。RocksDB 维护了一个 Env 类，这个类在同一个进程中的多个 DB 实例之间是能够共享的，所以 RocksDB 将这个类作为线程池的入口。而 FLAGS_env 就指向 Env 对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> ROCKSDB_NAMESPACE<span class="token double-colon punctuation">::</span>Env<span class="token operator">*</span> FLAGS_env <span class="token operator">=</span> ROCKSDB_NAMESPACE<span class="token double-colon punctuation">::</span><span class="token class-name">Env</span><span class="token double-colon punctuation">::</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，FLAGS_env-&gt;StartThread() 就是在线程池创建一个线程，工作内容就是 ThreadBody，因此一个 ThreadBody 就是 user thread。ThreadBody 核心如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">thread<span class="token operator">-></span>stats<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>thread<span class="token operator">-></span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>arg<span class="token operator">-></span>bm<span class="token operator">-></span><span class="token operator">*</span><span class="token punctuation">(</span>arg<span class="token operator">-></span>method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>FLAGS_perf_level <span class="token operator">></span> ROCKSDB_NAMESPACE<span class="token double-colon punctuation">::</span>PerfLevel<span class="token double-colon punctuation">::</span>kDisable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    thread<span class="token operator">-></span>stats<span class="token punctuation">.</span><span class="token function">AddMessage</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"PERF_CONTEXT:\n"</span><span class="token punctuation">)</span> <span class="token operator">+</span>                             <span class="token function">get_perf_context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>thread<span class="token operator">-></span>stats<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，其调用了 method，也就是 DoWrite()，而 DoWrite() 深入下去就是 batch-&gt;Put()，之后的流程就是 RocksDB 的写流程了。</p><p>因此，想要获取 user thread，只要在 ThreadBody 处打印线程 ID 即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ThreadBody</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"db_bench enters the ThreadBody(), lwpid is: %ld\n"</span><span class="token punctuation">,</span> <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_gettid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，用的是 syscall(SYS_gettid)，获取的是 lwp，也就是 htop 种最左边一列的 PID。和 Windows 不同，Linux 严格来讲并没有线程的概念，所谓的 “线程” 都是通过一个名为<strong>轻量级进程</strong>的东西模拟的，也就是 lwp。参考：<a href="https://blog.csdn.net/mm_hh/article/details/72587207">LWP与线程</a></p><p>重新编译安装，运行 db_bench，即可看到 8 个 user thread 的 id。</p><p><img src="https://s1.ax1x.com/2022/11/22/z3iWsU.png" alt="8个user thread"></p><p>刚好对应 db_bench 在 htop 中的前 8 个线程。</p><h2 id="Background-Thread"><a href="#Background-Thread" class="headerlink" title="Background Thread"></a>Background Thread</h2><p>RocksDB 采用的是线程池，Flush / Compaction 任务会交给线程池中的 background thread（BGThread）。在 RocksDB 的线程池中，所有的 BGThread 都是通过 StartBGThreads() 来创建，然后通过 RegisterThread() 来注册进线程池。整个函数调用链如下：</p><p><code>ThreadPoolImpl::Impl::StartBGThreads--&gt;BGThreadWrapper--&gt;ThreadStatusUtil::RegisterThread</code></p><p>StartBGThreads() 函数定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> ThreadPoolImpl<span class="token double-colon punctuation">::</span><span class="token class-name">Impl</span><span class="token double-colon punctuation">::</span><span class="token function">StartBGThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Start background thread if necessary</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>bgthreads_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> total_threads_limit_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        port<span class="token double-colon punctuation">::</span>Thread <span class="token function">p_t</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>BGThreadWrapper<span class="token punctuation">,</span>                         <span class="token keyword">new</span> <span class="token function">BGThreadMetadata</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> bgthreads_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Set the thread name to aid debugging</span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>_GNU_SOURCE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">defined</span><span class="token punctuation">(</span>__GLIBC_PREREQ<span class="token punctuation">)</span></span></span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">__GLIBC_PREREQ</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span></span></span>        <span class="token keyword">auto</span> th_handle <span class="token operator">=</span> p_t<span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>string thread_priority <span class="token operator">=</span> <span class="token class-name">Env</span><span class="token double-colon punctuation">::</span><span class="token function">PriorityToString</span><span class="token punctuation">(</span><span class="token function">GetThreadPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>ostringstream thread_name_stream<span class="token punctuation">;</span>        thread_name_stream <span class="token operator">&lt;&lt;</span> <span class="token string">"rocksdb:"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> thread_priority<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            thread_name_stream <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">pthread_setname_np</span><span class="token punctuation">(</span>th_handle<span class="token punctuation">,</span> thread_name_stream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        bgthreads_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到该函数逻辑很简单，只要 BGThread 数量不超过 total_threads_limit_，那就创建。因此想要获取 BGThread 的 id，只需要在 BGThreadWrapper 中打印即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> ThreadPoolImpl<span class="token double-colon punctuation">::</span><span class="token class-name">Impl</span><span class="token double-colon punctuation">::</span><span class="token function">BGThreadWrapper</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"RocksDB starts a BGThread, lwpid is: %ld\n"</span><span class="token punctuation">,</span> <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_gettid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重新编译安装。运行 db_bench，可以看到在 RocksDB 刚启动的时候就创建了很多 BGThread 进入线程池备用，而不是等到 Flush / Compaction 任务来的时候在创建。</p><img src="https://s1.ax1x.com/2022/11/22/z3i7J1.png" alt="z3i7J1.png" style="zoom: 67%;" /><p>上述 BGThread 一共有 33 个。这个值和 db_bench 中的配置有关，max_background_compactions 决定最多的后台 Compaction 线程数，max_background_flushes 决定最多的后台 Flush 线程数，两者共同组成 BGThread。本此示例中，max_background_compactions = 32，max_background_flushes = 1。</p><p>上面的这些 BGThread，刚好对应了 db_bench 在 htop 中除了 8 个 user thread 之外的绝大部分线程（注意，不是全部）。说明客户端的 user thread 和 后台的 background thread 占了 RocksDB 线程池中的绝大部分。</p><p><img src="https://s1.ax1x.com/2022/11/22/z3i1VH.png" alt="htop"></p><p>之后，就可以根据 background thread 的 id 去看 background thread 的 CPU、Mem 占用率了。</p><p>不过，当 thread 数量过多时，我相测总体的 CPU 占用率，比如我想测 background thread 整体的 CPU 占用率，而不是看某一个 thread，这样的话仅仅依靠 thread id 是很麻烦的，因为不仅要实时监控，还要求和。</p><p>因此建议用第二个方法来测：绑核。</p><h2 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h2><p>以 background thread 为例，我要测总体的 CPU 利用率，那我就可以在 StartBGThread() 处进行绑核，让所有的 background thread 绑定到一个核上且独占。这样一来，我只需用 mpstat 监控那一个核的 CPU 负载即可。</p><p>绑核过程如下：</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiKV部署(Docker多实例)</title>
      <link href="/tikv-bu-shu-docker-duo-shi-li/"/>
      <url>/tikv-bu-shu-docker-duo-shi-li/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇讲了如何用多台虚拟机部署 TiKV 集群，用的工具为 TiUP。但是那个方法无法用于 Docker，我试了下，开 四个 Container 模拟四台机器 ，但 tiup cluster deploy 会一直失败，因为 systemctl 无法执行。 问题的本质在于，Docker 只是进程隔离，而不是系统隔离，所有容器用的还是主机的系统，因此没有 systemctl 一说，故 Docker 部署 TiKV 无法用一般的多机部署方法。</p><p>幸运的是，PingCap 为 Docker 部署 TiKV 提供了专门的方法，它给了两个镜像：<code>pingcap/tikv</code> 与 <code>pingcap/pd</code> ，分别作为对应的示例。官方部署文档地址：<a href="https://tikv.org/docs/4.0/tasks/deploy/docker/">TiKV | Docker Deployment</a></p><p>但是，官方的部署方法一堆错误，用它的流程根本跑不起来，比如：</p><ul><li>没有架设 Docker 网桥，没有给 Container 设置 IP，因此 run 的时候 IP 是不确定的。</li><li>端口映射重复了，怎么可能多个 Container 映射主机的同一个端口。</li><li>6 个示例的数据挂载在主机的同一个目录 /data 下，这样做不报错，但多实例就没有意义了。</li></ul><p>这里更新一下部署流程，解决上述三个问题。</p><h3 id="实例分配"><a href="#实例分配" class="headerlink" title="实例分配"></a>实例分配</h3><table><thead><tr><th>容器名称</th><th>容器 IP</th><th>端口</th><th>服务</th><th>数据挂载路径</th></tr></thead><tbody><tr><td>pd1</td><td>172.18.0.11</td><td>12379:2379</td><td>PD1</td><td>~/ysy/tikv/data/pd1</td></tr><tr><td>pd2</td><td>172.18.0.12</td><td>22379:2379</td><td>PD2</td><td>~/ysy/tikv/data/pd2</td></tr><tr><td>pd3</td><td>172.18.0.13</td><td>32379:2379</td><td>PD3</td><td>~/ysy/tikv/data/pd3</td></tr><tr><td>tikv1</td><td>172.18.0.14</td><td>40160:20160</td><td>TiKV1</td><td>~/ysy/tikv/data/tikv1</td></tr><tr><td>tikv2</td><td>172.18.0.15</td><td>50160:20160</td><td>TiKV2</td><td>~/ysy/tikv/data/tikv2</td></tr><tr><td>tikv3</td><td>172.18.0.16</td><td>60160:20160</td><td>TiKV3</td><td>~/ysy/tikv/data/tikv3</td></tr></tbody></table><h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><p>创建挂载目录，当前位于 <code>~/ysy</code> 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p tikv/data/pd1<span class="token function">mkdir</span> -p tikv/data/pd2<span class="token function">mkdir</span> -p tikv/data/pd3<span class="token function">mkdir</span> -p tikv/data/tikv1<span class="token function">mkdir</span> -p tikv/data/tikv2<span class="token function">mkdir</span> -p tikv/data/tikv3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建虚拟网桥：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> network create --subnet<span class="token operator">=</span><span class="token number">172.18</span>.0.0/16 tikv-network<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拉取镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull pingcap/tikv:latest<span class="token function">docker</span> pull pingcap/pd:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="节点启动"><a href="#节点启动" class="headerlink" title="节点启动"></a>节点启动</h3><p>PD1：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name pd1 <span class="token punctuation">\</span>-p <span class="token number">12379</span>:2379 <span class="token punctuation">\</span>-p <span class="token number">12380</span>:2380 <span class="token punctuation">\</span>-v /etc/localtime:/etc/localtime:ro <span class="token punctuation">\</span>-v /home/zyh/ysy/tikv/data/pd1:/data <span class="token punctuation">\</span>--network tikv-network <span class="token punctuation">\</span>--ip <span class="token number">172.18</span>.0.11 <span class="token punctuation">\</span>pingcap/pd:latest <span class="token punctuation">\</span>--name<span class="token operator">=</span><span class="token string">"pd1"</span> <span class="token punctuation">\</span>--data-dir<span class="token operator">=</span><span class="token string">"/data/pd1"</span> <span class="token punctuation">\</span>--client-urls<span class="token operator">=</span><span class="token string">"http://0.0.0.0:2379"</span> <span class="token punctuation">\</span>--advertise-client-urls<span class="token operator">=</span><span class="token string">"http://172.18.0.11:2379"</span> <span class="token punctuation">\</span>--peer-urls<span class="token operator">=</span><span class="token string">"http://0.0.0.0:2380"</span> <span class="token punctuation">\</span>--advertise-peer-urls<span class="token operator">=</span><span class="token string">"http://172.18.0.11:2380"</span> <span class="token punctuation">\</span>--initial-cluster<span class="token operator">=</span><span class="token string">"pd1=http://172.18.0.11:2380,pd2=http://172.18.0.12:2380,pd3=http://172.18.0.13:2380"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PD2：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name pd2 <span class="token punctuation">\</span>-p <span class="token number">22379</span>:2379 <span class="token punctuation">\</span>-p <span class="token number">22380</span>:2380 <span class="token punctuation">\</span>-v /etc/localtime:/etc/localtime:ro <span class="token punctuation">\</span>-v /home/zyh/ysy/tikv/data/pd2:/data <span class="token punctuation">\</span>--network tikv-network <span class="token punctuation">\</span>--ip <span class="token number">172.18</span>.0.12 <span class="token punctuation">\</span>pingcap/pd:latest <span class="token punctuation">\</span>--name<span class="token operator">=</span><span class="token string">"pd2"</span> <span class="token punctuation">\</span>--data-dir<span class="token operator">=</span><span class="token string">"/data/pd2"</span> <span class="token punctuation">\</span>--client-urls<span class="token operator">=</span><span class="token string">"http://0.0.0.0:2379"</span> <span class="token punctuation">\</span>--advertise-client-urls<span class="token operator">=</span><span class="token string">"http://172.18.0.12:2379"</span> <span class="token punctuation">\</span>--peer-urls<span class="token operator">=</span><span class="token string">"http://0.0.0.0:2380"</span> <span class="token punctuation">\</span>--advertise-peer-urls<span class="token operator">=</span><span class="token string">"http://172.18.0.12:2380"</span> <span class="token punctuation">\</span>--initial-cluster<span class="token operator">=</span><span class="token string">"pd1=http://172.18.0.11:2380,pd2=http://172.18.0.12:2380,pd3=http://172.18.0.13:2380"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PD3：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name pd3 <span class="token punctuation">\</span>-p <span class="token number">32379</span>:2379 <span class="token punctuation">\</span>-p <span class="token number">32380</span>:2380 <span class="token punctuation">\</span>-v /etc/localtime:/etc/localtime:ro <span class="token punctuation">\</span>-v /home/zyh/ysy/tikv/data/pd3:/data <span class="token punctuation">\</span>--network tikv-network <span class="token punctuation">\</span>--ip <span class="token number">172.18</span>.0.13 <span class="token punctuation">\</span>pingcap/pd:latest <span class="token punctuation">\</span>--name<span class="token operator">=</span><span class="token string">"pd3"</span> <span class="token punctuation">\</span>--data-dir<span class="token operator">=</span><span class="token string">"/data/pd3"</span> <span class="token punctuation">\</span>--client-urls<span class="token operator">=</span><span class="token string">"http://0.0.0.0:2379"</span> <span class="token punctuation">\</span>--advertise-client-urls<span class="token operator">=</span><span class="token string">"http://172.18.0.13:2379"</span> <span class="token punctuation">\</span>--peer-urls<span class="token operator">=</span><span class="token string">"http://0.0.0.0:2380"</span> <span class="token punctuation">\</span>--advertise-peer-urls<span class="token operator">=</span><span class="token string">"http://172.18.0.13:2380"</span> <span class="token punctuation">\</span>--initial-cluster<span class="token operator">=</span><span class="token string">"pd1=http://172.18.0.11:2380,pd2=http://172.18.0.12:2380,pd3=http://172.18.0.13:2380"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TiKV1：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name tikv1 <span class="token punctuation">\</span>-p <span class="token number">40160</span>:20160 <span class="token punctuation">\</span>-v /etc/localtime:/etc/localtime:ro <span class="token punctuation">\</span>-v /home/zyh/ysy/tikv/data/tikv1:/data <span class="token punctuation">\</span>--network tikv-network <span class="token punctuation">\</span>--ip <span class="token number">172.18</span>.0.14 <span class="token punctuation">\</span>pingcap/tikv:latest <span class="token punctuation">\</span>--addr<span class="token operator">=</span><span class="token string">"0.0.0.0:20160"</span> <span class="token punctuation">\</span>--advertise-addr<span class="token operator">=</span><span class="token string">"172.18.0.14:20160"</span> <span class="token punctuation">\</span>--data-dir<span class="token operator">=</span><span class="token string">"/data/tikv1"</span> <span class="token punctuation">\</span>--pd<span class="token operator">=</span><span class="token string">"172.18.0.11:2379,172.18.0.12:2379,172.18.0.13:2379"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TiKV2：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name tikv2 <span class="token punctuation">\</span>-p <span class="token number">50160</span>:20160 <span class="token punctuation">\</span>-v /etc/localtime:/etc/localtime:ro <span class="token punctuation">\</span>-v /home/zyh/ysy/tikv/data/tikv2:/data <span class="token punctuation">\</span>--network tikv-network <span class="token punctuation">\</span>--ip <span class="token number">172.18</span>.0.15 <span class="token punctuation">\</span>pingcap/tikv:latest <span class="token punctuation">\</span>--addr<span class="token operator">=</span><span class="token string">"0.0.0.0:20160"</span> <span class="token punctuation">\</span>--advertise-addr<span class="token operator">=</span><span class="token string">"172.18.0.15:20160"</span> <span class="token punctuation">\</span>--data-dir<span class="token operator">=</span><span class="token string">"/data/tikv2"</span> <span class="token punctuation">\</span>--pd<span class="token operator">=</span><span class="token string">"172.18.0.11:2379,172.18.0.12:2379,172.18.0.13:2379"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TiKV3：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name tikv3 <span class="token punctuation">\</span>-p <span class="token number">60160</span>:20160 <span class="token punctuation">\</span>-v /etc/localtime:/etc/localtime:ro <span class="token punctuation">\</span>-v /home/zyh/ysy/tikv/data/tikv3:/data <span class="token punctuation">\</span>--network tikv-network <span class="token punctuation">\</span>--ip <span class="token number">172.18</span>.0.16 <span class="token punctuation">\</span>pingcap/tikv:latest <span class="token punctuation">\</span>--addr<span class="token operator">=</span><span class="token string">"0.0.0.0:20160"</span> <span class="token punctuation">\</span>--advertise-addr<span class="token operator">=</span><span class="token string">"172.18.0.16:20160"</span> <span class="token punctuation">\</span>--data-dir<span class="token operator">=</span><span class="token string">"/data/tikv3"</span> <span class="token punctuation">\</span>--pd<span class="token operator">=</span><span class="token string">"172.18.0.11:2379,172.18.0.12:2379,172.18.0.13:2379"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token number">172.18</span>.0.11:2379/pd/api/v1/stores <span class="token comment"># 验证集群，所有返回Up即成功！</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zyh@zyh ~/ysy $ <span class="token function">curl</span> <span class="token number">172.18</span>.0.11:2379/pd/api/v1/stores<span class="token punctuation">&#123;</span>  <span class="token string">"count"</span><span class="token builtin class-name">:</span> <span class="token number">3</span>,  <span class="token string">"stores"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token string">"store"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"id"</span><span class="token builtin class-name">:</span> <span class="token number">4</span>,        <span class="token string">"address"</span><span class="token builtin class-name">:</span> <span class="token string">"172.18.0.15:20160"</span>,        <span class="token string">"version"</span><span class="token builtin class-name">:</span> <span class="token string">"5.0.1"</span>,        <span class="token string">"status_address"</span><span class="token builtin class-name">:</span> <span class="token string">"127.0.0.1:20180"</span>,        <span class="token string">"git_hash"</span><span class="token builtin class-name">:</span> <span class="token string">"e26389a278116b2f61addfa9f15ca25ecf38bc80"</span>,        <span class="token string">"start_timestamp"</span><span class="token builtin class-name">:</span> <span class="token number">1667380969</span>,        <span class="token string">"deploy_path"</span><span class="token builtin class-name">:</span> <span class="token string">"/"</span>,        <span class="token string">"last_heartbeat"</span><span class="token builtin class-name">:</span> <span class="token number">1667382689745138538</span>,        <span class="token string">"state_name"</span><span class="token builtin class-name">:</span> <span class="token string">"Up"</span>      <span class="token punctuation">&#125;</span>,      <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"capacity"</span><span class="token builtin class-name">:</span> <span class="token string">"228.2GiB"</span>,        <span class="token string">"available"</span><span class="token builtin class-name">:</span> <span class="token string">"25.18GiB"</span>,        <span class="token string">"used_size"</span><span class="token builtin class-name">:</span> <span class="token string">"31.5MiB"</span>,        <span class="token string">"leader_count"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"leader_weight"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"leader_score"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"leader_size"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"region_count"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_weight"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_score"</span><span class="token builtin class-name">:</span> <span class="token number">5010678.9452130785</span>,        <span class="token string">"region_size"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"start_ts"</span><span class="token builtin class-name">:</span> <span class="token string">"2022-11-02T09:22:49Z"</span>,        <span class="token string">"last_heartbeat_ts"</span><span class="token builtin class-name">:</span> <span class="token string">"2022-11-02T09:51:29.745138538Z"</span>,        <span class="token string">"uptime"</span><span class="token builtin class-name">:</span> <span class="token string">"28m40.745138538s"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>,    <span class="token punctuation">&#123;</span>      <span class="token string">"store"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"id"</span><span class="token builtin class-name">:</span> <span class="token number">6</span>,        <span class="token string">"address"</span><span class="token builtin class-name">:</span> <span class="token string">"172.18.0.16:20160"</span>,        <span class="token string">"version"</span><span class="token builtin class-name">:</span> <span class="token string">"5.0.1"</span>,        <span class="token string">"status_address"</span><span class="token builtin class-name">:</span> <span class="token string">"127.0.0.1:20180"</span>,        <span class="token string">"git_hash"</span><span class="token builtin class-name">:</span> <span class="token string">"e26389a278116b2f61addfa9f15ca25ecf38bc80"</span>,        <span class="token string">"start_timestamp"</span><span class="token builtin class-name">:</span> <span class="token number">1667381000</span>,        <span class="token string">"deploy_path"</span><span class="token builtin class-name">:</span> <span class="token string">"/"</span>,        <span class="token string">"last_heartbeat"</span><span class="token builtin class-name">:</span> <span class="token number">1667382690721349602</span>,        <span class="token string">"state_name"</span><span class="token builtin class-name">:</span> <span class="token string">"Up"</span>      <span class="token punctuation">&#125;</span>,      <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"capacity"</span><span class="token builtin class-name">:</span> <span class="token string">"228.2GiB"</span>,        <span class="token string">"available"</span><span class="token builtin class-name">:</span> <span class="token string">"25.18GiB"</span>,        <span class="token string">"used_size"</span><span class="token builtin class-name">:</span> <span class="token string">"31.5MiB"</span>,        <span class="token string">"leader_count"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"leader_weight"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"leader_score"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"leader_size"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"region_count"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_weight"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_score"</span><span class="token builtin class-name">:</span> <span class="token number">4968170.338600396</span>,        <span class="token string">"region_size"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"start_ts"</span><span class="token builtin class-name">:</span> <span class="token string">"2022-11-02T09:23:20Z"</span>,        <span class="token string">"last_heartbeat_ts"</span><span class="token builtin class-name">:</span> <span class="token string">"2022-11-02T09:51:30.721349602Z"</span>,        <span class="token string">"uptime"</span><span class="token builtin class-name">:</span> <span class="token string">"28m10.721349602s"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>,    <span class="token punctuation">&#123;</span>      <span class="token string">"store"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"id"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"address"</span><span class="token builtin class-name">:</span> <span class="token string">"172.18.0.14:20160"</span>,        <span class="token string">"version"</span><span class="token builtin class-name">:</span> <span class="token string">"5.0.1"</span>,        <span class="token string">"status_address"</span><span class="token builtin class-name">:</span> <span class="token string">"127.0.0.1:20180"</span>,        <span class="token string">"git_hash"</span><span class="token builtin class-name">:</span> <span class="token string">"e26389a278116b2f61addfa9f15ca25ecf38bc80"</span>,        <span class="token string">"start_timestamp"</span><span class="token builtin class-name">:</span> <span class="token number">1667380946</span>,        <span class="token string">"deploy_path"</span><span class="token builtin class-name">:</span> <span class="token string">"/"</span>,        <span class="token string">"last_heartbeat"</span><span class="token builtin class-name">:</span> <span class="token number">1667382697269407432</span>,        <span class="token string">"state_name"</span><span class="token builtin class-name">:</span> <span class="token string">"Up"</span>      <span class="token punctuation">&#125;</span>,      <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"capacity"</span><span class="token builtin class-name">:</span> <span class="token string">"228.2GiB"</span>,        <span class="token string">"available"</span><span class="token builtin class-name">:</span> <span class="token string">"25.18GiB"</span>,        <span class="token string">"used_size"</span><span class="token builtin class-name">:</span> <span class="token string">"31.5MiB"</span>,        <span class="token string">"leader_count"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"leader_weight"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"leader_score"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"leader_size"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_count"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_weight"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"region_score"</span><span class="token builtin class-name">:</span> <span class="token number">5065447.578683018</span>,        <span class="token string">"region_size"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>,        <span class="token string">"start_ts"</span><span class="token builtin class-name">:</span> <span class="token string">"2022-11-02T09:22:26Z"</span>,        <span class="token string">"last_heartbeat_ts"</span><span class="token builtin class-name">:</span> <span class="token string">"2022-11-02T09:51:37.269407432Z"</span>,        <span class="token string">"uptime"</span><span class="token builtin class-name">:</span> <span class="token string">"29m11.269407432s"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> TiKV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无锁队列与CAS</title>
      <link href="/wu-suo-dui-lie-yu-cas/"/>
      <url>/wu-suo-dui-lie-yu-cas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文是 cv 的，原文链接：<a href="https://coolshell.cn/articles/8239.html">https://coolshell.cn/articles/8239.html</a></p></blockquote><p>关于无锁队列的实现，网上有很多文章，虽然本文可能和那些文章有所重复，但是我还是想以我自己的方式把这些文章中的重要的知识点串起来和大家讲一讲这个技术。下面开始正文</p><h3 id="关于CAS等原子操作"><a href="#关于CAS等原子操作" class="headerlink" title="关于CAS等原子操作"></a>关于CAS等原子操作</h3><p>在开始说无锁队列之前，我们需要知道一个很重要的技术就是 CAS 操作 —— Compare &amp; Set，或是 Compare &amp; Swap，<strong>现在几乎所有的 CPU 指令都支持 CAS 的原子操作，X86 下对应的是 CMPXCHG 汇编指令。</strong>有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。</p><p>这个操作用 C 语言来描述就是下面这个样子：（代码来自 <a href="https://en.wikipedia.org/wiki/Compare-and-swap">Wikipedia的Compare And Swap</a> 词条）意思就是说，看一看内存 <code>*reg</code> 里的值是不是 <code>oldval</code>，如果是的话，则对其赋值 <code>newval</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">compare_and_swap</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> reg<span class="token punctuation">,</span> <span class="token keyword">int</span> oldval<span class="token punctuation">,</span> <span class="token keyword">int</span> newval<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> old_reg_val <span class="token operator">=</span> <span class="token operator">*</span>reg<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>old_reg_val <span class="token operator">==</span> oldval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token operator">*</span>reg <span class="token operator">=</span> newval<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> old_reg_val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，<code>old_reg_val</code> 总是返回，于是，我们可以在 <code>compare_and_swap</code> 操作之后对其进行测试，以查看它是否与 <code>oldval</code> 相匹配，因为它可能有所不同，这意味着另一个并发线程已成功地竞争到 <code>compare_and_swap</code> 并成功将 <code>reg</code> 值从 <code>oldval</code> 更改为别的值了。</p><p>这个操作可以变种为返回 bool 值的形式（返回 bool值的好处在于，可以调用者知道有没有更新成功）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">compare_and_swap</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> oldval<span class="token punctuation">,</span> <span class="token keyword">int</span> newval<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span>addr <span class="token operator">!=</span> oldval <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span>addr <span class="token operator">=</span> newval<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 CAS 相似的还有下面的原子操作：（这些东西大家自己看 Wikipedia，也没什么复杂的）</p><ul><li><a href="https://en.wikipedia.org/wiki/Fetch-and-add">Fetch And Add</a>，一般用来对变量做 +1 的原子操作</li><li><a href="https://en.wikipedia.org/wiki/Test-and-set">Test-and-set</a>，写值到某个内存位置并传回其旧值。汇编指令BST</li><li><a href="https://en.wikipedia.org/wiki/Test_and_Test-and-set">Test and Test-and-set</a>，用来低低Test-and-Set的资源争夺情况</li></ul><p>在实际的C/C++程序中，CAS的各种实现版本如下：</p><p><strong>1）GCC的CAS</strong></p><p>GCC4.1+版本中支持CAS的原子操作（完整的原子操作可参看<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html"> GCC Atomic Builtins</a>）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">__sync_bool_compare_and_swap</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type oldval type newval<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>type <span class="token function">__sync_val_compare_and_swap</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type oldval type newval<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2）Windows的CAS</strong></p><p>在Windows下，你可以使用下面的Windows API来完成CAS：（完整的Windows原子操作可参看MSDN的<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx#interlocked_functions">InterLocked Functions</a>）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">InterlockedCompareExchange</span> <span class="token punctuation">(</span> __inout LONG <span class="token keyword">volatile</span> <span class="token operator">*</span>Target<span class="token punctuation">,</span>                            __in LONG Exchange<span class="token punctuation">,</span>                            __in LONG Comperand<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3) C++11中的CAS</strong></p><p>C++11中的STL中的atomic类的函数可以让你跨平台。（完整的C++11的原子操作可参看 <a href="http://en.cppreference.com/w/cpp/atomic">Atomic Operation Library</a>）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span><span class="token keyword">bool</span> <span class="token function">atomic_compare_exchange_weak</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">*</span> obj<span class="token punctuation">,</span>                                   T<span class="token operator">*</span> expected<span class="token punctuation">,</span> T desired <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span><span class="token keyword">bool</span> <span class="token function">atomic_compare_exchange_weak</span><span class="token punctuation">(</span> <span class="token keyword">volatile</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">*</span> obj<span class="token punctuation">,</span>                                   T<span class="token operator">*</span> expected<span class="token punctuation">,</span> T desired <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="无锁队列的链表实现"><a href="#无锁队列的链表实现" class="headerlink" title="无锁队列的链表实现"></a>无锁队列的链表实现</h3><p>下面的代码主要参考于两篇论文：</p><ul><li>John D. Valois 1994年10月在拉斯维加斯的并行和分布系统系统国际大会上的一篇论文——《<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&rep=rep1&type=pdf">Implementing Lock-Free Queues</a>》</li><li>美国纽约罗切斯特大学 Maged M. Michael 和 Michael L. Scott 在1996年3月发表的一篇论文 《<a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms</a>》</li></ul><p>（注：下面的代码并不完全与这篇论文相同）</p><p>初始化一个队列的代码很简，初始化一个dummy结点（注：在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断），如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    Q<span class="token operator">-></span>head <span class="token operator">=</span> Q<span class="token operator">-></span>tail <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先来看一下进队列用CAS实现的方式，基本上来说就是链表的两步操作：</p><ol><li>第一步，把tail指针的next指向要加入的结点。 <code>tail-&gt;next = p;</code></li><li>第二步，把tail指针移到队尾。 <code>tail = p;</code></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token comment">//进队列</span><span class="token punctuation">&#123;</span>    <span class="token comment">//准备新加入的结点数据</span>    n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n<span class="token operator">-></span>value <span class="token operator">=</span> data<span class="token punctuation">;</span>    n<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> Q<span class="token operator">-></span>tail<span class="token punctuation">;</span> <span class="token comment">//取链表尾指针的快照</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">CAS</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">!=</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//while条件注释：如果没有把结点链在尾指针上，再试</span>    <span class="token function">CAS</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>tail<span class="token punctuation">,</span> p<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//置尾结点 tail = n;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 <code>p-&gt;next</code> 是 <code>NULL</code>，那么，把新结点 <code>n</code> 加到队尾。如果不成功，则重新再来一次！</p><p>就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。</p><p>但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：</p><ol><li>如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，</li><li>此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为<code>tail-&gt;next</code>不是NULL了。</li><li>直到T1线程更新完 <code>tail</code> 指针，于是其它的线程中的某个线程就可以得到新的 <code>tail</code> 指针，继续往下走了。</li><li>所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，<code>tail</code> 指针必然可以被更新。</li></ol><p>这里有一个潜在的问题——<strong>如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了</strong>。下面是改良版的EnQueue()</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token comment">//进队列改良版 v1</span><span class="token punctuation">&#123;</span>    n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n<span class="token operator">-></span>value <span class="token operator">=</span> data<span class="token punctuation">;</span>    n<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> Q<span class="token operator">-></span>tail<span class="token punctuation">;</span>    oldp <span class="token operator">=</span> p    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">CAS</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">!=</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果没有把结点链在尾上，再试</span>    <span class="token function">CAS</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>tail<span class="token punctuation">,</span> oldp<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//置尾结点</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们让每个线程，自己fetch 指针 <code>p</code> 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 <code>p</code> 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？</p><p>比如：直接 fetch <code>Q-&gt;tail</code> 到队尾？因为，所有的线程都共享着 Q-&gt;tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token comment">//进队列改良版 v2 </span><span class="token punctuation">&#123;</span>    n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n<span class="token operator">-></span>value <span class="token operator">=</span> data<span class="token punctuation">;</span>    n<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//先取一下尾指针和尾指针的next</span>        tail <span class="token operator">=</span> Q<span class="token operator">-></span>tail<span class="token punctuation">;</span>        next <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">//如果尾指针已经被移动了，则重新开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> tail <span class="token operator">!=</span> Q<span class="token operator">-></span>tail <span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">//如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">CAS</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>tail<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//如果加入结点成功，则退出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">CAS</span><span class="token punctuation">(</span>tail<span class="token operator">-></span>next<span class="token punctuation">,</span> next<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> TRUE <span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">CAS</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>tail<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//置尾结点</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的代码还是很清楚的，相信你一定能看懂，而且，这也是 Java 中的 <code>ConcurrentLinkedQueue</code> 的实现逻辑，当然，我上面的这个版本比 Java 的好一点，因为没有 if 嵌套，嘿嘿。</p><p>好了，我们解决了EnQueue，我们再来看看DeQueue的代码：（很简单，我就不解释了）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span> <span class="token comment">//出队列</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> Q<span class="token operator">-></span>head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> ERR_EMPTY_QUEUE<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">CAS</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>head<span class="token punctuation">,</span> p<span class="token punctuation">,</span> p<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> TRUE <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token operator">-></span>next<span class="token operator">-></span>value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>我们可以看到，DeQueue的代码操作的是 <code>head-&gt;next</code>，而不是 <code>head</code> 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，<code>head</code> 和 <code>tail</code> 都指向同一个结点的问题，这样 <code>EnQueue</code> 和 <code>DeQueue</code> 要互相排斥了</strong>。</p><p>但是，如果 <code>head</code> 和 <code>tail</code> 都指向同一个结点，这意味着队列为空，应该返回 <code>ERR_EMPTY_QUEUE</code>，但是，在判断 <code>p-&gt;next == NULL</code> 时，另外一个EnQueue操作做了一半，此时的 p-&gt;next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。如下所示：</p><img src="https://s1.ax1x.com/2022/11/02/xHlS61.png" alt="出入队互斥" style="zoom:67%;" /><p>虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span> <span class="token comment">//出队列，改进版</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//取出头指针，尾指针，和第一个元素的指针</span>        head <span class="token operator">=</span> Q<span class="token operator">-></span>head<span class="token punctuation">;</span>        tail <span class="token operator">=</span> Q<span class="token operator">-></span>tail<span class="token punctuation">;</span>        next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">// Q->head 指针已移动，重新取 head指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> head <span class="token operator">!=</span> Q<span class="token operator">-></span>head <span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment">// 如果是空队列</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> head <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> next <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> ERR_EMPTY_QUEUE<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//如果 tail 指针落后了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> head <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> next <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">CAS</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>tail<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//移动 head 指针成功后，取出数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">CAS</span><span class="token punctuation">(</span> Q<span class="token operator">-></span>head<span class="token punctuation">,</span> head<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">==</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            value <span class="token operator">=</span> next<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放老的dummy结点</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码的逻辑和 Java 的 <code>ConcurrentLinkedQueue</code> 的 <code>poll</code> 方法很一致了。也是《<a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms</a>》这篇论文中的实现。</p><h3 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a>CAS的ABA问题</h3><p>所谓ABA（<a href="https://en.wikipedia.org/wiki/ABA_problem">见维基百科的ABA词条</a>），问题基本是这个样子：</p><ol><li>进程P1在共享变量中读到值为A</li><li>P1被抢占了，进程P2执行</li><li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li><li>P1回来看到共享变量里的值没有被改变，于是继续执行。</li></ol><p>虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。<strong>ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。</strong></p><p>比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（<strong>内存管理中重用内存基本上是一种很常见的行为</strong>）</p><p>这个例子你可能没有看懂，维基百科上给了一个活生生的例子——</p><blockquote><p><em>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</em></p></blockquote><p>这就是ABA的问题。</p><h3 id="解决ABA的问题"><a href="#解决ABA的问题" class="headerlink" title="解决ABA的问题"></a>解决ABA的问题</h3><p>维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容</p><p>1）一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。</p><p>2）只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。</p><p>这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）</p><p>当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，论文《<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&rep=rep1&type=pdf">Implementing Lock-Free Queues</a>》给出一这么一个方法——<strong>使用结点内存引用计数refcnt</strong>！（论文《<a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms</a>》中的实现方法也基本上是一样的，用到的是增加一个计数，可以理解为版本号）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SafeRead</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    loop<span class="token operator">:</span>        p <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        Fetch<span class="token operator">&amp;</span><span class="token function">Add</span><span class="token punctuation">(</span>p<span class="token operator">-></span>refcnt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">Release</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">goto</span> loop<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的 Fetch&amp;Add和Release分是是加引用计数和减引用计数，都是原子操作，这样就可以阻止内存被回收了。</p><h3 id="用数组实现无锁队列"><a href="#用数组实现无锁队列" class="headerlink" title="用数组实现无锁队列"></a>用数组实现无锁队列</h3><p>本实现来自论文《<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&rep=rep1&type=pdf">Implementing Lock-Free Queues</a>》</p><p>使用数组来实现队列是很常见的方法，因为没有内存的分部和释放，一切都会变得简单，实现的思路如下：</p><p>1）数组队列应该是一个ring buffer形式的数组（环形数组）</p><p>2）数组的元素应该有三个可能的值：HEAD，TAIL，EMPTY（当然，还有实际的数据）</p><p>3）数组一开始全部初始化成EMPTY，有两个相邻的元素要初始化成HEAD和TAIL，这代表空队列。</p><p>4）EnQueue操作。假设数据x要入队列，定位TAIL的位置，使用double-CAS方法把(TAIL, EMPTY) 更新成 (x, TAIL)。需要注意，如果找不到(TAIL, EMPTY)，则说明队列满了。</p><p>5）DeQueue操作。定位HEAD的位置，把(HEAD, x)更新成(EMPTY, HEAD)，并把x返回。同样需要注意，如果x是TAIL，则说明队列为空。</p><p>算法的一个关键是——如何定位HEAD或TAIL？</p><p>1）我们可以声明两个计数器，一个用来计数EnQueue的次数，一个用来计数DeQueue的次数。</p><p>2）这两个计算器使用使用Fetch&amp;ADD来进行原子累加，在EnQueue或DeQueue完成的时候累加就好了。</p><p>3）累加后求个模什么的就可以知道TAIL和HEAD的位置了。</p><p>如下图所示：</p><img src="https://s1.ax1x.com/2022/11/02/xHlkkD.png" alt="xHlkkD.png" style="zoom:67%;" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上基本上就是所有的无锁队列的技术细节，这些技术都可以用在其它的无锁数据结构上。</p><p>1）无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。</p><p>2）对于Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。</p><p>还有一些和Lock Free的文章你可以去看看：</p><ul><li>Code Project 上的雄文 《<a href="http://www.codeproject.com/Articles/153898/Yet-another-implementation-of-a-lock-free-circular">Yet another implementation of a lock-free circular array queue</a>》</li><li>Herb Sutter的《<a href="http://www.drdobbs.com/parallel/writing-lock-free-code-a-corrected-queue/210604448?pgno=1">Writing Lock-Free Code: A Corrected Queue</a>》– 用C++11的std::atomic模板。</li><li>IBM developerWorks的《<a href="https://www.ibm.com/developerworks/cn/aix/library/au-multithreaded_structures2/index.html">设计不使用互斥锁的并发数据结构</a>》</li></ul><p>一句话总结一下无锁队列：</p><blockquote><p>我有一辆 look-free 的自行车，它不用专门的车锁，而是自己锁自己！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiKV部署(多机)</title>
      <link href="/tikv-bu-shu-duo-ji/"/>
      <url>/tikv-bu-shu-duo-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>准备 4 台 Ubuntu16.04 虚拟机，3 台用来存储，1 台用来监控。</p><p>组件分配如下：</p><table><thead><tr><th>节点类型</th><th>部署数量</th><th>所在节点 IP</th></tr></thead><tbody><tr><td>TiKV</td><td>3</td><td>192.168.52.150<br />192.168.52.151<br />192.168.52.152</td></tr><tr><td>PD</td><td>3</td><td>192.168.52.150<br />192.168.52.151<br />192.168.52.152</td></tr><tr><td>monitoring server</td><td>1</td><td>192.168.52.153</td></tr><tr><td>grafana server</td><td>1</td><td>192.168.52.153</td></tr><tr><td>alertmanager server</td><td>1</td><td>192.168.52.153</td></tr></tbody></table><h3 id="部署预准备"><a href="#部署预准备" class="headerlink" title="部署预准备"></a>部署预准备</h3><h4 id="连接与权限"><a href="#连接与权限" class="headerlink" title="连接与权限"></a>连接与权限</h4><p>该步将给每一个机器（节点）添加一个用户名为 tikv，并让各节点的 tikv 用户可以免认证进行 ssh 连接。每个节点都要添加该用户，因此预准备步骤所有机器都要执行。</p><p>编辑 /etc/ssh/sshd_config，以下字段设为 yes</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">PermitRootLogin yesPasswordAuthentication yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启 sshd 服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加用户 tikv</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> adduser tikv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 visudo 命令在末尾加上以下文本，让 tikv 可以免密使用 sudo 所有权限</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">tikv ALL=(ALL) NOPASSWD</span><span class="token punctuation">:</span> ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出（按 Crtl + O，然后 Enter，最后 Ctrl + X）</p><p>配置 ssh 免认证登录（每个节点都要配置所有 IP，包括自己）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsassh-copy-id -i ~/.ssh/id_rsa.pub <span class="token number">192.168</span>.52.150ssh-copy-id -i ~/.ssh/id_rsa.pub <span class="token number">192.168</span>.52.151ssh-copy-id -i ~/.ssh/id_rsa.pub <span class="token number">192.168</span>.52.152ssh-copy-id -i ~/.ssh/id_rsa.pub <span class="token number">192.168</span>.52.153<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>认证是否能免认证登录其它节点：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> 其他节点IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2022/10/31/xTM0v6.png" alt="ssh免密登录"></p><h4 id="盘挂载（可选）"><a href="#盘挂载（可选）" class="headerlink" title="盘挂载（可选）"></a>盘挂载（可选）</h4><p>如果想让某一个节点使用特定的存储设备，比如 ssd，那么就在该机器上使用卷挂载，如果不用就直接跳过。比如，想在一个 tikv 节点上使用 SSD（/dev/sda1），那么就在该节点上执行以下挂载命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">fdisk</span> -l<span class="token function">sudo</span> <span class="token function">fdisk</span> /dev/sda1<span class="token function">sudo</span> mkfs.ext4 /dev/sda1<span class="token function">sudo</span> <span class="token function">mount</span> -t ext4 /dev/sda1 /data<span class="token function">sudo</span> <span class="token function">chmod</span> -R 0777 /data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在之后的部署流程中，让该节点的数据存在 /data 下即可。</p><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>部署操作只需要在 1 个节点上操作，这里我选择 192.168.52.150。部署步骤参考官方文档：<a href="https://tikv.org/docs/6.1/deploy/install/production/">TiUP 部署</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装 TiUP：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刷新环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证 TiUP 是否安装成功：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 TiUP cluster 组件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新 TiUP cluster 至最新版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup update --self <span class="token operator">&amp;&amp;</span> tiup update cluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证 TiUP cluster 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup --binary cluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>生成初始化的集群配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster template <span class="token operator">></span> topology.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用以下内容替换 topology.yaml：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token string">"tikv"</span>  <span class="token key atrule">ssh_port</span><span class="token punctuation">:</span> <span class="token number">22</span>  <span class="token key atrule">deploy_dir</span><span class="token punctuation">:</span> <span class="token string">"/data/tikv-deploy"</span>  <span class="token key atrule">data_dir</span><span class="token punctuation">:</span> <span class="token string">"/data/tikv-data"</span>  <span class="token key atrule">arch</span><span class="token punctuation">:</span> <span class="token string">"amd64"</span><span class="token key atrule">monitored</span><span class="token punctuation">:</span>  <span class="token key atrule">node_exporter_port</span><span class="token punctuation">:</span> <span class="token number">9100</span>  <span class="token key atrule">blackbox_exporter_port</span><span class="token punctuation">:</span> <span class="token number">9115</span><span class="token key atrule">pd_servers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.150  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.151  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.152<span class="token key atrule">tikv_servers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.150  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.151  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.152<span class="token key atrule">monitoring_servers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.153<span class="token key atrule">grafana_servers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.153<span class="token key atrule">alertmanager_servers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.52.153<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="开始部署-1"><a href="#开始部署-1" class="headerlink" title="开始部署"></a>开始部署</h4><p>部署集群：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster deploy tikv-test v5.0.1 ./topology.yaml --user root <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> <span class="token punctuation">[</span>-i /home/root/.ssh/gcp_rsa<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>You can use secret keys or interactive passwords for security authentication when you deploy TiKV using TiUP:</p><ul><li>If you use secret keys, you can specify the path of the keys through <code>-i</code> or <code>--identity_file</code>;</li><li>If you use passwords, add the <code>-p</code> flag to enter the password interaction window;</li><li>If password-free login to the target machine has been configured, no authentication is required.</li></ul></blockquote><p>这里我们选择之前生成的密钥文件，因此部署命令为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster deploy tikv-test v5.0.1 ./topology.yaml --user tikv -i ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动集群：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster start foobar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TiUP cluster 支持多集群管理，刚刚我们部署的只是一个集群，名为 tikv-test。想要查看所有集群，通过下述命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看指定集群的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup cluster display tikv-test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2022/10/31/xTlH9s.png" alt="查看tikv-test信息"></p><p>节点 4 部署了 grafana，用来监控集群，通过浏览器可以进入 dashboard：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">URL</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//192.168.52.153<span class="token punctuation">:</span>3000/<span class="token key atrule">User</span><span class="token punctuation">:</span> admin<span class="token key atrule">Passwd</span><span class="token punctuation">:</span> admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装 cli 工具进行 TiKV 管理，这里安装 v5.0.1 版本的，和集群版本同步：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tiup ctl:v5.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用 TiKV 的 go client 测试：<a href="https://tikv.org/docs/4.0/reference/clients/go/">https://tikv.org/docs/4.0/reference/clients/go/</a></p><p>使用 TiKV 的 python client 测试：<a href="https://tikv.org/docs/5.1/concepts/tikv-in-5-minutes/#set-up-a-local-tikv-cluster-with-the-default-options">https://tikv.org/docs/5.1/concepts/tikv-in-5-minutes/#set-up-a-local-tikv-cluster-with-the-default-options</a></p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> TiKV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(八): 写(四)-Memtable</title>
      <link href="/rocksdb-yuan-ma-xue-xi-ba-xie-si-memtable/"/>
      <url>/rocksdb-yuan-ma-xue-xi-ba-xie-si-memtable/</url>
      
        <content type="html"><![CDATA[<p>本篇博客将从源码层面分析 RocksDB 中 memtable 的创建与写入，且不考虑 pipelined_write，所用代码版本为 <code>v7.7.4</code></p><hr><p>当 WriteGroup 写完 WAL 后，就开始写 memtable，写分为两大类，parallel 和  ! parallel。前者的话，Leader 会唤醒 WriteGroup 中的所有 Writer，一起并行写入，后者的话，Leader 独自负责整个 WriteGroup 的串行写入。二者仅仅是 WriteBatch 的串行写和并行写的区别，而每个 WriteBatch 的写入，实现方式还是一致的。本篇博客以 ! parallel 为例，分析写 memtable 的源码。</p><p>还是在 WriteImpl() ，WAL 写完之后，会做一些 seq 和 callback 的操作，随后进入 memtable 的写流程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parallel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// w.sequence will be set inside InsertInto</span>        w<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>            write_group<span class="token punctuation">,</span> current_sequence<span class="token punctuation">,</span> column_family_memtables_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>flush_scheduler_<span class="token punctuation">,</span> <span class="token operator">&amp;</span>trim_history_scheduler_<span class="token punctuation">,</span>            write_options<span class="token punctuation">.</span>ignore_missing_column_families<span class="token punctuation">,</span>            <span class="token number">0</span> <span class="token comment">/*recovery_log_number*/</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> seq_per_batch_<span class="token punctuation">,</span>            batch_per_txn_<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        write_group<span class="token punctuation">.</span>last_sequence <span class="token operator">=</span> last_sequence<span class="token punctuation">;</span>        write_thread_<span class="token punctuation">.</span><span class="token function">LaunchParallelMemTableWriters</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>write_group<span class="token punctuation">)</span><span class="token punctuation">;</span>        in_parallel_group <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// Each parallel follower is doing each own writes. The leader should</span>        <span class="token comment">// also do its own.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">ShouldWriteToMemtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          ColumnFamilyMemTablesImpl <span class="token function">column_family_memtables</span><span class="token punctuation">(</span>              versions_<span class="token operator">-></span><span class="token function">GetColumnFamilySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>sequence <span class="token operator">==</span> current_sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>          w<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>              <span class="token operator">&amp;</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> <span class="token operator">&amp;</span>column_family_memtables<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flush_scheduler_<span class="token punctuation">,</span>              <span class="token operator">&amp;</span>trim_history_scheduler_<span class="token punctuation">,</span>              write_options<span class="token punctuation">.</span>ignore_missing_column_families<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/*log_number*/</span><span class="token punctuation">,</span>              <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/*concurrent_memtable_writes*/</span><span class="token punctuation">,</span> seq_per_batch_<span class="token punctuation">,</span>              w<span class="token punctuation">.</span>batch_cnt<span class="token punctuation">,</span> batch_per_txn_<span class="token punctuation">,</span>              write_options<span class="token punctuation">.</span>memtable_insert_hint_per_batch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，不管是并行还是非并行，都是调用了 WriteBatchInternal::InsertInto()，因为这个函数有三个重载：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> Status <span class="token function">InsertInto</span><span class="token punctuation">(</span>WriteThread<span class="token double-colon punctuation">::</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span class="token keyword">static</span> Status <span class="token function">InsertInto</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteBatch<span class="token operator">*</span> batch<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span class="token keyword">static</span> Status <span class="token function">InsertInto</span><span class="token punctuation">(</span>WriteThread<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span> writer<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在非并行的情况下，就是调用的第一个重载，Leader 传入整个 WriteGroup，我们以此作为分析入口。</p><h2 id="InsertInto"><a href="#InsertInto" class="headerlink" title="InsertInto"></a>InsertInto</h2><p>函数完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>    WriteThread<span class="token double-colon punctuation">::</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span> SequenceNumber sequence<span class="token punctuation">,</span>    ColumnFamilyMemTables<span class="token operator">*</span> memtables<span class="token punctuation">,</span> FlushScheduler<span class="token operator">*</span> flush_scheduler<span class="token punctuation">,</span>    TrimHistoryScheduler<span class="token operator">*</span> trim_history_scheduler<span class="token punctuation">,</span>    <span class="token keyword">bool</span> ignore_missing_column_families<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> recovery_log_number<span class="token punctuation">,</span> DB<span class="token operator">*</span> db<span class="token punctuation">,</span>    <span class="token keyword">bool</span> concurrent_memtable_writes<span class="token punctuation">,</span> <span class="token keyword">bool</span> seq_per_batch<span class="token punctuation">,</span> <span class="token keyword">bool</span> batch_per_txn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  MemTableInserter <span class="token function">inserter</span><span class="token punctuation">(</span>      sequence<span class="token punctuation">,</span> memtables<span class="token punctuation">,</span> flush_scheduler<span class="token punctuation">,</span> trim_history_scheduler<span class="token punctuation">,</span>      ignore_missing_column_families<span class="token punctuation">,</span> recovery_log_number<span class="token punctuation">,</span> db<span class="token punctuation">,</span>      concurrent_memtable_writes<span class="token punctuation">,</span> <span class="token keyword">nullptr</span> <span class="token comment">/* prot_info */</span><span class="token punctuation">,</span>      <span class="token keyword">nullptr</span> <span class="token comment">/*has_valid_writes*/</span><span class="token punctuation">,</span> seq_per_batch<span class="token punctuation">,</span> batch_per_txn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> w <span class="token operator">:</span> write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token operator">-></span><span class="token function">CallbackFailed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    w<span class="token operator">-></span>sequence <span class="token operator">=</span> inserter<span class="token punctuation">.</span><span class="token function">sequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>w<span class="token operator">-></span><span class="token function">ShouldWriteToMemtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// In seq_per_batch_ mode this advances the seq by one.</span>      inserter<span class="token punctuation">.</span><span class="token function">MaybeAdvanceSeq</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">SetSequence</span><span class="token punctuation">(</span>w<span class="token operator">-></span>batch<span class="token punctuation">,</span> inserter<span class="token punctuation">.</span><span class="token function">sequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inserter<span class="token punctuation">.</span><span class="token function">set_log_number_ref</span><span class="token punctuation">(</span>w<span class="token operator">-></span>log_ref<span class="token punctuation">)</span><span class="token punctuation">;</span>    inserter<span class="token punctuation">.</span><span class="token function">set_prot_info</span><span class="token punctuation">(</span>w<span class="token operator">-></span>batch<span class="token operator">-></span>prot_info_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token operator">-></span>status <span class="token operator">=</span> w<span class="token operator">-></span>batch<span class="token operator">-></span><span class="token function">Iterate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inserter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>w<span class="token operator">-></span>status<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> w<span class="token operator">-></span>status<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>seq_per_batch <span class="token operator">||</span> w<span class="token operator">-></span>batch_cnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>seq_per_batch <span class="token operator">||</span> inserter<span class="token punctuation">.</span><span class="token function">sequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> w<span class="token operator">-></span>sequence <span class="token operator">==</span> w<span class="token operator">-></span>batch_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先介绍一下 sequence 是啥。上一篇博客有讲，在写 WAL 时，RocksDB 会给 WriteGroup 分配一个 seq num，值为 last_sequence + 1，就是最新的 seq num。这里的 sequence 就是它，和 WAL 中的那个对应。</p><p>在循环体内，RocksDB 给 WriteGroup 中的每一个 Writer 以及每一个 WriteBatch 都设置了这个 sequence，应该是 WAL 恢复 memtable 时用来对应的，我现在也没搞清。接下来，会给每一个 WriteBatch 调用 WriteBatch::Iterate()，其完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">WriteBatch</span><span class="token double-colon punctuation">::</span><span class="token function">Iterate</span><span class="token punctuation">(</span>Handler<span class="token operator">*</span> handler<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>rep_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> WriteBatchInternal<span class="token double-colon punctuation">::</span>kHeader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">Corruption</span><span class="token punctuation">(</span><span class="token string">"malformed WriteBatch (too small)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">Iterate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> handler<span class="token punctuation">,</span> WriteBatchInternal<span class="token double-colon punctuation">::</span>kHeader<span class="token punctuation">,</span>                                     rep_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里解释一下 WriteBatchInternal::kHeader 是什么，先来看看注释是怎么说的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.</span><span class="token keyword">static</span> <span class="token keyword">constexpr</span> size_t kHeader <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>WriteBatch::rep_ 的结构为：8 字节的 seq num，4 字节的 record cnt，后面就是 record 数组了，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// WriteBatch::rep_ :=</span><span class="token comment">//    sequence: fixed64</span><span class="token comment">//    count: fixed32</span><span class="token comment">//    data: record[count]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此，kHeader 就是 WriteBatch 中 record[] 的首址。接下来，我们进入 WriteBatchInternal::Iterate()，其主要源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(七): 写(三)-WAL</title>
      <link href="/rocksdb-yuan-ma-xue-xi-qi-xie-san-wal/"/>
      <url>/rocksdb-yuan-ma-xue-xi-qi-xie-san-wal/</url>
      
        <content type="html"><![CDATA[<p>本篇博客将从源码层面分析 RocksDB 中 WAL 的创建与写入，且不考虑 2pc，所用代码版本为 <code>v7.7.4</code></p><hr><p>WAL 主要的功能是当 RocksDB 异常退出后，能够恢复出错前的 memtable 中的数据，因此 RocksDB 默认是每次用户写都会刷新数据到 WAL。 每次当当前 WAL 对应的 memtable 刷新到磁盘后，都会新建一个WAL，即一个 memtable 对应一个 WAL。实际上，memtable 刷新为 sstable 是通过 immutable memtable 后台完成的，所以只要 memtable 转换为 immutable memtable，就会新生成一个 memtable 和对应的 WAL。</p><p>每个 WAL 最终都会写入对应的 WAL 文件，所有的 WAL 文件都是保存在 options.wal_dir 中，为了保证数据的状态，这些文件的名字都是按照顺序的（log_number）。在 WriteGroup 写入 memtable 之前，它会先写入 WAL，具体写入的实现分为 2pc 和 !2pc，这里我们只考虑 !2pc。</p><h2 id="WAL-结构"><a href="#WAL-结构" class="headerlink" title="WAL 结构"></a>WAL 结构</h2><p>WAL 由一堆变长的 record 组成，而每个 record 是由 kBlockSize(32k) 来分组，比如某一个 record 大于kBlockSize 的话，它就会被切分为多个record（通过type来判断)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * File is broken down into variable sized records. The format of each record * is described below. *       +-----+-------------+--+----+----------+------+-- ... ----+ * File  | r0  |        r1   |P | r2 |    r3    |  r4  |           | *       +-----+-------------+--+----+----------+------+-- ... ----+ *       &lt;--- kBlockSize ------>|&lt;-- kBlockSize ------>| *  rn = variable size records *  P = Padding</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个 record 小于 kBlockSize，那么剩余的部分会填充 \0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Data is written out in kBlockSize chunks. If next record does not fit * into the space left, the leftover space will be padded with \0.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>record 的格式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Recyclable record format: * * +---------+-----------+-----------+----------------+--- ... ---+ * |CRC (4B) | Size (2B) | Type (1B) | Log number (4B)| Payload   | * +---------+-----------+-----------+----------------+--- ... ---+ * * CRC = 32bit hash computed over the record type and payload using CRC * Size = Length of the payload data * Type = Type of record *        (kZeroType, kFullType, kFirstType, kLastType, kMiddleType ) *        The type is used to group a bunch of records together to represent *        blocks that are larger than kBlockSize * Payload = Byte stream as long as specified by the payload size * Log number = 32bit log file number, so that we can distinguish between * records written by the most recent log writer vs a previous one.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个 record 记录一个 WriteBatch，放在 payload 里，其内容为 WriteBatch::rep_，是一个 string，格式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// WriteBatch::rep_ :=</span><span class="token comment">//    sequence: fixed64</span><span class="token comment">//    count: fixed32</span><span class="token comment">//    data: record[count]</span><span class="token comment">// record :=</span><span class="token comment">//    kTypeValue varstring varstring</span><span class="token comment">//    kTypeDeletion varstring</span><span class="token comment">//    kTypeSingleDeletion varstring</span><span class="token comment">//    kTypeRangeDeletion varstring varstring</span><span class="token comment">//    kTypeMerge varstring varstring</span><span class="token comment">//    kTypeColumnFamilyValue varint32 varstring varstring</span><span class="token comment">//    kTypeColumnFamilyDeletion varint32 varstring</span><span class="token comment">//    kTypeColumnFamilySingleDeletion varint32 varstring</span><span class="token comment">//    kTypeColumnFamilyRangeDeletion varint32 varstring varstring</span><span class="token comment">//    kTypeColumnFamilyMerge varint32 varstring varstring</span><span class="token comment">//    kTypeBeginPrepareXID</span><span class="token comment">//    kTypeEndPrepareXID varstring</span><span class="token comment">//    kTypeCommitXID varstring</span><span class="token comment">//    kTypeCommitXIDAndTimestamp varstring varstring</span><span class="token comment">//    kTypeRollbackXID varstring</span><span class="token comment">//    kTypeBeginPersistedPrepareXID</span><span class="token comment">//    kTypeBeginUnprepareXID</span><span class="token comment">//    kTypeWideColumnEntity varstring varstring</span><span class="token comment">//    kTypeColumnFamilyWideColumnEntity varint32 varstring varstring</span><span class="token comment">//    kTypeNoop</span><span class="token comment">// varstring :=</span><span class="token comment">//    len: varint32</span><span class="token comment">//    data: uint8[len]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，一个 WriteBatch 一个 seq num，说明在 WAL 中是以 WriteBatch 为单位的，而不是以 WriteBatch 里的具体操作为单位的。</p><h2 id="WAL-创建"><a href="#WAL-创建" class="headerlink" title="WAL 创建"></a>WAL 创建</h2><p>RocksDB 在两种情况下会创建 WAL：</p><ul><li>新的 DB 被打开时会创建一个 WAL。</li><li>当一个 CF 的 memtable 被刷新之后会创建一个 WAL。</li></ul><p>第一种情况，创建 WAL 的入口被封装进了 DB::Open() 函数中，核心源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token keyword">const</span> DBOptions<span class="token operator">&amp;</span> db_options<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> dbname<span class="token punctuation">,</span>                    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>ColumnFamilyDescriptor<span class="token operator">></span><span class="token operator">&amp;</span> column_families<span class="token punctuation">,</span>                    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>ColumnFamilyHandle<span class="token operator">*</span><span class="token operator">></span><span class="token operator">*</span> handles<span class="token punctuation">,</span> DB<span class="token operator">*</span><span class="token operator">*</span> dbptr<span class="token punctuation">,</span>                    <span class="token keyword">const</span> <span class="token keyword">bool</span> seq_per_batch<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">bool</span> batch_per_txn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//......................................................................</span>  s <span class="token operator">=</span> impl<span class="token operator">-></span><span class="token function">Recover</span><span class="token punctuation">(</span>column_families<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>recovered_seq<span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>recovery_ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint64_t</span> new_log_number <span class="token operator">=</span> impl<span class="token operator">-></span>versions_<span class="token operator">-></span><span class="token function">NewFileNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//.............................................</span>    s <span class="token operator">=</span> impl<span class="token operator">-></span><span class="token function">CreateWAL</span><span class="token punctuation">(</span>new_log_number<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/*recycle_log_number*/</span><span class="token punctuation">,</span>                        preallocate_block_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_log<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token comment">//................................................</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种情况，当  CF 的 memtable 要 flush 时，通过 DBImpl::Flush() 调用自身的 FlushMemTable() 函数，在flush memtable 的过程中进行新的 WAL 的创建。 这里当触发 CF 的 flush 时，需要将内存中 memtable 标记为imutable memetable，然后在后台转换为 sstable，同时会生成新的 memtable。这个时候 WAL 记录的是旧的 memtable 的请求，为了数据的隔离性，且 WAL 不会过大，每个 WAL 文件只和一个 memtable 绑定，所以切换memtable 的过程中会创建新的wal文件，用来接收新的请求。</p><p>函数调用链如下，一直到 DBImpl::SwitchMemtable()。该函数作用很简单，生成新的 memtable 并把旧的 memtable 变成 imutable memetable。同时，该函数也封装了创建 WAL 的入口函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token keyword">const</span> FlushOptions<span class="token operator">&amp;</span> flush_options<span class="token punctuation">,</span>                     ColumnFamilyHandle<span class="token operator">*</span> column_family<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 主要就是flush memtable</span>    s <span class="token operator">=</span> <span class="token function">FlushMemTable</span><span class="token punctuation">(</span>cfh<span class="token operator">-></span><span class="token function">cfd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flush_options<span class="token punctuation">,</span> FlushReason<span class="token double-colon punctuation">::</span>kManualFlush<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">FlushMemTable</span><span class="token punctuation">(</span>ColumnFamilyData<span class="token operator">*</span> cfd<span class="token punctuation">,</span>                             <span class="token keyword">const</span> FlushOptions<span class="token operator">&amp;</span> flush_options<span class="token punctuation">,</span>                             FlushReason flush_reason<span class="token punctuation">,</span> <span class="token keyword">bool</span> writes_stopped<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 切换memtable</span>    s <span class="token operator">=</span> <span class="token function">SwitchMemtable</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">SwitchMemtable</span><span class="token punctuation">(</span>ColumnFamilyData<span class="token operator">*</span> cfd<span class="token punctuation">,</span> WriteContext<span class="token operator">*</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//..................................................</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>creating_new_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO: Write buffer size passed in should be max of all CF's instead</span>    <span class="token comment">// of mutable_cf_options.write_buffer_size.</span>    io_s <span class="token operator">=</span> <span class="token function">CreateWAL</span><span class="token punctuation">(</span>new_log_number<span class="token punctuation">,</span> recycle_log_number<span class="token punctuation">,</span> preallocate_block_size<span class="token punctuation">,</span>                     <span class="token operator">&amp;</span>new_log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      s <span class="token operator">=</span> io_s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token comment">//...............................................</span>  <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，无论是哪种情况，在调用 CreateWAL() 时均会传入一个 new_log_number，这个值就是对应 WAL 的文件名前缀。CreateWAL() 的主要源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">IOStatus <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">CreateWAL</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> log_file_num<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> recycle_log_number<span class="token punctuation">,</span>                           size_t preallocate_block_size<span class="token punctuation">,</span>                           log<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span><span class="token operator">*</span> new_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  IOStatus io_s<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>FSWritableFile<span class="token operator">></span> lfile<span class="token punctuation">;</span>  DBOptions db_options <span class="token operator">=</span>      <span class="token function">BuildDBOptions</span><span class="token punctuation">(</span>immutable_db_options_<span class="token punctuation">,</span> mutable_db_options_<span class="token punctuation">)</span><span class="token punctuation">;</span>  FileOptions opt_file_options <span class="token operator">=</span>      fs_<span class="token operator">-></span><span class="token function">OptimizeForLogWrite</span><span class="token punctuation">(</span>file_options_<span class="token punctuation">,</span> db_options<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>string wal_dir <span class="token operator">=</span> immutable_db_options_<span class="token punctuation">.</span><span class="token function">GetWalDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>string log_fname <span class="token operator">=</span> <span class="token function">LogFileName</span><span class="token punctuation">(</span>wal_dir<span class="token punctuation">,</span> log_file_num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>recycle_log_number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ROCKS_LOG_INFO</span><span class="token punctuation">(</span>immutable_db_options_<span class="token punctuation">.</span>info_log<span class="token punctuation">,</span>                   <span class="token string">"reusing log %"</span> PRIu64 <span class="token string">" from recycle list\n"</span><span class="token punctuation">,</span>                   recycle_log_number<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string old_log_fname <span class="token operator">=</span> <span class="token function">LogFileName</span><span class="token punctuation">(</span>wal_dir<span class="token punctuation">,</span> recycle_log_number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TEST_SYNC_POINT</span><span class="token punctuation">(</span><span class="token string">"DBImpl::CreateWAL:BeforeReuseWritableFile1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TEST_SYNC_POINT</span><span class="token punctuation">(</span><span class="token string">"DBImpl::CreateWAL:BeforeReuseWritableFile2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    io_s <span class="token operator">=</span> fs_<span class="token operator">-></span><span class="token function">ReuseWritableFile</span><span class="token punctuation">(</span>log_fname<span class="token punctuation">,</span> old_log_fname<span class="token punctuation">,</span> opt_file_options<span class="token punctuation">,</span>                                  <span class="token operator">&amp;</span>lfile<span class="token punctuation">,</span> <span class="token comment">/*dbg=*/</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    io_s <span class="token operator">=</span> <span class="token function">NewWritableFile</span><span class="token punctuation">(</span>fs_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> log_fname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lfile<span class="token punctuation">,</span> opt_file_options<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，它会通过 wal_dir 和 log_file_num 生成一个文件名，然后判断是否配置了 recycle_log_number。如果否，那么就会调用 NewWritableFile() 重新创建一个 WAL。如果是，那就调用 ReuseWritableFile() 复用原来的 WAL，但要将其名字改为新的 log_fname。</p><p>会过头来看 log_file_num 的生成，其很简单，就是自增而已，由 NewFileNumber() 实现。因此一般来说 WAL 文件的名称都是类似 0000001.LOG 这样子。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Allocate and return a new file number</span><span class="token keyword">uint64_t</span> <span class="token function">NewFileNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> next_file_number_<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="WAL-写入"><a href="#WAL-写入" class="headerlink" title="WAL 写入"></a>WAL 写入</h2><p>接下来进入本篇博客的重点，WAL 的写入。</p><p>在上一篇博客中分析到，DBImpl::WriteImpl() 中，WriteGroup 的 Leader 会在写 memtable 之前把整个 WriteGroup 写入 WAL 中，源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>two_write_queues_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>write_options<span class="token punctuation">.</span>disableWAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>log_context<span class="token punctuation">.</span>log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        LogFileNumberSize<span class="token operator">&amp;</span> log_file_number_size <span class="token operator">=</span>            <span class="token operator">*</span><span class="token punctuation">(</span>log_context<span class="token punctuation">.</span>log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PERF_TIMER_GUARD</span><span class="token punctuation">(</span>write_wal_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        io_s <span class="token operator">=</span>            <span class="token function">WriteToWAL</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> log_context<span class="token punctuation">.</span>writer<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span>                       log_context<span class="token punctuation">.</span>need_log_sync<span class="token punctuation">,</span> log_context<span class="token punctuation">.</span>need_log_dir_sync<span class="token punctuation">,</span>                       last_sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>write_options<span class="token punctuation">.</span>disableWAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">PERF_TIMER_GUARD</span><span class="token punctuation">(</span>write_wal_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// LastAllocatedSequence is increased inside WriteToWAL under</span>        <span class="token comment">// wal_write_mutex_ to ensure ordered events in WAL</span>        io_s <span class="token operator">=</span> <span class="token function">ConcurrentWriteToWAL</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span> <span class="token operator">&amp;</span>last_sequence<span class="token punctuation">,</span>                                    seq_inc<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Otherwise we inc seq number for memtable writes</span>        last_sequence <span class="token operator">=</span> versions_<span class="token operator">-></span><span class="token function">FetchAddLastAllocatedSequence</span><span class="token punctuation">(</span>seq_inc<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们只考虑 !2pc 的过程，RocksDB 会调用 DBImpl::WriteToWAL()：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">WriteToWAL</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> log_context<span class="token punctuation">.</span>writer<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span>           log_context<span class="token punctuation">.</span>need_log_sync<span class="token punctuation">,</span> log_context<span class="token punctuation">.</span>need_log_dir_sync<span class="token punctuation">,</span>           last_sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，write_group 就是 Leader 的 WriteGroup，而 last_sequence + 1 是什么？我们把代码往前翻，会发现 last_sequence 就是当前 VersionSet 的最后一个 seq num，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>two_write_queues_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Assign it after ::PreprocessWrite since the sequence might advance</span>      <span class="token comment">// inside it by WriteRecoverableState</span>      last_sequence <span class="token operator">=</span> versions_<span class="token operator">-></span><span class="token function">LastSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，last_sequence + 1 就是给这个 WriteGroup 分配一个新的 seq num。WriteToWAL() 的流程主要分为四大步：MergeBatch、SetSequence、WriteToWAL（针对 WriteBatch）和 Sync。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">IOStatus <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">WriteToWAL</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteThread<span class="token double-colon punctuation">::</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span>                            log<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span> log_writer<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span><span class="token operator">*</span> log_used<span class="token punctuation">,</span>                            <span class="token keyword">bool</span> need_log_sync<span class="token punctuation">,</span> <span class="token keyword">bool</span> need_log_dir_sync<span class="token punctuation">,</span>                            SequenceNumber sequence<span class="token punctuation">,</span>                            LogFileNumberSize<span class="token operator">&amp;</span> log_file_number_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...  </span>  WriteBatch<span class="token operator">*</span> merged_batch<span class="token punctuation">;</span>  io_s <span class="token operator">=</span> <span class="token function">status_to_io_status</span><span class="token punctuation">(</span><span class="token function">MergeBatch</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp_batch_<span class="token punctuation">,</span> <span class="token operator">&amp;</span>merged_batch<span class="token punctuation">,</span>                                        <span class="token operator">&amp;</span>write_with_wal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>to_be_cached_state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span>  <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">SetSequence</span><span class="token punctuation">(</span>merged_batch<span class="token punctuation">,</span> sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span>  io_s <span class="token operator">=</span> <span class="token function">WriteToWAL</span><span class="token punctuation">(</span><span class="token operator">*</span>merged_batch<span class="token punctuation">,</span> log_writer<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span> <span class="token operator">&amp;</span>log_size<span class="token punctuation">,</span>                    write_group<span class="token punctuation">.</span>leader<span class="token operator">-></span>rate_limiter_priority<span class="token punctuation">,</span>                    log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>io_s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> need_log_sync<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> log <span class="token operator">:</span> logs_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      io_s <span class="token operator">=</span> log<span class="token punctuation">.</span>writer<span class="token operator">-></span><span class="token function">file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Sync</span><span class="token punctuation">(</span>immutable_db_options_<span class="token punctuation">.</span>use_fsync<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>io_s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MergeBatch"><a href="#MergeBatch" class="headerlink" title="MergeBatch"></a>MergeBatch</h3><p>RocksDB 在写入 WAL 之前，会把 WriteGroup 合并为一个 WriteBatch，名为 merged_batch。注意，这个 merge 不是 LSM 中的 merge，这里仅仅做合并，不做去重。完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">MergeBatch</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteThread<span class="token double-colon punctuation">::</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span>                          WriteBatch<span class="token operator">*</span> tmp_batch<span class="token punctuation">,</span> WriteBatch<span class="token operator">*</span><span class="token operator">*</span> merged_batch<span class="token punctuation">,</span>                          size_t<span class="token operator">*</span> write_with_wal<span class="token punctuation">,</span>                          WriteBatch<span class="token operator">*</span><span class="token operator">*</span> to_be_cached_state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>write_with_wal <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>tmp_batch <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>to_be_cached_state <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">*</span>write_with_wal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">*</span> leader <span class="token operator">=</span> write_group<span class="token punctuation">.</span>leader<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>leader<span class="token operator">-></span>disable_wal<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Same holds for all in the batch group</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>write_group<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>leader<span class="token operator">-></span><span class="token function">CallbackFailed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      leader<span class="token operator">-></span>batch<span class="token operator">-></span><span class="token function">GetWalTerminationPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is_cleared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// we simply write the first WriteBatch to WAL if the group only</span>    <span class="token comment">// contains one batch, that batch should be written to the WAL,</span>    <span class="token comment">// and the batch is not wanting to be truncated</span>    <span class="token operator">*</span>merged_batch <span class="token operator">=</span> leader<span class="token operator">-></span>batch<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">IsLatestPersistentState</span><span class="token punctuation">(</span><span class="token operator">*</span>merged_batch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token operator">*</span>to_be_cached_state <span class="token operator">=</span> <span class="token operator">*</span>merged_batch<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>write_with_wal <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// WAL needs all of the batches flattened into a single batch.</span>    <span class="token comment">// We could avoid copying here with an iov-like AddRecord</span>    <span class="token comment">// interface</span>    <span class="token operator">*</span>merged_batch <span class="token operator">=</span> tmp_batch<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> writer <span class="token operator">:</span> write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>writer<span class="token operator">-></span><span class="token function">CallbackFailed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Status s <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token operator">*</span>merged_batch<span class="token punctuation">,</span> writer<span class="token operator">-></span>batch<span class="token punctuation">,</span>                                              <span class="token comment">/*WAL_only*/</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          tmp_batch<span class="token operator">-></span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">IsLatestPersistentState</span><span class="token punctuation">(</span>writer<span class="token operator">-></span>batch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// We only need to cache the last of such write batch</span>          <span class="token operator">*</span>to_be_cached_state <span class="token operator">=</span> writer<span class="token operator">-></span>batch<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token punctuation">(</span><span class="token operator">*</span>write_with_wal<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// return merged_batch;</span>  <span class="token keyword">return</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其逻辑很简单，就是遍历一遍 WriteGroup，把其中的所有 WriteBatch 都 Append 进 merged_batch 中。</p><h3 id="SetSequence"><a href="#SetSequence" class="headerlink" title="SetSequence"></a>SetSequence</h3><p>到目前为止，写操作都没有被分配 seq num。RocksDB 生成完 merged_batch 之后，会给其分配一个 seq num，而这个 seq 就是 last_sequence + 1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteToWAL</span>  <span class="token comment">// sequence == last_sequence + 1</span>  <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">SetSequence</span><span class="token punctuation">(</span>merged_batch<span class="token punctuation">,</span> sequence<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>SetSequence() 源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">SetSequence</span><span class="token punctuation">(</span>WriteBatch<span class="token operator">*</span> b<span class="token punctuation">,</span> SequenceNumber seq<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">EncodeFixed64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>rep_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在前文中我们介绍了 WriteBatch::rep_ 的首个元素就是 seq num，这里该函数将其赋值为最新的 seq num。</p><h3 id="WriteToWAL（针对-wb）"><a href="#WriteToWAL（针对-wb）" class="headerlink" title="WriteToWAL（针对 wb）"></a>WriteToWAL（针对 wb）</h3><p>WriteToWAL() 一共有两个重载，一个针对 WriteGroup，另一个针对 WriteBatch：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">IOStatus <span class="token function">WriteToWAL</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteBatch<span class="token operator">&amp;</span> merged_batch<span class="token punctuation">,</span> log<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span> log_writer<span class="token punctuation">,</span>                    <span class="token keyword">uint64_t</span><span class="token operator">*</span> log_used<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span><span class="token operator">*</span> log_size<span class="token punctuation">,</span>                    Env<span class="token double-colon punctuation">::</span>IOPriority rate_limiter_priority<span class="token punctuation">,</span>                    LogFileNumberSize<span class="token operator">&amp;</span> log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>IOStatus <span class="token function">WriteToWAL</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteThread<span class="token double-colon punctuation">::</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span>                    log<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span> log_writer<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span><span class="token operator">*</span> log_used<span class="token punctuation">,</span>                    <span class="token keyword">bool</span> need_log_sync<span class="token punctuation">,</span> <span class="token keyword">bool</span> need_log_dir_sync<span class="token punctuation">,</span>                    SequenceNumber sequence<span class="token punctuation">,</span>                    LogFileNumberSize<span class="token operator">&amp;</span> log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WAL 写入的入口为第二个重载，传入 WriteGroup，但最后还要要调用第一个重载，传入 merged_batch：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteToWAL</span>  io_s <span class="token operator">=</span> <span class="token function">WriteToWAL</span><span class="token punctuation">(</span><span class="token operator">*</span>merged_batch<span class="token punctuation">,</span> log_writer<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span> <span class="token operator">&amp;</span>log_size<span class="token punctuation">,</span>                    write_group<span class="token punctuation">.</span>leader<span class="token operator">-></span>rate_limiter_priority<span class="token punctuation">,</span>                    log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该重载的完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">IOStatus <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">WriteToWAL</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteBatch<span class="token operator">&amp;</span> merged_batch<span class="token punctuation">,</span>                            log<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span> log_writer<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span><span class="token operator">*</span> log_used<span class="token punctuation">,</span>                            <span class="token keyword">uint64_t</span><span class="token operator">*</span> log_size<span class="token punctuation">,</span>                            Env<span class="token double-colon punctuation">::</span>IOPriority rate_limiter_priority<span class="token punctuation">,</span>                            LogFileNumberSize<span class="token operator">&amp;</span> log_file_number_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>log_size <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Slice log_entry <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">Contents</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>merged_batch<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"DBImpl::WriteToWAL:log_entry"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>log_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> s <span class="token operator">=</span> merged_batch<span class="token punctuation">.</span><span class="token function">VerifyChecksum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">status_to_io_status</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span>log_size <span class="token operator">=</span> log_entry<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// When two_write_queues_ WriteToWAL has to be protected from concurretn calls</span>  <span class="token comment">// from the two queues anyway and log_write_mutex_ is already held. Otherwise</span>  <span class="token comment">// if manual_wal_flush_ is enabled we need to protect log_writer->AddRecord</span>  <span class="token comment">// from possible concurrent calls via the FlushWAL by the application.</span>  <span class="token keyword">const</span> <span class="token keyword">bool</span> needs_locking <span class="token operator">=</span> manual_wal_flush_ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>two_write_queues_<span class="token punctuation">;</span>  <span class="token comment">// Due to performance cocerns of missed branch prediction penalize the new</span>  <span class="token comment">// manual_wal_flush_ feature (by UNLIKELY) instead of the more common case</span>  <span class="token comment">// when we do not need any locking.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">UNLIKELY</span><span class="token punctuation">(</span>needs_locking<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log_write_mutex_<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  IOStatus io_s <span class="token operator">=</span> log_writer<span class="token operator">-></span><span class="token function">AddRecord</span><span class="token punctuation">(</span>log_entry<span class="token punctuation">,</span> rate_limiter_priority<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">UNLIKELY</span><span class="token punctuation">(</span>needs_locking<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log_write_mutex_<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>log_used <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>log_used <span class="token operator">=</span> logfile_number_<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  total_log_size_ <span class="token operator">+=</span> log_entry<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log_file_number_size<span class="token punctuation">.</span><span class="token function">AddSize</span><span class="token punctuation">(</span><span class="token operator">*</span>log_size<span class="token punctuation">)</span><span class="token punctuation">;</span>  log_empty_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> io_s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，它会将 merged_batch 包装成一个 log_entry，作为 WAL 中的 record。接着，调用 Writer::AddRecord() 来将改 record 写入到 WAL 中，并最终写入 WAL 文件。整个写入过程的调用链为 <code>AddRecord</code> –&gt; <code>Flush</code> –&gt;<code>WriteBuffered</code> –&gt; <code>PosixWritableFile::Append</code> –&gt; <code>PosixWrite</code> –&gt; <code>write</code> 。前面就是一些字符串的格式处理，一直到后面调用 Linux 的 write 系统调用，才真正将数据写入 WAL 文件。</p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>这里要先了解一下 Linux 的 I/O 机制。</p><p>Linux 在内核设有缓冲区高速缓存或页面高速缓存，大多数磁盘 I/O 都通过缓冲区进行。当我们向文件写数据时，内核通常先将数据复制到一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待写满或者内核需要重用该缓冲区以便存放其他数据时，才会将该缓冲区排入输出队列，然后等它到达队首时，才进行实际的I/O 操作。这就是被称为<strong>延迟写</strong>的输出方式。延迟写减少了磁盘读次数，但是却减低了文件内容跟新的速度。当系统发生故障时，延迟写的方式可能造成文件跟新丢失。</p><p>为了应对此种情况，Linux 提供了三个函数来保证实际文件系统与缓冲区中内容的一致：</p><ul><li><strong>fdatasyncsync</strong>：该函数只是将所有修改过的块缓冲区排入写队列，然后就返回，他并不等待实际写磁盘操作结束。</li><li><strong>fsync</strong>：只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。</li><li><strong>fdatasync</strong>：类似于 fsync，但是它只影响文件的数据部分。而除数据外，fsync 还会同步更新文件的属性。</li></ul><p>因此，上一步的 WriteToWAL() 并不一定真正写入了文件系统，期间可能出现故障导致写缓冲区内容的丢失。保证写内容的顺利落盘，RocksDB 在 WriteToWAL() 之后使用了刷盘操作，由 need_log_sync 决定是否使用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteToWAL</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>io_s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> need_log_sync<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> log <span class="token operator">:</span> logs_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      io_s <span class="token operator">=</span> log<span class="token punctuation">.</span>writer<span class="token operator">-></span><span class="token function">file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Sync</span><span class="token punctuation">(</span>immutable_db_options_<span class="token punctuation">.</span>use_fsync<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>io_s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>log.writer-&gt;file()-&gt;Sync() 会进一步调用 WritableFileWriter::SyncInternal() ，该函数核心源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">IOStatus <span class="token class-name">WritableFileWriter</span><span class="token double-colon punctuation">::</span><span class="token function">SyncInternal</span><span class="token punctuation">(</span><span class="token keyword">bool</span> use_fsync<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>use_fsync<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> writable_file_<span class="token operator">-></span><span class="token function">Fsync</span><span class="token punctuation">(</span>io_options<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> writable_file_<span class="token operator">-></span><span class="token function">Sync</span><span class="token punctuation">(</span>io_options<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续往下追踪，发现 Fsync() 最终调用了 fsync()，而 Sync() 最终调用了 fdatasync()，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">IOStatus <span class="token class-name">PosixMmapFile</span><span class="token double-colon punctuation">::</span><span class="token function">Sync</span><span class="token punctuation">(</span><span class="token keyword">const</span> IOOptions<span class="token operator">&amp;</span> <span class="token comment">/*opts*/</span><span class="token punctuation">,</span>                             IODebugContext<span class="token operator">*</span> <span class="token comment">/*dbg*/</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_FULLFSYNC</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd_<span class="token punctuation">,</span> F_FULLFSYNC<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">IOError</span><span class="token punctuation">(</span><span class="token string">"while fcntl(F_FULLSYNC) mmapped file"</span><span class="token punctuation">,</span> filename_<span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">// HAVE_FULLFSYNC</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fdatasync</span><span class="token punctuation">(</span>fd_<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">IOError</span><span class="token punctuation">(</span><span class="token string">"While fdatasync mmapped file"</span><span class="token punctuation">,</span> filename_<span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">// HAVE_FULLFSYNC</span></span>  <span class="token keyword">return</span> <span class="token function">Msync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Flush data as well as metadata to stable storage. */</span>IOStatus <span class="token class-name">PosixMmapFile</span><span class="token double-colon punctuation">::</span><span class="token function">Fsync</span><span class="token punctuation">(</span><span class="token keyword">const</span> IOOptions<span class="token operator">&amp;</span> <span class="token comment">/*opts*/</span><span class="token punctuation">,</span>                              IODebugContext<span class="token operator">*</span> <span class="token comment">/*dbg*/</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_FULLFSYNC</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd_<span class="token punctuation">,</span> F_FULLFSYNC<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">IOError</span><span class="token punctuation">(</span><span class="token string">"While fcntl(F_FULLSYNC) on mmaped file"</span><span class="token punctuation">,</span> filename_<span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">// HAVE_FULLFSYNC</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span>fd_<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">IOError</span><span class="token punctuation">(</span><span class="token string">"While fsync mmaped file"</span><span class="token punctuation">,</span> filename_<span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">// HAVE_FULLFSYNC</span></span>  <span class="token keyword">return</span> <span class="token function">Msync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，Leader 向 WAL 中写入 WriteGroup 的过程就结束了，相关函数调用图如下：</p><p><img src="https://s1.ax1x.com/2022/10/26/xWy9aV.png" alt="WriteToWAL调用链"></p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(六): 写(二)-WriteGroup</title>
      <link href="/rocksdb-yuan-ma-xue-xi-liu-xie-er-writegroup/"/>
      <url>/rocksdb-yuan-ma-xue-xi-liu-xie-er-writegroup/</url>
      
        <content type="html"><![CDATA[<p>本篇博客将从源码层面分析 RocksDB 写操作中与 WriteGroup 有关的内容，且不考虑 pipelined_write 与 2pc，所用代码版本为 <code>v7.7.4</code></p><hr><p>WAL 主要的功能是当 RocksDB 异常退出后，能够恢复出错前的 memtable 中的数据，因此 RocksDB 默认是每次用户写都会刷新数据到 WAL。每次当当前 WAL 对应的 memtable 刷新到磁盘之后，都会新建一个WAL，即一个 memtable 对应一个 WAL。每一个 WAL 最终都会写入对应的 WAL 文件中，这些文件保存在 options.wal_dir 中，所有 WAL 文件都是按照 log_number 来起的。</p><h2 id="WriteImpl"><a href="#WriteImpl" class="headerlink" title="WriteImpl"></a>WriteImpl</h2><p>我们知道，每一个写线程都对应一个 WriteBatch，其写入会交给 DBImpl::WriteImpl() 来完成，而 WriteGroup 的构建与消除，也是在该函数内部完成，因此本文以该函数为分析入口。</p><p>进入函数内部，跳过配置检查、unordered_write、pipelined_write 等分支，会看见封装 Writer 的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>WriteThread<span class="token double-colon punctuation">::</span>Writer <span class="token function">w</span><span class="token punctuation">(</span>write_options<span class="token punctuation">,</span> my_batch<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> log_ref<span class="token punctuation">,</span>                      disable_memtable<span class="token punctuation">,</span> batch_cnt<span class="token punctuation">,</span> pre_release_callback<span class="token punctuation">,</span>                      post_memtable_callback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Writer 内部的结构在上一篇博客中已经讨论过了，核心为 WriteBatch* 、link_older 与 link_newer，这里就不再赘述了。封装完 Writer 后，会将其加入 DB 对象中的 Writer 链表，上一篇博客我们把它称 WriteLink，本篇依旧如此。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>write_thread_<span class="token punctuation">.</span><span class="token function">JoinBatchGroup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="JoinBatchGroup"><a href="#JoinBatchGroup" class="headerlink" title="JoinBatchGroup"></a>JoinBatchGroup</h3><p>该函数完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">WriteThread</span><span class="token double-colon punctuation">::</span><span class="token function">JoinBatchGroup</span><span class="token punctuation">(</span>Writer<span class="token operator">*</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::JoinBatchGroup:Start"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token operator">-></span>batch <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> linked_as_leader <span class="token operator">=</span> <span class="token function">LinkOne</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>newest_writer_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>linked_as_leader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SetState</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> STATE_GROUP_LEADER<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::JoinBatchGroup:Wait"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::JoinBatchGroup:Wait2"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>linked_as_leader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Wait util:     * 1) An existing leader pick us as the new leader when it finishes     * 2) An existing leader pick us as its follewer and     * 2.1) finishes the memtable writes on our behalf     * 2.2) Or tell us to finish the memtable writes in pralallel     * 3) (pipelined write) An existing leader pick us as its follower and     *    finish book-keeping and WAL write for us, enqueue us as pending     *    memtable writer, and     * 3.1) we become memtable writer group leader, or     * 3.2) an existing memtable writer group leader tell us to finish memtable     *      writes in parallel.     */</span>    <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::JoinBatchGroup:BeganWaiting"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">AwaitState</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> STATE_GROUP_LEADER <span class="token operator">|</span> STATE_MEMTABLE_WRITER_LEADER <span class="token operator">|</span>                      STATE_PARALLEL_MEMTABLE_WRITER <span class="token operator">|</span> STATE_COMPLETED<span class="token punctuation">,</span>               <span class="token operator">&amp;</span>jbg_ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::JoinBatchGroup:DoneWaiting"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// ...</span><span class="token keyword">bool</span> <span class="token class-name">WriteThread</span><span class="token double-colon punctuation">::</span><span class="token function">LinkOne</span><span class="token punctuation">(</span>Writer<span class="token operator">*</span> w<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>Writer<span class="token operator">*</span><span class="token operator">></span><span class="token operator">*</span> newest_writer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>newest_writer <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token operator">-></span>state <span class="token operator">==</span> STATE_INIT<span class="token punctuation">)</span><span class="token punctuation">;</span>  Writer<span class="token operator">*</span> writers <span class="token operator">=</span> newest_writer<span class="token operator">-></span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// If write stall in effect, and w->no_slowdown is not true,</span>    <span class="token comment">// block here until stall is cleared. If its true, then return</span>    <span class="token comment">// immediately</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>writers <span class="token operator">==</span> <span class="token operator">&amp;</span>write_stall_dummy_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token operator">-></span>no_slowdown<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        w<span class="token operator">-></span>status <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">Incomplete</span><span class="token punctuation">(</span><span class="token string">"Write stall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SetState</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> STATE_COMPLETED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// Since no_slowdown is false, wait here to be notified of the write</span>      <span class="token comment">// stall clearing</span>      <span class="token punctuation">&#123;</span>        MutexLock <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stall_mu_<span class="token punctuation">)</span><span class="token punctuation">;</span>        writers <span class="token operator">=</span> newest_writer<span class="token operator">-></span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>writers <span class="token operator">==</span> <span class="token operator">&amp;</span>write_stall_dummy_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::WriteStall::Wait"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>          stall_cv_<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Load newest_writers_ again since it may have changed</span>          writers <span class="token operator">=</span> newest_writer<span class="token operator">-></span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    w<span class="token operator">-></span>link_older <span class="token operator">=</span> writers<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newest_writer<span class="token operator">-></span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>writers<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>writers <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其逻辑很简单，先取出 newest_writer_ ，如果其 stall 了，那么视配置来决定是直接返回还是等待。之后，将当前 Writer 插入 WriteLink，实际就是把 link_order 指向 newest_writer，然后把自己变为新的 newest_writer_ 。如果原来的 newest_writer_ 为空，说明当前 Writer 为头一个，则返回 true 表示自己是 Leader，反之返回 false。</p><p>插入 WriteLink 后，如果是 Leader，那就把 state 设为 STATE_GROUP_LEADER。如果不是 Leader，就会调用 AwaitState() 阻塞自己，等待 Leader 给自己设置状态（唤醒）。不考虑 pipelined 的情况下，被唤醒的条件有两个，如注释所述：</p><ul><li>自己不在 WriteGroup 中，被 WriteGroup 的 Leader 选为新的 Leader。</li><li>在 WriteGroup 中，被 Leader 唤醒。</li></ul><p>注意到，JoinBatchGroup() 会阻塞非 Leader，因此接下来的代码，只有 Leader 或者被 Leader 唤醒的 Writer 可以执行，我们先以非 Leader 的视角来看。</p><h3 id="非-Leader-视角"><a href="#非-Leader-视角" class="headerlink" title="非 Leader 视角"></a>非 Leader 视角</h3><p>JoinBatchGroup() 执行完毕后，RocksDB 会对该 Writer 的 state 做两个判断，一个是 STATE_PARALLEL_MEMTABLE_WRITER，一个是 STATE_COMPLETED，我们一个一个分析。</p><h4 id="STATE-PARALLEL-MEMTABLE-WRITER"><a href="#STATE-PARALLEL-MEMTABLE-WRITER" class="headerlink" title="STATE_PARALLEL_MEMTABLE_WRITER"></a>STATE_PARALLEL_MEMTABLE_WRITER</h4><p>首先是 STATE_PARALLEL_MEMTABLE_WRITER，源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span><span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span>state <span class="token operator">==</span> WriteThread<span class="token double-colon punctuation">::</span>STATE_PARALLEL_MEMTABLE_WRITER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// we are a non-leader in a parallel group</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">ShouldWriteToMemtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">PERF_TIMER_STOP</span><span class="token punctuation">(</span>write_pre_and_post_process_time<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">PERF_TIMER_GUARD</span><span class="token punctuation">(</span>write_memtable_time<span class="token punctuation">)</span><span class="token punctuation">;</span>      ColumnFamilyMemTablesImpl <span class="token function">column_family_memtables</span><span class="token punctuation">(</span>          versions_<span class="token operator">-></span><span class="token function">GetColumnFamilySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      w<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>          <span class="token operator">&amp;</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> <span class="token operator">&amp;</span>column_family_memtables<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flush_scheduler_<span class="token punctuation">,</span>          <span class="token operator">&amp;</span>trim_history_scheduler_<span class="token punctuation">,</span>          write_options<span class="token punctuation">.</span>ignore_missing_column_families<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/*log_number*/</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span>          <span class="token boolean">true</span> <span class="token comment">/*concurrent_memtable_writes*/</span><span class="token punctuation">,</span> seq_per_batch_<span class="token punctuation">,</span> w<span class="token punctuation">.</span>batch_cnt<span class="token punctuation">,</span>          batch_per_txn_<span class="token punctuation">,</span> write_options<span class="token punctuation">.</span>memtable_insert_hint_per_batch<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">PERF_TIMER_START</span><span class="token punctuation">(</span>write_pre_and_post_process_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>write_thread_<span class="token punctuation">.</span><span class="token function">CompleteParallelMemTableWriter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// we're responsible for exit batch group</span>      <span class="token comment">// TODO(myabandeh): propagate status to write_group</span>      <span class="token keyword">auto</span> last_sequence <span class="token operator">=</span> w<span class="token punctuation">.</span>write_group<span class="token operator">-></span>last_sequence<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">*</span> tmp_w <span class="token operator">:</span> <span class="token operator">*</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>write_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>tmp_w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_w<span class="token operator">-></span>post_memtable_callback<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          Status tmp_s <span class="token operator">=</span>              <span class="token punctuation">(</span><span class="token operator">*</span>tmp_w<span class="token operator">-></span>post_memtable_callback<span class="token punctuation">)</span><span class="token punctuation">(</span>last_sequence<span class="token punctuation">,</span> disable_memtable<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// TODO: propagate the execution status of post_memtable_callback to</span>          <span class="token comment">// caller.</span>          <span class="token function">assert</span><span class="token punctuation">(</span>tmp_s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      versions_<span class="token operator">-></span><span class="token function">SetLastSequence</span><span class="token punctuation">(</span>last_sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">MemTableInsertStatusCheck</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>      write_thread_<span class="token punctuation">.</span><span class="token function">ExitAsBatchGroupFollower</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>state <span class="token operator">==</span> WriteThread<span class="token double-colon punctuation">::</span>STATE_COMPLETED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// STATE_COMPLETED conditional below handles exit</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>STATE_PARALLEL_MEMTABLE_WRITER 的意思是，自己在 WriteGroup 中但不是 Leader，且此时已经被 Leader 唤醒，且写入配置为 parallel。因此，该段代码的意思为，在 parallel 的情况下，Leader 把自己的 Follower 唤醒，要求其并行的将自己写入 memtable 中，写入的实现位于 WriteBatchInternal::InsertInto() 中。代码的后半部分用了一个 CompleteParallelMemTableWriter() 判断，先来看看它的注释。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Reports the completion of w's batch to the parallel group leader, and</span><span class="token comment">// waits for the rest of the parallel batch to complete.  Returns true</span><span class="token comment">// if this thread is the last to complete, and hence should advance</span><span class="token comment">// the sequence number and then call EarlyExitParallelGroup, false if</span><span class="token comment">// someone else has already taken responsibility for that.</span><span class="token keyword">bool</span> <span class="token function">CompleteParallelMemTableWriter</span><span class="token punctuation">(</span>Writer<span class="token operator">*</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点为，如果当前 Writer 是并行写入中最后一个完成的 Writer，那么返回 true。因此上述代码块的第二个作用为，如果当前 Writer 是最后一个完成的，那么尤其负责 WriteGroup 的善后工作，包括更新全局 seq num 以及执行 ExitAsBatchGroupFollower()，ExitAsBatchGroupFollower() 作用主要是辅助选出新的 WriteGroup，在上一篇博客中提到了，在后文我们会细说。</p><p>当然，这一部分只有在开启 parallel 的情况下才可能达到，否则会直接跳过。</p><h4 id="STATE-COMPLETED"><a href="#STATE-COMPLETED" class="headerlink" title="STATE_COMPLETED"></a>STATE_COMPLETED</h4><p>顾名思义，STATE_COMPLETED 指该 Writer 已经完成了，因此这一部分没做什么重要的操作，直接返回了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()  </span><span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span>state <span class="token operator">==</span> WriteThread<span class="token double-colon punctuation">::</span>STATE_COMPLETED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>log_used <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>log_used <span class="token operator">=</span> w<span class="token punctuation">.</span>log_used<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>seq_used <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>seq_used <span class="token operator">=</span> w<span class="token punctuation">.</span>sequence<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// write is complete and leader has updated sequence</span>    <span class="token keyword">return</span> w<span class="token punctuation">.</span><span class="token function">FinalStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述两个分支，都只有非 Leader 能够达到。接下来，我们以 Leader 的视角继续。</p><h3 id="Leader-视角"><a href="#Leader-视角" class="headerlink" title="Leader 视角"></a>Leader 视角</h3><p>JoinBatchGroup() 会阻塞除了 Leader 以外的所有 Writer，而 Leader 的状态为 STATE_GROUP_LEADER，因此它会直接跳过上面两个分支，执行接下来的代码。Leader 会先创建一个空 WriteGroup，然后开始逐步构建它。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()  </span>WriteThread<span class="token double-colon punctuation">::</span>WriteGroup write_group<span class="token punctuation">;</span>last_batch_group_size_ <span class="token operator">=</span>    write_thread_<span class="token punctuation">.</span><span class="token function">EnterAsBatchGroupLeader</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>write_group<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，EnterAsBatchGroupLeader() 就是构建 WriteBatch 的核心函数。</p><h4 id="EnterAsBatchGroupLeader"><a href="#EnterAsBatchGroupLeader" class="headerlink" title="EnterAsBatchGroupLeader"></a>EnterAsBatchGroupLeader</h4><p>省去中间的配置判断，该函数源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">WriteThread</span><span class="token double-colon punctuation">::</span><span class="token function">EnterAsBatchGroupLeader</span><span class="token punctuation">(</span>Writer<span class="token operator">*</span> leader<span class="token punctuation">,</span>                                            WriteGroup<span class="token operator">*</span> write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>leader<span class="token operator">-></span>link_older <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>leader<span class="token operator">-></span>batch <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>write_group <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t size <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">ByteSize</span><span class="token punctuation">(</span>leader<span class="token operator">-></span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Allow the group to grow up to a maximum size, but if the</span>  <span class="token comment">// original write is small, limit the growth so we do not slow</span>  <span class="token comment">// down the small write too much.</span>  size_t max_size <span class="token operator">=</span> max_write_batch_group_size_bytes<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">uint64_t</span> min_batch_size_bytes <span class="token operator">=</span> max_write_batch_group_size_bytes <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> min_batch_size_bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    max_size <span class="token operator">=</span> size <span class="token operator">+</span> min_batch_size_bytes<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  leader<span class="token operator">-></span>write_group <span class="token operator">=</span> write_group<span class="token punctuation">;</span>  write_group<span class="token operator">-></span>leader <span class="token operator">=</span> leader<span class="token punctuation">;</span>  write_group<span class="token operator">-></span>last_writer <span class="token operator">=</span> leader<span class="token punctuation">;</span>  write_group<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  Writer<span class="token operator">*</span> newest_writer <span class="token operator">=</span> newest_writer_<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// This is safe regardless of any db mutex status of the caller. Previous</span>  <span class="token comment">// calls to ExitAsGroupLeader either didn't call CreateMissingNewerLinks</span>  <span class="token comment">// (they emptied the list and then we added ourself as leader) or had to</span>  <span class="token comment">// explicitly wake us up (the list was non-empty when we added ourself,</span>  <span class="token comment">// so we have already received our MarkJoined).</span>  <span class="token function">CreateMissingNewerLinks</span><span class="token punctuation">(</span>newest_writer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Tricky. Iteration start (leader) is exclusive and finish</span>  <span class="token comment">// (newest_writer) is inclusive. Iteration goes from old to new.</span>  Writer<span class="token operator">*</span> w <span class="token operator">=</span> leader<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> newest_writer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token operator">-></span>link_newer<span class="token punctuation">)</span><span class="token punctuation">;</span>    w <span class="token operator">=</span> w<span class="token operator">-></span>link_newer<span class="token punctuation">;</span>    <span class="token comment">// 各种if判断，如果w和leader的配置不吻合，那就break。</span>    w<span class="token operator">-></span>write_group <span class="token operator">=</span> write_group<span class="token punctuation">;</span>    size <span class="token operator">+=</span> batch_size<span class="token punctuation">;</span>    write_group<span class="token operator">-></span>last_writer <span class="token operator">=</span> w<span class="token punctuation">;</span>    write_group<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">TEST_SYNC_POINT_CALLBACK</span><span class="token punctuation">(</span><span class="token string">"WriteThread::EnterAsBatchGroupLeader:End"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，该函数取出 newest_writer_，然后调用 WriteThread::CreateMissingNewerLinks()。在 JoinBatchGroup 时，构造的是只有后向指针 link_older 的单向链表，而该函数就是从尾部遍历一遍这个链表，把每一个 Writer 的 link_newer 确定，即边单向为双向。其实现很简单，这里就不赘述了。</p><p>接着，进入循环，从 Leader（也就是自己）开始遍历。如果 w 和 Leader 的配置不吻合，那就 break，因为 WriteGroup 要保证配置一致。如果吻合，那就加入 WriteGroup 中，以此类推，最终用 last_writer 来标记 WriteGroup 中的最后一个 Writer。</p><p>Leader 构建完 WriteGroup 之后，就要执行写入了。</p><h4 id="是否-parallel"><a href="#是否-parallel" class="headerlink" title="是否 parallel"></a>是否 parallel</h4><p>WriteGroup 的写入分为 parallel 和  !parallel，即是否并行。判断准则如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>    <span class="token comment">// Rules for when we can update the memtable concurrently</span>    <span class="token comment">// 1. supported by memtable</span>    <span class="token comment">// 2. Puts are not okay if inplace_update_support</span>    <span class="token comment">// 3. Merges are not okay</span>    <span class="token comment">//</span>    <span class="token comment">// Rules 1..2 are enforced by checking the options</span>    <span class="token comment">// during startup (CheckConcurrentWritesSupported), so if</span>    <span class="token comment">// options.allow_concurrent_memtable_write is true then they can be</span>    <span class="token comment">// assumed to be true.  Rule 3 is checked for each batch.  We could</span>    <span class="token comment">// relax rules 2 if we could prevent write batches from referring</span>    <span class="token comment">// more than once to a particular key.</span>    <span class="token keyword">bool</span> parallel <span class="token operator">=</span> immutable_db_options_<span class="token punctuation">.</span>allow_concurrent_memtable_write <span class="token operator">&amp;&amp;</span>                    write_group<span class="token punctuation">.</span>size <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>    size_t total_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    size_t valid_batches <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    size_t total_byte_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    size_t pre_release_callback_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">*</span> writer <span class="token operator">:</span> write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>writer<span class="token operator">-></span><span class="token function">CheckCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        valid_batches <span class="token operator">+=</span> writer<span class="token operator">-></span>batch_cnt<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>writer<span class="token operator">-></span><span class="token function">ShouldWriteToMemtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          total_count <span class="token operator">+=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">Count</span><span class="token punctuation">(</span>writer<span class="token operator">-></span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>          parallel <span class="token operator">=</span> parallel <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>writer<span class="token operator">-></span>batch<span class="token operator">-></span><span class="token function">HasMerge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        total_byte_size <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">AppendedByteSize</span><span class="token punctuation">(</span>            total_byte_size<span class="token punctuation">,</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">ByteSize</span><span class="token punctuation">(</span>writer<span class="token operator">-></span>batch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>writer<span class="token operator">-></span>pre_release_callback<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          pre_release_callback_cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码来看，准则有三点：</p><ul><li>allow_concurrent_memtable_write 必须要置位。</li><li>只能是 out_of_place_update，不能是 inplace_update。</li><li>所有 Writer 中都不含 Merge 操作。</li></ul><p>我们分析下第二点。如果采用就地更新的话，那么就不能支持多 Writer 并发写了，原因是如果不是原地更新的话，那么同一个 key 可能会有多个版本：（keyX, seq1, val1）， （keyX, seq2, val2）， （keyX, seq3, val3)，多个 Writer 并发插数据到跳表的时候，一定能够保证，对于相同的 key，seq 越大的排在跳表的后面，这可以保证MVCC 或者事务的正确性。如果是原地更新，那么同一个 key 在跳表中只对应一个节点，多 writer 并发写的时候，无法保证 seq 最大的 Writer 最后写入相关的节点。</p><h4 id="写入-WAL"><a href="#写入-WAL" class="headerlink" title="写入 WAL"></a>写入 WAL</h4><p>如果没有置位 disableWAL ，那么接下来 WriteGroup 都要被写入 WAL，但是这会被分为 2pc 和 !2pc 两个分支。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>two_write_queues_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>write_options<span class="token punctuation">.</span>disableWAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>log_context<span class="token punctuation">.</span>log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        LogFileNumberSize<span class="token operator">&amp;</span> log_file_number_size <span class="token operator">=</span>            <span class="token operator">*</span><span class="token punctuation">(</span>log_context<span class="token punctuation">.</span>log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PERF_TIMER_GUARD</span><span class="token punctuation">(</span>write_wal_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        io_s <span class="token operator">=</span>            <span class="token function">WriteToWAL</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> log_context<span class="token punctuation">.</span>writer<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span>                       log_context<span class="token punctuation">.</span>need_log_sync<span class="token punctuation">,</span> log_context<span class="token punctuation">.</span>need_log_dir_sync<span class="token punctuation">,</span>                       last_sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> log_file_number_size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>write_options<span class="token punctuation">.</span>disableWAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">PERF_TIMER_GUARD</span><span class="token punctuation">(</span>write_wal_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// LastAllocatedSequence is increased inside WriteToWAL under</span>        <span class="token comment">// wal_write_mutex_ to ensure ordered events in WAL</span>        io_s <span class="token operator">=</span> <span class="token function">ConcurrentWriteToWAL</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> log_used<span class="token punctuation">,</span> <span class="token operator">&amp;</span>last_sequence<span class="token punctuation">,</span>                                    seq_inc<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Otherwise we inc seq number for memtable writes</span>        last_sequence <span class="token operator">=</span> versions_<span class="token operator">-></span><span class="token function">FetchAddLastAllocatedSequence</span><span class="token punctuation">(</span>seq_inc<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有开启 2pc，那么就会调用 WriteToWAL()，如果开启了 2pc，则调用 ConcurrentWriteToWAL()，二者都会将整个 WriteGroup 传入。具体怎么写 WAL 的，这里就不深入，在下一篇博客中会专门对 WAL 写入进行源码分析。</p><p>在写完 WAL 之后，会对 seq 进行一些推进，这里我们先略过。之后就开始写 memtable。</p><h4 id="写入-memtable"><a href="#写入-memtable" class="headerlink" title="写入 memtable"></a>写入 memtable</h4><p>写入 memtable 的流程被分为了两个分支，parallel 和 ! parallel，源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parallel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// w.sequence will be set inside InsertInto</span>        w<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>            write_group<span class="token punctuation">,</span> current_sequence<span class="token punctuation">,</span> column_family_memtables_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>flush_scheduler_<span class="token punctuation">,</span> <span class="token operator">&amp;</span>trim_history_scheduler_<span class="token punctuation">,</span>            write_options<span class="token punctuation">.</span>ignore_missing_column_families<span class="token punctuation">,</span>            <span class="token number">0</span> <span class="token comment">/*recovery_log_number*/</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> seq_per_batch_<span class="token punctuation">,</span>            batch_per_txn_<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        write_group<span class="token punctuation">.</span>last_sequence <span class="token operator">=</span> last_sequence<span class="token punctuation">;</span>        write_thread_<span class="token punctuation">.</span><span class="token function">LaunchParallelMemTableWriters</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>write_group<span class="token punctuation">)</span><span class="token punctuation">;</span>        in_parallel_group <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// Each parallel follower is doing each own writes. The leader should</span>        <span class="token comment">// also do its own.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">ShouldWriteToMemtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          ColumnFamilyMemTablesImpl <span class="token function">column_family_memtables</span><span class="token punctuation">(</span>              versions_<span class="token operator">-></span><span class="token function">GetColumnFamilySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>sequence <span class="token operator">==</span> current_sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>          w<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>              <span class="token operator">&amp;</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> <span class="token operator">&amp;</span>column_family_memtables<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flush_scheduler_<span class="token punctuation">,</span>              <span class="token operator">&amp;</span>trim_history_scheduler_<span class="token punctuation">,</span>              write_options<span class="token punctuation">.</span>ignore_missing_column_families<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/*log_number*/</span><span class="token punctuation">,</span>              <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/*concurrent_memtable_writes*/</span><span class="token punctuation">,</span> seq_per_batch_<span class="token punctuation">,</span>              w<span class="token punctuation">.</span>batch_cnt<span class="token punctuation">,</span> batch_per_txn_<span class="token punctuation">,</span>              write_options<span class="token punctuation">.</span>memtable_insert_hint_per_batch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分析之前，先说一下，WriteBatchInternal::InsertInto() 是向 memtable 写入的入口函数，它有三个重载，分别用于 WriteGroup、WriteBatch 以及 Writer，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> Status <span class="token function">InsertInto</span><span class="token punctuation">(</span>    WriteThread<span class="token double-colon punctuation">::</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Convenience form of InsertInto when you have only one batch</span><span class="token comment">// next_seq returns the seq after last sequence number used in MemTable insert</span><span class="token keyword">static</span> Status <span class="token function">InsertInto</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> WriteBatch<span class="token operator">*</span> batch<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> Status <span class="token function">InsertInto</span><span class="token punctuation">(</span>    WriteThread<span class="token double-colon punctuation">::</span>Writer<span class="token operator">*</span> writer<span class="token punctuation">,</span> xxx<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是 !parallel，那就很直观了，因为 Leader 全权负责整个 WriteGroup 的写入，它会直接调用 WriteBatchInternal::InsertInto() 的第一个重载，独自写入整个 WriteGroup。</p><p>这里着重关注一下 parallel 模式。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>write_thread_<span class="token punctuation">.</span><span class="token function">LaunchParallelMemTableWriters</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>write_group<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述操作会唤醒 WriteGroup 的所有 Writer，并将它们的状态设为 STATE_PARALLEL_MEMTABLE_WRITER，源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">WriteThread</span><span class="token double-colon punctuation">::</span><span class="token function">LaunchParallelMemTableWriters</span><span class="token punctuation">(</span>WriteGroup<span class="token operator">*</span> write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>write_group <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  write_group<span class="token operator">-></span>running<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>write_group<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> w <span class="token operator">:</span> <span class="token operator">*</span>write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SetState</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> STATE_PARALLEL_MEMTABLE_WRITER<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，被唤醒的 Writer 会从 JoinBatchGroup() 中返回，进入非 Leader 视角的分支，自己执行写入。而 Leader 同它们一样，不再负责整个 WriteGroup 的写入了，只需完成自己的写入即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>        <span class="token comment">// Each parallel follower is doing each own writes. The leader should</span>        <span class="token comment">// also do its own.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">ShouldWriteToMemtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          ColumnFamilyMemTablesImpl <span class="token function">column_family_memtables</span><span class="token punctuation">(</span>              versions_<span class="token operator">-></span><span class="token function">GetColumnFamilySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">assert</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>sequence <span class="token operator">==</span> current_sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>          w<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token class-name">WriteBatchInternal</span><span class="token double-colon punctuation">::</span><span class="token function">InsertInto</span><span class="token punctuation">(</span>              <span class="token operator">&amp;</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> <span class="token operator">&amp;</span>column_family_memtables<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flush_scheduler_<span class="token punctuation">,</span>              <span class="token operator">&amp;</span>trim_history_scheduler_<span class="token punctuation">,</span>              write_options<span class="token punctuation">.</span>ignore_missing_column_families<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/*log_number*/</span><span class="token punctuation">,</span>              <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/*concurrent_memtable_writes*/</span><span class="token punctuation">,</span> seq_per_batch_<span class="token punctuation">,</span>              w<span class="token punctuation">.</span>batch_cnt<span class="token punctuation">,</span> batch_per_txn_<span class="token punctuation">,</span>              write_options<span class="token punctuation">.</span>memtable_insert_hint_per_batch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不管是 WriteBatchInternal::InsertInto() 的第一个重载还是第二个重载，其核心都是一致的，在这里就不深入了，会放在对 memtable 写入的博客中详细分析。</p><p>写完 memtable 之后，Leader 会做一些 log_sync 操作，这里先略过。</p><h4 id="ExitAsBatchGroupLeader"><a href="#ExitAsBatchGroupLeader" class="headerlink" title="ExitAsBatchGroupLeader"></a>ExitAsBatchGroupLeader</h4><p>到这里，WriteGroup 任务就算完成了，然后会开始一些扫尾工作。如果是 parallel，那么由最后一个完成写入的 Writer 来执行，如果不是，那么 Leader 直接执行。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// DBImpl::WriteImpl()</span>  <span class="token keyword">bool</span> should_exit_batch_group <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>in_parallel_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// CompleteParallelWorker returns true if this thread should</span>    <span class="token comment">// handle exit, false means somebody else did</span>    should_exit_batch_group <span class="token operator">=</span> write_thread_<span class="token punctuation">.</span><span class="token function">CompleteParallelMemTableWriter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>should_exit_batch_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">*</span> tmp_w <span class="token operator">:</span> write_group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>tmp_w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_w<span class="token operator">-></span>post_memtable_callback<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          Status tmp_s <span class="token operator">=</span>              <span class="token punctuation">(</span><span class="token operator">*</span>tmp_w<span class="token operator">-></span>post_memtable_callback<span class="token punctuation">)</span><span class="token punctuation">(</span>last_sequence<span class="token punctuation">,</span> disable_memtable<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// TODO: propagate the execution status of post_memtable_callback to</span>          <span class="token comment">// caller.</span>          <span class="token function">assert</span><span class="token punctuation">(</span>tmp_s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// Note: if we are to resume after non-OK statuses we need to revisit how</span>      <span class="token comment">// we reacts to non-OK statuses here.</span>      versions_<span class="token operator">-></span><span class="token function">SetLastSequence</span><span class="token punctuation">(</span>last_sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">MemTableInsertStatusCheck</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    write_thread_<span class="token punctuation">.</span><span class="token function">ExitAsBatchGroupLeader</span><span class="token punctuation">(</span>write_group<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扫尾工作有两项：</p><ul><li>更新该 version 的 last_sequence_。</li><li>辅助生成下一个 WriteGroup。</li></ul><p>截取 ExitAsBatchGroupLeader 中的非 pipelined 部分，源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">WriteThread</span><span class="token double-colon punctuation">::</span><span class="token function">ExitAsBatchGroupLeader</span><span class="token punctuation">(</span>WriteGroup<span class="token operator">&amp;</span> write_group<span class="token punctuation">,</span>                                         Status<span class="token operator">&amp;</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Writer<span class="token operator">*</span> leader <span class="token operator">=</span> write_group<span class="token punctuation">.</span>leader<span class="token punctuation">;</span>  Writer<span class="token operator">*</span> last_writer <span class="token operator">=</span> write_group<span class="token punctuation">.</span>last_writer<span class="token punctuation">;</span>  <span class="token comment">// ...</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>enable_pipelined_write_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    Writer<span class="token operator">*</span> head <span class="token operator">=</span> newest_writer_<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> last_writer <span class="token operator">||</span>        <span class="token operator">!</span>newest_writer_<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Either last_writer wasn't the head during the load(), or it was the</span>      <span class="token comment">// head during the load() but somebody else pushed onto the list before</span>      <span class="token comment">// we did the compare_exchange_strong (causing it to fail).  In the</span>      <span class="token comment">// latter case compare_exchange_strong has the effect of re-reading</span>      <span class="token comment">// its first param (head).  No need to retry a failing CAS, because</span>      <span class="token comment">// only a departing leader (which we are at the moment) can remove</span>      <span class="token comment">// nodes from the list.</span>      <span class="token function">assert</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> last_writer<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// After walking link_older starting from head (if not already done)</span>      <span class="token comment">// we will be able to traverse w->link_newer below. This function</span>      <span class="token comment">// can only be called from an active leader, only a leader can</span>      <span class="token comment">// clear newest_writer_, we didn't, and only a clear newest_writer_</span>      <span class="token comment">// could cause the next leader to start their work without a call</span>      <span class="token comment">// to MarkJoined, so we can definitely conclude that no other leader</span>      <span class="token comment">// work is going on here (with or without db mutex).</span>      <span class="token function">CreateMissingNewerLinks</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>last_writer<span class="token operator">-></span>link_newer <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>last_writer<span class="token operator">-></span>link_newer<span class="token operator">-></span>link_older <span class="token operator">==</span> last_writer<span class="token punctuation">)</span><span class="token punctuation">;</span>      last_writer<span class="token operator">-></span>link_newer<span class="token operator">-></span>link_older <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment">// Next leader didn't self-identify, because newest_writer_ wasn't</span>      <span class="token comment">// nullptr when they enqueued (we were definitely enqueued before them</span>      <span class="token comment">// and are still in the list).  That means leader handoff occurs when</span>      <span class="token comment">// we call MarkJoined</span>      <span class="token function">SetState</span><span class="token punctuation">(</span>last_writer<span class="token operator">-></span>link_newer<span class="token punctuation">,</span> STATE_GROUP_LEADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// else nobody else was waiting, although there might already be a new</span>    <span class="token comment">// leader now</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>last_writer <span class="token operator">!=</span> leader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>last_writer<span class="token punctuation">)</span><span class="token punctuation">;</span>      last_writer<span class="token operator">-></span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>      <span class="token comment">// we need to read link_older before calling SetState, because as soon</span>      <span class="token comment">// as it is marked committed the other thread's Await may return and</span>      <span class="token comment">// deallocate the Writer.</span>      <span class="token keyword">auto</span> next <span class="token operator">=</span> last_writer<span class="token operator">-></span>link_older<span class="token punctuation">;</span>      <span class="token function">SetState</span><span class="token punctuation">(</span>last_writer<span class="token punctuation">,</span> STATE_COMPLETED<span class="token punctuation">)</span><span class="token punctuation">;</span>      last_writer <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，虽然在 EnterAsBatchGroupLeader() 时已经调用过一次 CreateMissingNewerLinks() 将 WriteLink 由单向链表转变为双向链表，但是在 WriteGroup 写入的过程中，很有可能会有新的 Write 加入 WriteLink，而新的这一段就是单向链表了，因此在 Exit 时又调用了一遍 CreateMissingNewerLinks() 确保 WriteLink 为双向链表。</p><p>接着，它会选择新的 Leader，实际上就是 last_writer 的后一个 Writer，并且把新 Leader 的 link_order 置空，意为把新旧两个 WriteGroup 断开了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// WriteThread::ExitAsBatchGroupLeader()</span>last_writer<span class="token operator">-></span>link_newer<span class="token operator">-></span>link_older <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token function">SetState</span><span class="token punctuation">(</span>last_writer<span class="token operator">-></span>link_newer<span class="token punctuation">,</span> STATE_GROUP_LEADER<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后，把所处 WriteGroup 中的所有 Writer 状态都改为 STATE_COMPLETED，意味完成写入。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// WriteThread::ExitAsBatchGroupLeader()</span><span class="token keyword">while</span> <span class="token punctuation">(</span>last_writer <span class="token operator">!=</span> leader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>last_writer<span class="token punctuation">)</span><span class="token punctuation">;</span>    last_writer<span class="token operator">-></span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>    <span class="token comment">// we need to read link_older before calling SetState, because as soon</span>    <span class="token comment">// as it is marked committed the other thread's Await may return and</span>    <span class="token comment">// deallocate the Writer.</span>    <span class="token keyword">auto</span> next <span class="token operator">=</span> last_writer<span class="token operator">-></span>link_older<span class="token punctuation">;</span>    <span class="token function">SetState</span><span class="token punctuation">(</span>last_writer<span class="token punctuation">,</span> STATE_COMPLETED<span class="token punctuation">)</span><span class="token punctuation">;</span>    last_writer <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，当选择新的 Leader 之后，后者会被唤醒，即可从 JoinBatchGroup() 中返回，进入 Leader 视角的分支，重复上述行为，构造新的 WriteGroup，以此循环。</p><hr><p>至此，与 WriteGroup 有关的源码分析就结束了，下一篇将分析向 WAL 中的写入。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(五): 写(一)-框架</title>
      <link href="/rocksdb-yuan-ma-xue-xi-wu-xie-yi-kuang-jia/"/>
      <url>/rocksdb-yuan-ma-xue-xi-wu-xie-yi-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>RocksDB 的写流程比读流程要复杂很多，其中涉及到了多线程写入与 RocksDB 采用的很多优化，比如 unordered_write、pipelined_write 等等，还有一些可选策略，比如 2pc、parallel 等等，所以写入过程的分支非常多，如果直接磕源码会很没方向。</p><p>本篇博客将先理清 RocksDB 的基本写入框架，不考虑 pipelined_write 优化，并且不讨论源码实现，用以为后续的源码分析做前言。</p><hr><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>RocksDB 的写入口为 DBImpl::WriteImpl()，这个函数相当复杂，写操作的所有分支流程基本都被封装进去了，该函数的核心入参为一个 WriteBatch* 和一个 WriteOptions&amp; 。RocksDB 每个<strong>线程</strong>发起的写事务均以一个 WriteBatch 对象为载体，WriteBatch 记录了要写入的所有数据。接着，WriteBatch 会被封装为一个 WriteThread::Writer 结构体，该结构体将存储 WriteBatch、WriteOptions 中的配置以及前后向指针等等，所以一个写线程配备一个 Writer。可以看下这个结构的源码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Writer</span> <span class="token punctuation">&#123;</span>  WriteBatch<span class="token operator">*</span> batch<span class="token punctuation">;</span>  <span class="token keyword">bool</span> sync<span class="token punctuation">;</span>  <span class="token keyword">bool</span> no_slowdown<span class="token punctuation">;</span>  <span class="token keyword">bool</span> disable_wal<span class="token punctuation">;</span>  Env<span class="token double-colon punctuation">::</span>IOPriority rate_limiter_priority<span class="token punctuation">;</span>  <span class="token keyword">bool</span> disable_memtable<span class="token punctuation">;</span>  size_t batch_cnt<span class="token punctuation">;</span>  <span class="token comment">// if non-zero, number of sub-batches in the write batch</span>  size_t protection_bytes_per_key<span class="token punctuation">;</span>  PreReleaseCallback<span class="token operator">*</span> pre_release_callback<span class="token punctuation">;</span>  PostMemTableCallback<span class="token operator">*</span> post_memtable_callback<span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> log_used<span class="token punctuation">;</span>  <span class="token comment">// log number that this batch was inserted into</span>  <span class="token keyword">uint64_t</span> log_ref<span class="token punctuation">;</span>   <span class="token comment">// log number that memtable insert should reference</span>  WriteCallback<span class="token operator">*</span> callback<span class="token punctuation">;</span>  <span class="token keyword">bool</span> made_waitable<span class="token punctuation">;</span>          <span class="token comment">// records lazy construction of mutex and cv</span>  std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">uint8_t</span><span class="token operator">></span> state<span class="token punctuation">;</span>  <span class="token comment">// write under StateMutex() or pre-link</span>  WriteGroup<span class="token operator">*</span> write_group<span class="token punctuation">;</span>  SequenceNumber sequence<span class="token punctuation">;</span>  <span class="token comment">// the sequence number to use for the first key</span>  Status status<span class="token punctuation">;</span>  Status callback_status<span class="token punctuation">;</span>  <span class="token comment">// status returned by callback->Callback()</span>  std<span class="token double-colon punctuation">::</span>aligned_storage<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token punctuation">)</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>type state_mutex_bytes<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>aligned_storage<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable<span class="token punctuation">)</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>type state_cv_bytes<span class="token punctuation">;</span>  Writer<span class="token operator">*</span> link_older<span class="token punctuation">;</span>  <span class="token comment">// read/write only before linking, or as leader</span>  Writer<span class="token operator">*</span> link_newer<span class="token punctuation">;</span>  <span class="token comment">// lazy, read/write only before linking, or as leader</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单的来讲，该结构记录了如下信息：</p><ul><li>本次 write 的配置，比如是否要做 sync，要写入的 WAL 日志编号等等</li><li>本次要 write 的数据，即 <strong>WriteBatch</strong> 对象</li><li>本次 write 所属的 WiteGroup</li><li>本次 write 的第一个数据对象的 sequence number</li><li>前置 Writer</li><li>后置 Writer</li></ul><h3 id="WriteGroup-构建"><a href="#WriteGroup-构建" class="headerlink" title="WriteGroup 构建"></a>WriteGroup 构建</h3><p>因为随时都会有接连不断的写请求涌入，为了处理并发， RocksDB 将多个 Writer 对象用链表串起来，组成一个WiteGroup，一个 WriteGroup 会选出一个 Leader 来管理当前 group 的写过程。<strong>而任意时刻只会有一个WriteGroup被写入。</strong></p><p>每个 Writer 写入前要先加入一个 WriteGroup。加入的过程其实将 Writer 对象加入到 WriteGroup 链表尾端。每个 <strong>DB</strong> 对象一次只能存在一个 WriteGroup，只有当该 WriteGroup 全部写入完成后，才会开始建立新的 WriteGroup。</p><p>首先关注下 WriteGroup 的建立过程。</p><p>在 DBImpl::WriteImpl() 封装每一个 Writer 之后，都会把它加进当前 DB 对象的 Writer 的<strong>单向</strong>链表中，不妨把该该链表称为 WriteLink（实际没有这个结构），link_older 就是该链表的指针，由后往前指。而这个 WriteLink 并不是 WriteGroup，二者是包含关系，每次生成 WriteGroup 都是从 WriteLink 的 Leader 开始连续选择一定数量的 Writer 构成的子<strong>双向</strong>链表。在 WriteLink 中，由 newest_writer_ 代表最后一个 Writer，在 WriteGroup 中，由 last_writer 代表最后一个 Writer。</p><p>Writer 加入 WriteLink 的过程，由 WriteThread::JoinBatchGroup() 实现，主要完成两点作用：</p><ul><li>如果加入时链表为空，则将该 Writer 标记为 Leader；</li><li>如果加入时链表不为空，则阻塞等待该 Writer 的状态被设置；</li></ul><p>WriteGroup 的建立位于 WriteThread::EnterAsBatchGroupLeader() 中，由 Leader 执行，它会首先遍历整个 WriteLink，把单向链表变成双向链表，由 WriteThread::CreateMissingNewerLinks() 实现。接着，重新从 Leader 开始往后遍历，逐个加入 WriteGroup，直到遇见一个 Writer 的配置与 Leader 的配置不符，就算作构建完成。因此，一个 WriteGroup 中所有的 Writer 都是配置相符合的。</p><p><img src="https://s1.ax1x.com/2022/10/25/xR4NB4.png" alt="WriteGroup与WriteLink"></p><p>WriteGroup 构建完毕后，由 Leader 来处理其向 WAL 以及 Memtable 中的写入，具体怎么写入先略过。</p><p>当本次 WriteGroup 写入完毕后，它需要做一些收尾工作，由 Leader 完成，主要为两点：</p><ul><li>更新全局的 sequence number；</li><li>设置新的 WriteGroup</li></ul><p>第一点由 VersionSet::SetLastSequence() 实现，第二点由 WriteThread::ExitAsBatchGroupLeader() 来实现，这里只关注后者。虽然 WriteThread::CreateMissingNewerLinks() 已经将单向链表变为双向链表，但是在 WriteGroup 写入的过程中，可能有新的 Writer 加入 WriteLink 中，而新的这一段仍然是单向链表，所以 Exit 会重新调用一遍 WriteThread::CreateMissingNewerLinks() 来完善双向链表。接着，设置下一个 WriteGroup 的新Leader（为本组最后一个 Writer 的后置 Writer），并将新 Leader 的前置指针设为 null。</p><p><img src="https://s1.ax1x.com/2022/10/25/xR5zod.png" alt="新的WriteGroup"></p><p>上述流程的源码分析在下一篇博客会详细说明：<a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-liu-xie-er-writegroup/">WriteGroup 源码分析</a>。接下来，我们关注 WriteGroup 的写入。</p><h3 id="WriteGroup-写入"><a href="#WriteGroup-写入" class="headerlink" title="WriteGroup 写入"></a>WriteGroup 写入</h3><p>这里不考虑 pipelined_write，不考虑 2pc。WriteGroup 的写入分为两步，一是写入 WAL，二是写入 memtable。前者由 DBImpl::WriteToWAL() 实现，后者主要由 WriteBatchInternal::InsertInto() 实现。</p><h4 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h4><p>WAL 主要的功能是当 RocksDB 异常退出后，能够恢复出错前的内存中（memtable）数据,因此 RocksDB 默认是每次用户写都会刷新数据到 WAL。每次当当前 WAL 对应的 memtable 刷新到磁盘之后，都会新建一个WAL，即一个 WAL 对应一个memtable。</p><p>每一个 WAL 最后都会被写入对应的 WAL 文件中，所有的 WAL 文件均保存在 WA L目录（options.wal_dir），为了保证数据的状态，所有的 WAL 文件的名字都是按照顺序的（log_number）。</p><p>写 WAL 可以简单分为三个阶段，第一阶段往 WritableFileWriter 的 buf_ 里面写，第二阶段写到系统缓存，第三阶段是将系统缓存刷盘，也就是让写文件操作落盘。WAL 写入的具体流程会在源码分析时详细说明：<a href="">WAL 写源码分析（待填坑</a>。</p><h4 id="memtable"><a href="#memtable" class="headerlink" title="memtable"></a>memtable</h4><p>在 RocksDB 中，每个 CF 都有自己的 memtable，互不影响。每当 WriteGroup 写完 WAL 之后，就会向 memtable 中去写。具体的写入流程将分为两种情况， !parallel 和 parallel，由 allow_concurrent_memtable_write 来决定。</p><p>在没有并行的情况下，Leader 全权负责整个 WriteGroup 的写入，在并行的情况下，Leader 会唤醒该 WriteGroup 中的所有 Writer，然后各自负责自己的写入，并发执行。不管哪种情况，写memtable的入口函数为WriteBatchInternal::InsertInto()，它会根据传入的是 WriteGroup、Writer 还是 WriteBatch 来进行重载。</p><p>memtable 写入的具体流程会在源码分析时详细说明：</p><ul><li><a href="">memtable 写入源码分析（非并行）（待填坑</a></li><li><a href="">memtable 写入源码分析（并行）（待填坑</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里贴两张总结图，是网上找的，版本为 2018年7月11日版本（commit：35b38a232c1d357a7a885b9b4b8442e24a8433d7 ），不过我没搜到这一版。原图所在仓库：<a href="https://github.com/wisehead/myrocks_notes">https://github.com/wisehead/myrocks_notes</a></p><p>1、当开启 allow_concurrent_memtable_write 并且关闭 pipelined_write 的写入流程图：</p><img src="https://s1.ax1x.com/2022/10/25/xRTiqS.jpg" alt="parallel写入流程" style="zoom: 80%;" /><p>2、从 WriteImpl() 开始的函数调用链图，图片太大了，地址如下：</p><p><a href="https://s1.ax1x.com/2022/10/25/xRT6JA.jpg">https://s1.ax1x.com/2022/10/25/xRT6JA.jpg</a></p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(四): 读(三)</title>
      <link href="/rocksdb-yuan-ma-xue-xi-si-du-san/"/>
      <url>/rocksdb-yuan-ma-xue-xi-si-du-san/</url>
      
        <content type="html"><![CDATA[<p>注：本篇博客涉及的代码版本均为<code>v7.7.4</code>。</p><p>上两篇博客中我们分析了 RocksDB 如何在内存中查找对应的数据，这一篇我们将会详细分析当内存中未找到记录时，RocksDB 如何在磁盘上查找对应的数据。</p><hr><p>依旧是从 DBImpl::GetImpl() 开始，当再 memtable 和 immutable memtable 中均没有找到后，会进入如下代码段：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">PERF_TIMER_GUARD</span><span class="token punctuation">(</span>get_from_output_files_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    sv<span class="token operator">-></span>current<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>        read_options<span class="token punctuation">,</span> lkey<span class="token punctuation">,</span> get_impl_options<span class="token punctuation">.</span>value<span class="token punctuation">,</span> get_impl_options<span class="token punctuation">.</span>columns<span class="token punctuation">,</span>        timestamp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>merge_context<span class="token punctuation">,</span> <span class="token operator">&amp;</span>max_covering_tombstone_seq<span class="token punctuation">,</span>        <span class="token operator">&amp;</span>pinned_iters_mgr<span class="token punctuation">,</span>        get_impl_options<span class="token punctuation">.</span>get_value <span class="token operator">?</span> get_impl_options<span class="token punctuation">.</span>value_found <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>        <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>        get_impl_options<span class="token punctuation">.</span>get_value <span class="token operator">?</span> get_impl_options<span class="token punctuation">.</span>callback <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>        get_impl_options<span class="token punctuation">.</span>get_value <span class="token operator">?</span> get_impl_options<span class="token punctuation">.</span>is_blob_index <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>        get_impl_options<span class="token punctuation">.</span>get_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">RecordTick</span><span class="token punctuation">(</span>stats_<span class="token punctuation">,</span> MEMTABLE_MISS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即，会调用 Version::Get() 函数，而这个函数，才真正进入磁盘中开始查找。简单的来说，该函数要先找到可能存在的目标 key 的 sstable，然后再从该 sstable 中查找目标 key，如果没找到，就再找下一个可能存在目标 key 的 sstable，然后继续在其中查找，以此迭代，直到把所有的 level 都找一遍。我们截取它的部分代码，主要分为三个部分，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Version</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> read_options<span class="token punctuation">,</span> <span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span> k<span class="token punctuation">,</span>                  PinnableSlice<span class="token operator">*</span> value<span class="token punctuation">,</span> PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">,</span>                  std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">,</span> Status<span class="token operator">*</span> status<span class="token punctuation">,</span>                  MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">,</span>                  SequenceNumber<span class="token operator">*</span> max_covering_tombstone_seq<span class="token punctuation">,</span>                  PinnedIteratorsManager<span class="token operator">*</span> pinned_iters_mgr<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">*</span> value_found<span class="token punctuation">,</span>                  <span class="token keyword">bool</span><span class="token operator">*</span> key_exists<span class="token punctuation">,</span> SequenceNumber<span class="token operator">*</span> seq<span class="token punctuation">,</span> ReadCallback<span class="token operator">*</span> callback<span class="token punctuation">,</span>                  <span class="token keyword">bool</span><span class="token operator">*</span> is_blob<span class="token punctuation">,</span> <span class="token keyword">bool</span> do_merge<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  GetContext <span class="token function">get_context</span><span class="token punctuation">(</span>      <span class="token function">user_comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> merge_operator_<span class="token punctuation">,</span> info_log_<span class="token punctuation">,</span> db_statistics_<span class="token punctuation">,</span>      status<span class="token operator">-></span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> GetContext<span class="token double-colon punctuation">::</span>kNotFound <span class="token operator">:</span> GetContext<span class="token double-colon punctuation">::</span>kMerge<span class="token punctuation">,</span> user_key<span class="token punctuation">,</span>      do_merge <span class="token operator">?</span> value <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> do_merge <span class="token operator">?</span> columns <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>      do_merge <span class="token operator">?</span> timestamp <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> value_found<span class="token punctuation">,</span> merge_context<span class="token punctuation">,</span> do_merge<span class="token punctuation">,</span>      max_covering_tombstone_seq<span class="token punctuation">,</span> clock_<span class="token punctuation">,</span> seq<span class="token punctuation">,</span>      merge_operator_ <span class="token operator">?</span> pinned_iters_mgr <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> is_blob_to_use<span class="token punctuation">,</span>      tracing_get_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>blob_fetcher<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span>  FilePicker <span class="token function">fp</span><span class="token punctuation">(</span>user_key<span class="token punctuation">,</span> ikey<span class="token punctuation">,</span> <span class="token operator">&amp;</span>storage_info_<span class="token punctuation">.</span>level_files_brief_<span class="token punctuation">,</span>                storage_info_<span class="token punctuation">.</span>num_non_empty_levels_<span class="token punctuation">,</span>                <span class="token operator">&amp;</span>storage_info_<span class="token punctuation">.</span>file_indexer_<span class="token punctuation">,</span> <span class="token function">user_comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">internal_comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FdWithKeyRange<span class="token operator">*</span> f <span class="token operator">=</span> fp<span class="token punctuation">.</span><span class="token function">GetNextFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>status <span class="token operator">=</span> table_cache_<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>        read_options<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token function">internal_comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>f<span class="token operator">-></span>file_metadata<span class="token punctuation">,</span> ikey<span class="token punctuation">,</span>        <span class="token operator">&amp;</span>get_context<span class="token punctuation">,</span> mutable_cf_options_<span class="token punctuation">.</span>prefix_extractor<span class="token punctuation">,</span>        cfd_<span class="token operator">-></span><span class="token function">internal_stats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetFileReadHist</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span><span class="token function">GetHitFileLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">IsFilterSkipped</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span><span class="token function">GetHitFileLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        fp<span class="token punctuation">.</span><span class="token function">IsHitFileLastInLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        fp<span class="token punctuation">.</span><span class="token function">GetHitFileLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> max_file_size_for_l0_meta_pin_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>get_context<span class="token punctuation">.</span><span class="token function">State</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// ...</span>      <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kFound<span class="token operator">:</span>      <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span>    f <span class="token operator">=</span> fp<span class="token punctuation">.</span><span class="token function">GetNextFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四个部分依次如下：</p><ul><li>用 get_context 来维护查找过程中的上下文，类似与在 memtable 中查找时的 saver。</li><li>创建一个文件选择器 FilePicker，名为 fp。</li><li>通过 fp.GetNextFile() 得到可能存在目标 key 的 sstable。</li><li>通过 table_cache_-&gt;Get() 在上述 sstable 中查找目标 key，如果没找到就重新执行步骤 3 来迭代。</li></ul><h2 id="GetContext"><a href="#GetContext" class="headerlink" title="GetContext"></a>GetContext</h2><p>首先看查找前的初始化，创建一个变量 get_context，其类型未类 GetContext，该类用来保存查询过程中的一些上下文，比如目标 key、查询状态、时间戳等等，其作用类似于在 memtable 中辅助查找的结构体 Saver。构造函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">GetContext</span><span class="token double-colon punctuation">::</span><span class="token function">GetContext</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> Comparator<span class="token operator">*</span> ucmp<span class="token punctuation">,</span> <span class="token keyword">const</span> MergeOperator<span class="token operator">*</span> merge_operator<span class="token punctuation">,</span> Logger<span class="token operator">*</span> logger<span class="token punctuation">,</span>    Statistics<span class="token operator">*</span> statistics<span class="token punctuation">,</span> GetState init_state<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> user_key<span class="token punctuation">,</span>    PinnableSlice<span class="token operator">*</span> pinnable_val<span class="token punctuation">,</span> PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">,</span>    std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">*</span> value_found<span class="token punctuation">,</span> MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">,</span>    <span class="token keyword">bool</span> do_merge<span class="token punctuation">,</span> SequenceNumber<span class="token operator">*</span> _max_covering_tombstone_seq<span class="token punctuation">,</span>    SystemClock<span class="token operator">*</span> clock<span class="token punctuation">,</span> SequenceNumber<span class="token operator">*</span> seq<span class="token punctuation">,</span>    PinnedIteratorsManager<span class="token operator">*</span> _pinned_iters_mgr<span class="token punctuation">,</span> ReadCallback<span class="token operator">*</span> callback<span class="token punctuation">,</span>    <span class="token keyword">bool</span><span class="token operator">*</span> is_blob_index<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> tracing_get_id<span class="token punctuation">,</span> BlobFetcher<span class="token operator">*</span> blob_fetcher<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">ucmp_</span><span class="token punctuation">(</span>ucmp<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">merge_operator_</span><span class="token punctuation">(</span>merge_operator<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">logger_</span><span class="token punctuation">(</span>logger<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">statistics_</span><span class="token punctuation">(</span>statistics<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">state_</span><span class="token punctuation">(</span>init_state<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">user_key_</span><span class="token punctuation">(</span>user_key<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">pinnable_val_</span><span class="token punctuation">(</span>pinnable_val<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">columns_</span><span class="token punctuation">(</span>columns<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">timestamp_</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">value_found_</span><span class="token punctuation">(</span>value_found<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">merge_context_</span><span class="token punctuation">(</span>merge_context<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">max_covering_tombstone_seq_</span><span class="token punctuation">(</span>_max_covering_tombstone_seq<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">clock_</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">seq_</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">replay_log_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">pinned_iters_mgr_</span><span class="token punctuation">(</span>_pinned_iters_mgr<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">callback_</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">do_merge_</span><span class="token punctuation">(</span>do_merge<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">is_blob_index_</span><span class="token punctuation">(</span>is_blob_index<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">tracing_get_id_</span><span class="token punctuation">(</span>tracing_get_id<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">blob_fetcher_</span><span class="token punctuation">(</span>blob_fetcher<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>seq_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>seq_ <span class="token operator">=</span> kMaxSequenceNumber<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  sample_ <span class="token operator">=</span> <span class="token function">should_sample_file_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要留意一下，当 Version::Get() 构造 GetContext 时，第 7 个参数 pinnable_val（PinnableSlice* ）的值取决于 do_merge，如果 do_merge 为 true，则传入 value（PinnableSlice*），反之则传入 nullptr。</p><h2 id="FilePicker"><a href="#FilePicker" class="headerlink" title="FilePicker"></a>FilePicker</h2><p>接下来我们看一下辅助类 FilePicker，类如其名，作用就是通过传入的 user_key （LookupKey 中的）来获取到可能位于的 sstable 里。该类的一些私有字段如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FilePicker</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ...</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_levels_<span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> curr_level_<span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> returned_file_level_<span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> hit_file_level_<span class="token punctuation">;</span>  <span class="token keyword">int32_t</span> search_left_bound_<span class="token punctuation">;</span>  <span class="token keyword">int32_t</span> search_right_bound_<span class="token punctuation">;</span>  autovector<span class="token operator">&lt;</span>LevelFilesBrief<span class="token operator">></span><span class="token operator">*</span> level_files_brief_<span class="token punctuation">;</span>  <span class="token keyword">bool</span> search_ended_<span class="token punctuation">;</span>  <span class="token keyword">bool</span> is_hit_file_last_in_level_<span class="token punctuation">;</span>  LevelFilesBrief<span class="token operator">*</span> curr_file_level_<span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> curr_index_in_curr_level_<span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> start_index_in_curr_level_<span class="token punctuation">;</span>  Slice user_key_<span class="token punctuation">;</span>  Slice ikey_<span class="token punctuation">;</span>  FileIndexer<span class="token operator">*</span> file_indexer_<span class="token punctuation">;</span>  <span class="token keyword">const</span> Comparator<span class="token operator">*</span> user_comparator_<span class="token punctuation">;</span>  <span class="token keyword">const</span> InternalKeyComparator<span class="token operator">*</span> internal_comparator_<span class="token punctuation">;</span> <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先简单的介绍一下各字段的含义：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>num_levels_</td><td>磁盘中一共有多少层 level</td></tr><tr><td>curr_level_</td><td>当前所在的 level</td></tr><tr><td>returned_file_level_</td><td>返回的 sstable 所在的 level</td></tr><tr><td>hit_file_level_</td><td>命中的 sstable 所在的 level</td></tr><tr><td>search_left_bound_</td><td>下一层查找的左边界 sstable 下标</td></tr><tr><td>search_right_bound_</td><td>下一层查找的右边界 sstable 下标</td></tr><tr><td>level_files_brief_</td><td>所有 level 的 LevelFilesBrief 组成的一个 vector</td></tr><tr><td>search_ended_</td><td>查找是否结束</td></tr><tr><td>is_hit_file_last_in_level_</td><td>命中的 sstable 是否为当前 level 中的最后一个</td></tr><tr><td>curr_file_level_</td><td>LevelFilesBrief 类型，为一个 level 中的所有 sstable 组成的数组的头节点</td></tr><tr><td>curr_index_in_curr_level_</td><td>当前 sstable 位于当前 level 的下标</td></tr><tr><td>start_index_in_curr_level_</td><td>当前 level 的查找起点 sstable 的下标</td></tr><tr><td>user_key_</td><td>目标 user_key（实际就是 ikey_ 中的 user_key）</td></tr><tr><td>ikey_</td><td>LookupKey</td></tr></tbody></table><p>这里，我们重点关注三个字段：search_left_bound_ 、search_right_bound_ 、level_files_brief_，它们三个均和接下来要介绍的重点函数 GetNextFile() 密不可分。在介绍开始之前，我们先回顾一下 RocksDB 在磁盘中迭代查找 sstable 的逻辑：</p><p>level0 是可重叠的，因此迭代时，要把整个 level0 遍历一遍。而在非 level0，每层只需定位到一个 sstable 即可，如果该层查找失败，进入下一层，而这 “定位” 就是问题的关键。当要进入下一个 level 开始查找时，RocksDB 不会把遍历该 level 来查 sstable，而是通过二分查找的方式所有 sstable 的范围。</p><p>为了加速二分查找的速度，每次更新 sstable 的时候，RocksDB 都会调用 FileIndexer::UpdateIndex() 来更新一个结构，名为 FileIndexer，它主要是用来保存每一个 level 和 level+1 的 key 范围的关联信息，这样当我们在 level查找的时候，如果没有查找到信息，那么我们将会迅速得到下一个 level 需要查找的 sstable 范围。至于怎么更新的，我们先不管。每一个 key 来进行比较只会有三种情况：</p><ul><li>小于当前 sstable 的 smallest。</li><li>大于当前 sstable 的 largest。</li><li>处于这个范围。</li></ul><p>FileIndexer 维护了如下四个字段：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Point to a left most file in a lower level that may contain a key,</span><span class="token comment">// which compares greater than smallest of a FileMetaData (upper level)</span><span class="token keyword">int32_t</span> smallest_lb<span class="token punctuation">;</span><span class="token comment">// Point to a left most file in a lower level that may contain a key,</span><span class="token comment">// which compares greater than largest of a FileMetaData (upper level)</span><span class="token keyword">int32_t</span> largest_lb<span class="token punctuation">;</span><span class="token comment">// Point to a right most file in a lower level that may contain a key,</span><span class="token comment">// which compares smaller than smallest of a FileMetaData (upper level)</span><span class="token keyword">int32_t</span> smallest_rb<span class="token punctuation">;</span><span class="token comment">// Point to a right most file in a lower level that may contain a key,</span><span class="token comment">// which compares smaller than largest of a FileMetaData (upper level)</span><span class="token keyword">int32_t</span> largest_rb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方还给了例子来帮助理解，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Example:</span><span class="token comment">//    level 1:              [50 - 60]</span><span class="token comment">//    level 2:        [1 - 40], [45 - 55], [58 - 80]</span><span class="token comment">// A key 35, compared to be less than 50, 3rd file on level 2 can be</span><span class="token comment">// skipped according to rule (1). LB = 0, RB = 1.</span><span class="token comment">// A key 53, sits in the middle 50 and 60. 1st file on level 2 can be</span><span class="token comment">// skipped according to rule (2)-a, but the 3rd file cannot be skipped</span><span class="token comment">// because 60 is greater than 58. LB = 1, RB = 2.</span><span class="token comment">// A key 70, compared to be larger than 60. 1st and 2nd file can be skipped</span><span class="token comment">// according to rule (3). LB = 2, RB = 2.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 level1 的 [50, 60] 而言，其 smallest 为 50，largest 为 60。smallest_lb 指下一级中恰好包含比 smallest 大的 sstable，故为 1，即 [45, 55]。smallest_rb 指下一级中恰好包含比 smallest 小的 sstable，故为 1，即 [45, 55]。largest_lb 指下一级中恰好包含比 largest 大的 sstable，故为 2，即 [58, 80]。largest_rb 指下一级中恰好包含比 largest 小的 sstable，故为 2，即 [58, 80]。</p><p>在 level1 中查找 key 35，没有找到，且在 sstable 左边，因此需要跳到 level2 中的 0 ~ smallest_lb 中去找，即sstable0 和 sstable 1。key 53 没有找到，且在 sstable 内部，因此需要跳到 level2 的重合区间去找，故范围为 smallest_lb ~ largest_rb，即 sstable1 和 sstable 2。 key35 没找到，且在 sstable 右边，因此需要跳到 level2 中的 largest_lb ~ 右边界 中去找，即 sstable2 本身。</p><p>明白了这个 level 之间的关系之后，再来看 GetNextFile() 的实现。</p><h3 id="GetNextFile"><a href="#GetNextFile" class="headerlink" title="GetNextFile"></a>GetNextFile</h3><p>首先要明确 GetNextFile 的作用，它是一个迭代函数，每调用一次，都会返回下一个可能存在目标 key 的 sstable。用图示表明如下：</p><img src="https://s1.ax1x.com/2022/10/24/x22a6J.png" alt="sstable命中示例" style="zoom: 50%;" /><p>这也就是为什么，在 Version::Get() 中首先通过 GetNextFile() 来获取到一个可能 sstable，然后在其中查找，如果没找到就再调用一次 GetNextFile() 获取下一个可能 sstable，以此循环，直到找到目标 key 或全部 level 都找完。现在来看下该函数的具体实现，其完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">FdWithKeyRange<span class="token operator">*</span> <span class="token function">GetNextFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>search_ended_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Loops over different levels.</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>curr_index_in_curr_level_ <span class="token operator">&lt;</span> curr_file_level_<span class="token operator">-></span>num_files<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Loops over all files in current level.</span>        FdWithKeyRange<span class="token operator">*</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>curr_file_level_<span class="token operator">-></span>files<span class="token punctuation">[</span>curr_index_in_curr_level_<span class="token punctuation">]</span><span class="token punctuation">;</span>        hit_file_level_ <span class="token operator">=</span> curr_level_<span class="token punctuation">;</span>        is_hit_file_last_in_level_ <span class="token operator">=</span>            curr_index_in_curr_level_ <span class="token operator">==</span> curr_file_level_<span class="token operator">-></span>num_files <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cmp_largest <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// Do key range filtering of files or/and fractional cascading if:</span>        <span class="token comment">// (1) not all the files are in level 0, or</span>        <span class="token comment">// (2) there are more than 3 current level files</span>        <span class="token comment">// If there are only 3 or less current level files in the system, we skip</span>        <span class="token comment">// the key range filtering. In this case, more likely, the system is</span>        <span class="token comment">// highly tuned to minimize number of tables queried by each query,</span>        <span class="token comment">// so it is unlikely that key range filtering is more efficient than</span>        <span class="token comment">// querying the files.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num_levels_ <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> curr_file_level_<span class="token operator">-></span>num_files <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// Check if key is within a file's range. If search left bound and</span>          <span class="token comment">// right bound point to the same find, we are sure key falls in</span>          <span class="token comment">// range.</span>          <span class="token function">assert</span><span class="token punctuation">(</span>curr_level_ <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>                 curr_index_in_curr_level_ <span class="token operator">==</span> start_index_in_curr_level_ <span class="token operator">||</span>                 user_comparator_<span class="token operator">-></span><span class="token function">CompareWithoutTimestamp</span><span class="token punctuation">(</span>                     user_key_<span class="token punctuation">,</span> <span class="token function">ExtractUserKey</span><span class="token punctuation">(</span>f<span class="token operator">-></span>smallest_key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> cmp_smallest <span class="token operator">=</span> user_comparator_<span class="token operator">-></span><span class="token function">CompareWithoutTimestamp</span><span class="token punctuation">(</span>              user_key_<span class="token punctuation">,</span> <span class="token function">ExtractUserKey</span><span class="token punctuation">(</span>f<span class="token operator">-></span>smallest_key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_smallest <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cmp_largest <span class="token operator">=</span> user_comparator_<span class="token operator">-></span><span class="token function">CompareWithoutTimestamp</span><span class="token punctuation">(</span>                user_key_<span class="token punctuation">,</span> <span class="token function">ExtractUserKey</span><span class="token punctuation">(</span>f<span class="token operator">-></span>largest_key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token comment">// Setup file search bound for the next level based on the</span>          <span class="token comment">// comparison results</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_level_ <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            file_indexer_<span class="token operator">-></span><span class="token function">GetNextLevelIndex</span><span class="token punctuation">(</span>curr_level_<span class="token punctuation">,</span>                                            curr_index_in_curr_level_<span class="token punctuation">,</span>                                            cmp_smallest<span class="token punctuation">,</span> cmp_largest<span class="token punctuation">,</span>                                            <span class="token operator">&amp;</span>search_left_bound_<span class="token punctuation">,</span>                                            <span class="token operator">&amp;</span>search_right_bound_<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token comment">// Key falls out of current file's range</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_smallest <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> cmp_largest <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_level_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token operator">++</span>curr_index_in_curr_level_<span class="token punctuation">;</span>              <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>              <span class="token comment">// Search next level.</span>              <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        returned_file_level_ <span class="token operator">=</span> curr_level_<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_level_ <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cmp_largest <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// No more files to search in this level.</span>          search_ended_ <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">PrepareNextLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token operator">++</span>curr_index_in_curr_level_<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// Start searching next level.</span>      search_ended_ <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">PrepareNextLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Search ended.</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只考虑层数大于 1 的情况，这最普遍。首先，该函数通过 curr_index_in_curr_level_ 来获取当前查找到的 sstable，然后比较目标 key 和 smallest 以及 largest 的大小，结果存在 cmp_smallest 与 cmp_largest 中。因为在 level0 中有重叠，所以需要遍历完整个 level0，只有在 level1 及以上才会启用 FileIndexer 关系。先考虑 level0，跳过 curr_level_ &gt; 0 的判断。如果目标 key 不在 sstable 内，那就 ++curr_index_in_curr_level_ ，然后 continue，此时会进入 level0 的下一个 sstable 中重复，如果在，那么依然  ++ curr_index_in_curr_level_ ，然后返回这个 sstable，在下一次调用 GetNextFile() 的时候会进入下一个 sstable 中重复。</p><p>如果在非 level0，那么就需要先通过 file_indexer_-&gt;GetNextLevelIndex() 来定位到 level+1 中的 sstable。如果目标 key 不在当前 sstable，那么直接 break，通过 PrepareNextLevel() 来进入 level+1 中，查找点就是刚刚定位的 sstable。这里有两个注意点：</p><ul><li>file_indexer_-&gt;GetNextLevelIndex() 就是通过 FileIndexer 来进行的。</li><li>非 level0 中，判断失败立刻 break，进入下一层。说明每一层只检查<strong>一个</strong> sstable，而不是在某一个范围内遍历，这个很重要！</li></ul><h4 id="GetNextLevelIndex"><a href="#GetNextLevelIndex" class="headerlink" title="GetNextLevelIndex"></a>GetNextLevelIndex</h4><p>分点来看，首先是 GetNextLevelIndex()，其完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">FileIndexer</span><span class="token double-colon punctuation">::</span><span class="token function">GetNextLevelIndex</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t level<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t file_index<span class="token punctuation">,</span>                                    <span class="token keyword">const</span> <span class="token keyword">int</span> cmp_smallest<span class="token punctuation">,</span>                                    <span class="token keyword">const</span> <span class="token keyword">int</span> cmp_largest<span class="token punctuation">,</span> <span class="token keyword">int32_t</span><span class="token operator">*</span> left_bound<span class="token punctuation">,</span>                                    <span class="token keyword">int32_t</span><span class="token operator">*</span> right_bound<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>level <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Last level, no hint</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">==</span> num_levels_ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>left_bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">*</span>right_bound <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>level <span class="token operator">&lt;</span> num_levels_ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>file_index<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> level_rb_<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> IndexUnit<span class="token operator">*</span> index_units <span class="token operator">=</span> next_level_index_<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>index_units<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> index <span class="token operator">=</span> index_units<span class="token punctuation">[</span>file_index<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_smallest <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>left_bound <span class="token operator">=</span> <span class="token punctuation">(</span>level <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> file_index <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                      <span class="token operator">?</span> index_units<span class="token punctuation">[</span>file_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>largest_lb                      <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">*</span>right_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>smallest_rb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_smallest <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>left_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>smallest_lb<span class="token punctuation">;</span>    <span class="token operator">*</span>right_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>smallest_rb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_smallest <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cmp_largest <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>left_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>smallest_lb<span class="token punctuation">;</span>    <span class="token operator">*</span>right_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>largest_rb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_largest <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>left_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>largest_lb<span class="token punctuation">;</span>    <span class="token operator">*</span>right_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>largest_rb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_largest <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>left_bound <span class="token operator">=</span> index<span class="token punctuation">.</span>largest_lb<span class="token punctuation">;</span>    <span class="token operator">*</span>right_bound <span class="token operator">=</span> level_rb_<span class="token punctuation">[</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>left_bound <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>left_bound <span class="token operator">&lt;=</span> <span class="token operator">*</span>right_bound <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>right_bound <span class="token operator">&lt;=</span> level_rb_<span class="token punctuation">[</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑很简单，就是结合比较结果与 FileIndexer 中的四个字段，计算出 search_left_bound_ 与 search_right_bound_，即下一层的查找范围。</p><h4 id="PrepareNextLevel"><a href="#PrepareNextLevel" class="headerlink" title="PrepareNextLevel"></a>PrepareNextLevel</h4><p>这样一来，第二个注意点就出问题了。search_left_bound_  和 search_right_bound_ 明明代表的是一个范围，比如前文示例中 key 35 的下一层查找范围为 [0, 1]，但为什么在 GetNextFile() 每一层只查找一个 sstable 呢？这个问题困扰了我大概一天，甚至怀疑过是不是源码写错了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Key falls out of current file's range</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cmp_smallest <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> cmp_largest <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_level_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>curr_index_in_curr_level_<span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Search next level.</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，RocksDB 对下一个 level 中 sstable 的定位，就是直接定到其中一个。只不过它分了两步。第一步通过 FileIndexer 来确定 search_left_bound_  和 search_right_bound_ ，第二步就是在这个范围内具体定到某一个 sstable 中。而第二步的实现，就是在 PrepareNextLevel() 中，我们看一下它的源码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">PrepareNextLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    curr_level_<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr_level_ <span class="token operator">&lt;</span> num_levels_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        curr_file_level_ <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>level_files_brief_<span class="token punctuation">)</span><span class="token punctuation">[</span>curr_level_<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_file_level_<span class="token operator">-></span>num_files <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// When current level is empty, the search bound generated from upper</span>            <span class="token comment">// level must be [0, -1] or [0, FileIndexer::kLevelMaxIndex] if it is</span>            <span class="token comment">// also empty.</span>            <span class="token function">assert</span><span class="token punctuation">(</span>search_left_bound_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">assert</span><span class="token punctuation">(</span>search_right_bound_ <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span>                   search_right_bound_ <span class="token operator">==</span> FileIndexer<span class="token double-colon punctuation">::</span>kLevelMaxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Since current level is empty, it will need to search all files in</span>            <span class="token comment">// the next level</span>            search_left_bound_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            search_right_bound_ <span class="token operator">=</span> FileIndexer<span class="token double-colon punctuation">::</span>kLevelMaxIndex<span class="token punctuation">;</span>            curr_level_<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Some files may overlap each other. We find</span>        <span class="token comment">// all files that overlap user_key and process them in order from</span>        <span class="token comment">// newest to oldest. In the context of merge-operator, this can occur at</span>        <span class="token comment">// any level. Otherwise, it only occurs at Level-0 (since Put/Deletes</span>        <span class="token comment">// are always compacted into a single entry).</span>        <span class="token keyword">int32_t</span> start_index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_level_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// On Level-0, we read through all files to check for overlap.</span>            start_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// On Level-n (n>=1), files are sorted. Binary search to find the</span>            <span class="token comment">// earliest file whose largest key >= ikey. Search left bound and</span>            <span class="token comment">// right bound are used to narrow the range.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>search_left_bound_ <span class="token operator">&lt;=</span> search_right_bound_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>search_right_bound_ <span class="token operator">==</span> FileIndexer<span class="token double-colon punctuation">::</span>kLevelMaxIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    search_right_bound_ <span class="token operator">=</span>                        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>curr_file_level_<span class="token operator">-></span>num_files<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// `search_right_bound_` is an inclusive upper-bound, but since it was</span>                <span class="token comment">// determined based on user key, it is still possible the lookup key</span>                <span class="token comment">// falls to the right of `search_right_bound_`'s corresponding file.</span>                <span class="token comment">// So, pass a limit one higher, which allows us to detect this case.</span>                start_index <span class="token operator">=</span>                    <span class="token function">FindFileInRange</span><span class="token punctuation">(</span><span class="token operator">*</span>internal_comparator_<span class="token punctuation">,</span> <span class="token operator">*</span>curr_file_level_<span class="token punctuation">,</span> ikey_<span class="token punctuation">,</span>                                    <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>search_left_bound_<span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>search_right_bound_<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>start_index <span class="token operator">==</span> search_right_bound_ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// `ikey_` comes after `search_right_bound_`. The lookup key does</span>                    <span class="token comment">// not exist on this level, so let's skip this level and do a full</span>                    <span class="token comment">// binary search on the next level.</span>                    search_left_bound_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    search_right_bound_ <span class="token operator">=</span> FileIndexer<span class="token double-colon punctuation">::</span>kLevelMaxIndex<span class="token punctuation">;</span>                    curr_level_<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// search_left_bound > search_right_bound, key does not exist in</span>                <span class="token comment">// this level. Since no comparison is done in this level, it will</span>                <span class="token comment">// need to search all files in the next level.</span>                search_left_bound_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                search_right_bound_ <span class="token operator">=</span> FileIndexer<span class="token double-colon punctuation">::</span>kLevelMaxIndex<span class="token punctuation">;</span>                curr_level_<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        start_index_in_curr_level_ <span class="token operator">=</span> start_index<span class="token punctuation">;</span>        curr_index_in_curr_level_ <span class="token operator">=</span> start_index<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// curr_level_ = num_levels_. So, no more levels to search.</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数作用很明确，首先是 curr_level_ ++，指进入了下一层，其次就是通过 search_left_bound_  和 search_right_bound_  来确定 start_index，这个 start_index 就是下一层中定位的 sstable 下标。官方对其的解释如下：</p><blockquote><p>On Level-n (n&gt;=1), files are sorted. Binary search to find the earliest file whose largest key &gt;= ikey. Search left bound and right bound are used to narrow the range.</p></blockquote><p>意思是，startIndex 就是最早的满足 largest &gt;= 目标 key 的 sstable 下标，其由如下代码块确定：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">start_index <span class="token operator">=</span>    <span class="token function">FindFileInRange</span><span class="token punctuation">(</span><span class="token operator">*</span>internal_comparator_<span class="token punctuation">,</span> <span class="token operator">*</span>curr_file_level_<span class="token punctuation">,</span> ikey_<span class="token punctuation">,</span>                    <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>search_left_bound_<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>search_right_bound_<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>进入该函数看一看，源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Find File in LevelFilesBrief data structure</span><span class="token comment">// Within an index range defined by left and right</span><span class="token keyword">int</span> <span class="token function">FindFileInRange</span><span class="token punctuation">(</span><span class="token keyword">const</span> InternalKeyComparator<span class="token operator">&amp;</span> icmp<span class="token punctuation">,</span>    <span class="token keyword">const</span> LevelFilesBrief<span class="token operator">&amp;</span> file_level<span class="token punctuation">,</span>    <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>    <span class="token keyword">uint32_t</span> left<span class="token punctuation">,</span>    <span class="token keyword">uint32_t</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> FdWithKeyRange<span class="token operator">&amp;</span> f<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> k<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> icmp<span class="token punctuation">.</span><span class="token class-name">InternalKeyComparator</span><span class="token double-colon punctuation">::</span><span class="token function">Compare</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>largest_key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> file_level<span class="token punctuation">.</span>files<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>b <span class="token operator">+</span> left<span class="token punctuation">,</span>                                           b <span class="token operator">+</span> right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span> <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就很明确了，该函数其实就是个 lower_bound，核心是比较器。可以看出，比较器会将 sstable 中的 largest 与目标 key 来进行比较，小于在返回 true。故该函数就是返回最早的满足 largest &gt;= 目标 key 的 sstable 下标。仍然拿官方的列子来看：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Example:</span><span class="token comment">//    level 1:              [50 - 60]</span><span class="token comment">//    level 2:        [1 - 40], [45 - 55], [58 - 80]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>level1 查找完 key 35 时，level2 对应范围为 [0，1]，但显然 35 只可能落在 [1 - 40] 中，因为它是最早的满足 largeset &gt;=  35 的 sstable，所以 start_index 为 0，[45 - 55] 就没必要去搜索了 。level1 查找完 key 53 时，level2 对应范围为 [1，2]，但显然 53 只可能落在 [45 - 55] 中，理由同上，故 stat_index 为 1。</p><p>至此就是解释了第二个注意点的问题了，因为 PrepareNextLevel() 会直接定位到 level+1 中一个具体的 sstable 上，而不是一个范围，所以每一层只检查一个 sstable 就行。</p><h2 id="TableCache"><a href="#TableCache" class="headerlink" title="TableCache"></a>TableCache</h2><p>当 FilePicker 找到一个 sstable 后，RocksDB 会调用 TableCache::Get() 来在这个 sstable 中查找，并把一些信息保存在 get_context 中·</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">*</span>status <span class="token operator">=</span> table_cache_<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>    read_options<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token function">internal_comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>f<span class="token operator">-></span>file_metadata<span class="token punctuation">,</span> ikey<span class="token punctuation">,</span>    <span class="token operator">&amp;</span>get_context<span class="token punctuation">,</span> mutable_cf_options_<span class="token punctuation">.</span>prefix_extractor<span class="token punctuation">,</span>    cfd_<span class="token operator">-></span><span class="token function">internal_stats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetFileReadHist</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span><span class="token function">GetHitFileLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">IsFilterSkipped</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span><span class="token function">GetHitFileLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    fp<span class="token punctuation">.</span><span class="token function">IsHitFileLastInLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    fp<span class="token punctuation">.</span><span class="token function">GetHitFileLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> max_file_size_for_l0_meta_pin_<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当返回后，通过 get_context 来判断返回的结果是否符合预期。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>get_context<span class="token punctuation">.</span><span class="token function">State</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kNotFound<span class="token operator">:</span>    <span class="token comment">// Keep searching in other files</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kMerge<span class="token operator">:</span>    <span class="token comment">// TODO: update per-level perfcontext user_key_return_count for kMerge</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kFound<span class="token operator">:</span>    <span class="token comment">// ... 主要在这</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kDeleted<span class="token operator">:</span>    <span class="token operator">*</span>status <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">NotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kCorrupt<span class="token operator">:</span>    <span class="token operator">*</span>status <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">Corruption</span><span class="token punctuation">(</span><span class="token string">"corrupted key for "</span><span class="token punctuation">,</span> user_key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kUnexpectedBlobIndex<span class="token operator">:</span>    <span class="token function">ROCKS_LOG_ERROR</span><span class="token punctuation">(</span>info_log_<span class="token punctuation">,</span> <span class="token string">"Encounter unexpected blob index."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>status <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">NotSupported</span><span class="token punctuation">(</span>        <span class="token string">"Encounter unexpected blob index. Please open DB with "</span>        <span class="token string">"ROCKSDB_NAMESPACE::blob_db::BlobDB instead."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> GetContext<span class="token double-colon punctuation">::</span>kUnexpectedWideColumnEntity<span class="token operator">:</span>    <span class="token operator">*</span>status <span class="token operator">=</span>        <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">NotSupported</span><span class="token punctuation">(</span><span class="token string">"Encountered unexpected wide-column entity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不符合预期，那么会重新调用 GetNextLevelIndex() 重复上述过程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">f <span class="token operator">=</span> fp<span class="token punctuation">.</span><span class="token function">GetNextFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，我们进入最核心的 TableCache::Get()，该函数的主要工作为两点：</p><ul><li>cache 相关的信息，分为两个 cache：<ul><li>row_cache，用来 cache &lt;key, vlaue&gt;</li><li>table_cache，用来 cache &lt;key，sstable&gt;</li></ul></li><li>从 sstable 中查找目标 key。</li></ul><p>我们源码中主要的部分，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">TableCache</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> options<span class="token punctuation">,</span>    <span class="token keyword">const</span> InternalKeyComparator<span class="token operator">&amp;</span> internal_comparator<span class="token punctuation">,</span>    <span class="token keyword">const</span> FileMetaData<span class="token operator">&amp;</span> file_meta<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> k<span class="token punctuation">,</span> GetContext<span class="token operator">*</span> get_context<span class="token punctuation">,</span>    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> SliceTransform<span class="token operator">></span><span class="token operator">&amp;</span> prefix_extractor<span class="token punctuation">,</span>    HistogramImpl<span class="token operator">*</span> file_read_hist<span class="token punctuation">,</span> <span class="token keyword">bool</span> skip_filters<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span>    size_t max_file_size_for_l0_meta_pin<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token comment">// Check row cache if enabled. Since row cache does not currently store</span>  <span class="token comment">// sequence numbers, we cannot use it if we need to fetch the sequence.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ioptions_<span class="token punctuation">.</span>row_cache <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>get_context<span class="token operator">-></span><span class="token function">NeedToReadSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> user_key <span class="token operator">=</span> <span class="token function">ExtractUserKey</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CreateRowCacheKeyPrefix</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> k<span class="token punctuation">,</span> get_context<span class="token punctuation">,</span> row_cache_key<span class="token punctuation">)</span><span class="token punctuation">;</span>    done <span class="token operator">=</span> <span class="token function">GetFromRowCache</span><span class="token punctuation">(</span>user_key<span class="token punctuation">,</span> row_cache_key<span class="token punctuation">,</span> row_cache_key<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                           get_context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      row_cache_entry <span class="token operator">=</span> <span class="token operator">&amp;</span>row_cache_entry_buffer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span>  Status s<span class="token punctuation">;</span>  TableReader<span class="token operator">*</span> t <span class="token operator">=</span> fd<span class="token punctuation">.</span>table_reader<span class="token punctuation">;</span>  Cache<span class="token double-colon punctuation">::</span>Handle<span class="token operator">*</span> handle <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      s <span class="token operator">=</span> <span class="token function">FindTable</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> file_options_<span class="token punctuation">,</span> internal_comparator<span class="token punctuation">,</span> file_meta<span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>handle<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">,</span>                    options<span class="token punctuation">.</span>read_tier <span class="token operator">==</span> kBlockCacheTier <span class="token comment">/* no_io */</span><span class="token punctuation">,</span>                    <span class="token boolean">true</span> <span class="token comment">/* record_read_stats */</span><span class="token punctuation">,</span> file_read_hist<span class="token punctuation">,</span> skip_filters<span class="token punctuation">,</span>                    level<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* prefetch_index_and_filter_in_cache */</span><span class="token punctuation">,</span>                    max_file_size_for_l0_meta_pin<span class="token punctuation">,</span> file_meta<span class="token punctuation">.</span>temperature<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        t <span class="token operator">=</span> <span class="token function">GetTableReaderFromHandle</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      get_context<span class="token operator">-></span><span class="token function">SetReplayLog</span><span class="token punctuation">(</span>row_cache_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// nullptr if no cache.</span>      s <span class="token operator">=</span> t<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> k<span class="token punctuation">,</span> get_context<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> skip_filters<span class="token punctuation">)</span><span class="token punctuation">;</span>      get_context<span class="token operator">-></span><span class="token function">SetReplayLog</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// Put the replay log in row cache only if something was found.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> row_cache_entry <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>row_cache_entry<span class="token operator">-></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    size_t charge <span class="token operator">=</span> row_cache_entry<span class="token operator">-></span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> row_ptr <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>row_cache_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// If row cache is full, it's OK to continue.</span>    ioptions_<span class="token punctuation">.</span>row_cache        <span class="token operator">-></span><span class="token function">Insert</span><span class="token punctuation">(</span>row_cache_key<span class="token punctuation">.</span><span class="token function">GetUserKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row_ptr<span class="token punctuation">,</span> charge<span class="token punctuation">,</span>                 <span class="token operator">&amp;</span>DeleteEntry<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">PermitUncheckedError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，它会判断 row_cache 是否打开，如果打开，则会在 row_cache 中进行一次查找，并把查找结果记录在 get_context 中。在进入 row_cache 前，会先将 key 包装成 row_cache 中形式的 key。通过下面的代码我们可以看到 row_cache 的 key 就是 fd_number+seq_no+user_key。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TableCache</span><span class="token double-colon punctuation">::</span><span class="token function">CreateRowCacheKeyPrefix</span><span class="token punctuation">(</span><span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> options<span class="token punctuation">,</span>                                         <span class="token keyword">const</span> FileDescriptor<span class="token operator">&amp;</span> fd<span class="token punctuation">,</span>                                         <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> internal_key<span class="token punctuation">,</span>                                         GetContext<span class="token operator">*</span> get_context<span class="token punctuation">,</span>                                         IterKey<span class="token operator">&amp;</span> row_cache_key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token comment">// Compute row cache key.</span>  row_cache_key<span class="token punctuation">.</span><span class="token function">TrimAppend</span><span class="token punctuation">(</span>row_cache_key<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row_cache_id_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                           row_cache_id_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">AppendVarint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>row_cache_key<span class="token punctuation">,</span> fd_number<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">AppendVarint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>row_cache_key<span class="token punctuation">,</span> seq_no<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">TableCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetFromRowCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> user_key<span class="token punctuation">,</span> IterKey<span class="token operator">&amp;</span> row_cache_key<span class="token punctuation">,</span>                                 size_t prefix_size<span class="token punctuation">,</span> GetContext<span class="token operator">*</span> get_context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  row_cache_key<span class="token punctuation">.</span><span class="token function">TrimAppend</span><span class="token punctuation">(</span>prefix_size<span class="token punctuation">,</span> user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GetFromRowCache() 的具体实现我们先不分析。如果在 row_cache 中找到，那么 done 就是 true，后面的查找就全部跳过。如果没有找到，那么就会进入 sstable 中查找。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TableReader<span class="token operator">*</span> t <span class="token operator">=</span> fd<span class="token punctuation">.</span>table_reader<span class="token punctuation">;</span><span class="token comment">// ...</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    get_context<span class="token operator">-></span><span class="token function">SetReplayLog</span><span class="token punctuation">(</span>row_cache_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// nullptr if no cache.</span>    s <span class="token operator">=</span> t<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> k<span class="token punctuation">,</span> get_context<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> skip_filters<span class="token punctuation">)</span><span class="token punctuation">;</span>    get_context<span class="token operator">-></span><span class="token function">SetReplayLog</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分析函数之前，我们先分析一下 sstable 的结构，一个 sstable 对应一个 FileMetaData，类的主要成员如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">FileMetaData</span> <span class="token punctuation">&#123;</span>  FileDescriptor fd<span class="token punctuation">;</span>  InternalKey smallest<span class="token punctuation">;</span>            <span class="token comment">// Smallest internal key served by table</span>  InternalKey largest<span class="token punctuation">;</span>             <span class="token comment">// Largest internal key served by table</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，smallest 和 largest 就是 sstable 的两个边界 key。主要来看一下成员 fd：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// A copyable structure contains information needed to read data from an SST</span><span class="token comment">// file. It can contain a pointer to a table reader opened for the file, or</span><span class="token comment">// file number and size, which can be used to create a new table reader for it.</span><span class="token comment">// The behavior is undefined when a copied of the structure is used when the</span><span class="token comment">// file is not in any live version any more.</span><span class="token keyword">struct</span> <span class="token class-name">FileDescriptor</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Table reader in table_reader_handle</span>  TableReader<span class="token operator">*</span> table_reader<span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> packed_number_and_path_id<span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> file_size<span class="token punctuation">;</span>  <span class="token comment">// File size in bytes</span>  SequenceNumber smallest_seqno<span class="token punctuation">;</span>  <span class="token comment">// The smallest seqno in this file</span>  SequenceNumber largest_seqno<span class="token punctuation">;</span>   <span class="token comment">// The largest seqno in this file</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如注释所述，该结构记录了 sstable 的信息，比如大小、seq 范围等等。但最重要的就是 TableReader，它才是 sstable 的核心数据结构，所有的读取均在其中进行。官方解释如下：</p><blockquote><p>A Table (also referred to as SST) is a sorted map from strings to strings. Tables are immutable and persistent.  A Table may be safely accessed from multiple threads without external synchronization. Table readers are used for reading various types of table formats supported by rocksdb including BlockBasedTable, PlainTable and CuckooTable format.</p></blockquote><p>也即，TableReader 实际上是一个抽象类，RocksDB 有多个不同的 sstable 实现，每一个 TableReader 的派生类都是一种实现，包括 BlockBasedTable、CuckooTable、MockTable、PlainTable 这四种。</p><p><img src="https://s1.ax1x.com/2022/10/24/x27w8I.png" alt="TableReader派生类"></p><p>RocksDB 默认采用的数据结构为 BlockBasedTable，这也是大部分资料都在讨论的基于 block 的 sstable，那我们就只关注它，其余实现都不看。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Create default block based table factory.</span><span class="token keyword">extern</span> TableFactory<span class="token operator">*</span> <span class="token function">NewBlockBasedTableFactory</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> BlockBasedTableOptions<span class="token operator">&amp;</span> table_options <span class="token operator">=</span> <span class="token function">BlockBasedTableOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个结构的实现这里就不讨论了。针对该结构我曾做过一篇简要博客：<a href="https://yesiyuan.cn/sstable-jie-shao/">sstable 简要分析</a>，不过那一篇没有进入源码层面，后面我会另出一篇对 sstable 源码进行详细分析：<a href="xxxx">sstable实现—BlockBasedTable （待填坑</a></p><p>在 row_cahce 中读取失败后，会拿到 sstable 的 TableReader，如果为空，那么就会在 table_cache 中找。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TableReader<span class="token operator">*</span> t <span class="token operator">=</span> fd<span class="token punctuation">.</span>table_reader<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> <span class="token function">FindTable</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> file_options_<span class="token punctuation">,</span> internal_comparator<span class="token punctuation">,</span> file_meta<span class="token punctuation">,</span>                  <span class="token operator">&amp;</span>handle<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">,</span>                  options<span class="token punctuation">.</span>read_tier <span class="token operator">==</span> kBlockCacheTier <span class="token comment">/* no_io */</span><span class="token punctuation">,</span>                  <span class="token boolean">true</span> <span class="token comment">/* record_read_stats */</span><span class="token punctuation">,</span> file_read_hist<span class="token punctuation">,</span> skip_filters<span class="token punctuation">,</span>                  level<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* prefetch_index_and_filter_in_cache */</span><span class="token punctuation">,</span>                  max_file_size_for_l0_meta_pin<span class="token punctuation">,</span> file_meta<span class="token punctuation">.</span>temperature<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TableCache::FindTable 的主要源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">TableCache</span><span class="token double-colon punctuation">::</span><span class="token function">FindTable</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> ro<span class="token punctuation">,</span> <span class="token keyword">const</span> FileOptions<span class="token operator">&amp;</span> file_options<span class="token punctuation">,</span>    <span class="token keyword">const</span> InternalKeyComparator<span class="token operator">&amp;</span> internal_comparator<span class="token punctuation">,</span>    <span class="token keyword">const</span> FileMetaData<span class="token operator">&amp;</span> file_meta<span class="token punctuation">,</span> Cache<span class="token double-colon punctuation">::</span>Handle<span class="token operator">*</span><span class="token operator">*</span> handle<span class="token punctuation">,</span>    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> SliceTransform<span class="token operator">></span><span class="token operator">&amp;</span> prefix_extractor<span class="token punctuation">,</span>    <span class="token keyword">const</span> <span class="token keyword">bool</span> no_io<span class="token punctuation">,</span> <span class="token keyword">bool</span> record_read_stats<span class="token punctuation">,</span> HistogramImpl<span class="token operator">*</span> file_read_hist<span class="token punctuation">,</span>    <span class="token keyword">bool</span> skip_filters<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">bool</span> prefetch_index_and_filter_in_cache<span class="token punctuation">,</span>    size_t max_file_size_for_l0_meta_pin<span class="token punctuation">,</span> Temperature file_temperature<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>TableReader<span class="token operator">></span> table_reader<span class="token punctuation">;</span>    Status s <span class="token operator">=</span>        <span class="token function">GetTableReader</span><span class="token punctuation">(</span>ro<span class="token punctuation">,</span> file_options<span class="token punctuation">,</span> internal_comparator<span class="token punctuation">,</span> file_meta<span class="token punctuation">,</span>                       <span class="token boolean">false</span> <span class="token comment">/* sequential mode */</span><span class="token punctuation">,</span> record_read_stats<span class="token punctuation">,</span>                       file_read_hist<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table_reader<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">,</span>                       skip_filters<span class="token punctuation">,</span> level<span class="token punctuation">,</span> prefetch_index_and_filter_in_cache<span class="token punctuation">,</span>                       max_file_size_for_l0_meta_pin<span class="token punctuation">,</span> file_temperature<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>table_reader <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">RecordTick</span><span class="token punctuation">(</span>ioptions_<span class="token punctuation">.</span>stats<span class="token punctuation">,</span> NO_FILE_ERRORS<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// We do not cache error results so that if the error is transient,</span>      <span class="token comment">// or somebody repairs the file, we recover automatically.</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      s <span class="token operator">=</span> cache_<span class="token operator">-></span><span class="token function">Insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> table_reader<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>DeleteEntry<span class="token operator">&lt;</span>TableReader<span class="token operator">></span><span class="token punctuation">,</span>                         handle<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Release ownership of table reader.</span>        table_reader<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑很简单，就是一般的 cache 逻辑，读取然后判断是否存在，不存在则创建一个插入 cache。上面的函数会调用 TableCache::GetTableReader()，我们来简单看下这个函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">TableCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetTableReader</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> ro<span class="token punctuation">,</span> <span class="token keyword">const</span> FileOptions<span class="token operator">&amp;</span> file_options<span class="token punctuation">,</span>    <span class="token keyword">const</span> InternalKeyComparator<span class="token operator">&amp;</span> internal_comparator<span class="token punctuation">,</span>    <span class="token keyword">const</span> FileMetaData<span class="token operator">&amp;</span> file_meta<span class="token punctuation">,</span> <span class="token keyword">bool</span> sequential_mode<span class="token punctuation">,</span> <span class="token keyword">bool</span> record_read_stats<span class="token punctuation">,</span>    HistogramImpl<span class="token operator">*</span> file_read_hist<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>TableReader<span class="token operator">></span><span class="token operator">*</span> table_reader<span class="token punctuation">,</span>    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> SliceTransform<span class="token operator">></span><span class="token operator">&amp;</span> prefix_extractor<span class="token punctuation">,</span>    <span class="token keyword">bool</span> skip_filters<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">bool</span> prefetch_index_and_filter_in_cache<span class="token punctuation">,</span>    size_t max_file_size_for_l0_meta_pin<span class="token punctuation">,</span> Temperature file_temperature<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    s <span class="token operator">=</span> ioptions_<span class="token punctuation">.</span>table_factory<span class="token operator">-></span><span class="token function">NewTableReader</span><span class="token punctuation">(</span>        ro<span class="token punctuation">,</span>        <span class="token function">TableReaderOptions</span><span class="token punctuation">(</span>ioptions_<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">,</span> file_options<span class="token punctuation">,</span>                           internal_comparator<span class="token punctuation">,</span> skip_filters<span class="token punctuation">,</span> immortal_tables_<span class="token punctuation">,</span>                           <span class="token boolean">false</span> <span class="token comment">/* force_direct_prefetch */</span><span class="token punctuation">,</span> level<span class="token punctuation">,</span>                           block_cache_tracer_<span class="token punctuation">,</span> max_file_size_for_l0_meta_pin<span class="token punctuation">,</span>                           db_session_id_<span class="token punctuation">,</span> file_meta<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">GetNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                           expected_unique_id<span class="token punctuation">,</span> file_meta<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>largest_seqno<span class="token punctuation">)</span><span class="token punctuation">,</span>        std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>file_reader<span class="token punctuation">)</span><span class="token punctuation">,</span> file_meta<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">GetFileSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> table_reader<span class="token punctuation">,</span>        prefetch_index_and_filter_in_cache<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即，通过相关的参数创建了一个 TableReader。该函数的具体实现先不深入分析，重新回到 TableCache::Get() 中。当获取到 TableReader 中后，RocksDB 就要在其中查找目标 key 了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  get_context<span class="token operator">-></span><span class="token function">SetReplayLog</span><span class="token punctuation">(</span>row_cache_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// nullptr if no cache.</span>  s <span class="token operator">=</span> t<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> k<span class="token punctuation">,</span> get_context<span class="token punctuation">,</span> prefix_extractor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> skip_filters<span class="token punctuation">)</span><span class="token punctuation">;</span>  get_context<span class="token operator">-></span><span class="token function">SetReplayLog</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>read_tier <span class="token operator">==</span> kBlockCacheTier <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">IsIncomplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Couldn't find Table in cache but treat as kFound if no_io set</span>  get_context<span class="token operator">-></span><span class="token function">MarkKeyMayExist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找的入口就是 TableReader::Get()，其也是一个抽象，不同的 sstable 数据结构对其的实现方式均不一样。</p><p><img src="https://s1.ax1x.com/2022/10/24/x2bju6.png" alt="TableReader::Get()"></p><p>当然，默认的就是 BlockBasedTable::Get()，这里我们就不深入了，放在对 sstable 单独分析的那篇博客中讲：<a href="xxxx">sstable实现—BlockBasedTable （待填坑</a></p><p>当从 sstable 中找到后，将会把 &lt;key, value&gt; 缓存进 row_cache 中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> row_cache_entry <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>row_cache_entry<span class="token operator">-></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  size_t charge <span class="token operator">=</span> row_cache_entry<span class="token operator">-></span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span><span class="token operator">*</span> row_ptr <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>row_cache_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// If row cache is full, it's OK to continue.</span>  ioptions_<span class="token punctuation">.</span>row_cache      <span class="token operator">-></span><span class="token function">Insert</span><span class="token punctuation">(</span>row_cache_key<span class="token punctuation">.</span><span class="token function">GetUserKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row_ptr<span class="token punctuation">,</span> charge<span class="token punctuation">,</span>               <span class="token operator">&amp;</span>DeleteEntry<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">PermitUncheckedError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>至此，从 sstable 中的读流程分析完毕，意味着 RocksDB 的整个读流程分析完毕。虽然忽略了一些重要实现，但它们会在后续对数据结构的专讲中详细说明。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(三): 读(二)</title>
      <link href="/rocksdb-yuan-ma-xue-xi-san-du-er/"/>
      <url>/rocksdb-yuan-ma-xue-xi-san-du-er/</url>
      
        <content type="html"><![CDATA[<p>本篇博客关注 RocksDB 从 immutable memtable 中的读取，所有代码版本均为 <code>v7.7.3</code>。</p><p>在 Rocksdb 中，memtable 和 immutable memtable 都位于内存，且它俩是一样的数据结构，唯一的区别是memtable 可读可写，而 immutable memtable 是只读的，不允许写入。写入从 writebatch 提交后，会进入 memtable，一旦一个 memtable 写满了，那么它就会转化成一个 immutable memtable，作为向 sstable 转换的过度态，然后生成一个新的空 memtable。</p><p>Rocksdb 引入了 CF 的概念，在一个 CF 中只有一个 memtable，但允许存在多个 immutable memtable。当从 memtable 中没读到时，就会尝试在这些 immutable memtable 中读。</p><hr><p>从上一篇博客，读操作从 DBImpl::GetImpl() 开始依次从不同的部分读取，所以这里的分析如果依旧是  DBImpl::GetImpl()。截取部分代码，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">GetImpl</span><span class="token punctuation">(</span><span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> read_options<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                       GetImplOptions<span class="token operator">&amp;</span> get_impl_options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ....</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>get_impl_options<span class="token punctuation">.</span>get_value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sv<span class="token operator">-></span>mem<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>              lkey<span class="token punctuation">,</span>              get_impl_options<span class="token punctuation">.</span>value <span class="token operator">?</span> get_impl_options<span class="token punctuation">.</span>value<span class="token operator">-></span><span class="token function">GetSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                     <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>              get_impl_options<span class="token punctuation">.</span>columns<span class="token punctuation">,</span> timestamp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>merge_context<span class="token punctuation">,</span>              <span class="token operator">&amp;</span>max_covering_tombstone_seq<span class="token punctuation">,</span> read_options<span class="token punctuation">,</span>              <span class="token boolean">false</span> <span class="token comment">/* immutable_memtable */</span><span class="token punctuation">,</span> get_impl_options<span class="token punctuation">.</span>callback<span class="token punctuation">,</span>              get_impl_options<span class="token punctuation">.</span>is_blob_index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>get_impl_options<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          get_impl_options<span class="token punctuation">.</span>value<span class="token operator">-></span><span class="token function">PinSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">RecordTick</span><span class="token punctuation">(</span>stats_<span class="token punctuation">,</span> MEMTABLE_HIT<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">IsMergeInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                 sv<span class="token operator">-></span>imm<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>lkey<span class="token punctuation">,</span>                              get_impl_options<span class="token punctuation">.</span>value                                  <span class="token operator">?</span> get_impl_options<span class="token punctuation">.</span>value<span class="token operator">-></span><span class="token function">GetSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                  <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>                              get_impl_options<span class="token punctuation">.</span>columns<span class="token punctuation">,</span> timestamp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span>                              <span class="token operator">&amp;</span>merge_context<span class="token punctuation">,</span> <span class="token operator">&amp;</span>max_covering_tombstone_seq<span class="token punctuation">,</span>                              read_options<span class="token punctuation">,</span> get_impl_options<span class="token punctuation">.</span>callback<span class="token punctuation">,</span>                              get_impl_options<span class="token punctuation">.</span>is_blob_index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>get_impl_options<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          get_impl_options<span class="token punctuation">.</span>value<span class="token operator">-></span><span class="token function">PinSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">RecordTick</span><span class="token punctuation">(</span>stats_<span class="token punctuation">,</span> MEMTABLE_HIT<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码的前半部分就是上一篇博客的入口，即 MemTable::Get()。而如果没有找到，则会调用 sv-&gt;imm-&gt;Get()，开始从 immutable memtable 中读取。实际上，这个 imm 并不是一个 immutable memtable，而是多个 immutable memtable 组成的一个链表，因为 RocksDB 中一个 CF 允许多个 immutable memetable 存在。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MemTableListVersion<span class="token operator">*</span> imm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MemTableListVersion</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ...</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// Immutable MemTables that have not yet been flushed.</span>  std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>MemTable<span class="token operator">*</span><span class="token operator">></span> memlist_<span class="token punctuation">;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出来，immutable memtable 和 memtable 是一个数据结构，所以 imm 可以被看为一个由只读 memtable 组成的链表。</p><p>sv-&gt;imm-&gt;Get() 实际上调用的是 MemTableListVersion::Get()，其完整代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Search all the memtables starting from the most recent one.</span><span class="token comment">// Return the most recent value found, if any.</span><span class="token comment">// Operands stores the list of merge operations to apply, so far.</span><span class="token keyword">bool</span> <span class="token class-name">MemTableListVersion</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> value<span class="token punctuation">,</span>                              PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">,</span>                              std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">,</span> Status<span class="token operator">*</span> s<span class="token punctuation">,</span>                              MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">,</span>                              SequenceNumber<span class="token operator">*</span> max_covering_tombstone_seq<span class="token punctuation">,</span>                              SequenceNumber<span class="token operator">*</span> seq<span class="token punctuation">,</span> <span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> read_opts<span class="token punctuation">,</span>                              ReadCallback<span class="token operator">*</span> callback<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">*</span> is_blob_index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">GetFromList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memlist_<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> timestamp<span class="token punctuation">,</span> s<span class="token punctuation">,</span>                     merge_context<span class="token punctuation">,</span> max_covering_tombstone_seq<span class="token punctuation">,</span> seq<span class="token punctuation">,</span> read_opts<span class="token punctuation">,</span>                     callback<span class="token punctuation">,</span> is_blob_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GetFromList() 的第一个参数为 memlist_，也就是 immutable memtable 组成的链表。该函数完整源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">MemTableListVersion</span><span class="token double-colon punctuation">::</span><span class="token function">GetFromList</span><span class="token punctuation">(</span>    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>MemTable<span class="token operator">*</span><span class="token operator">></span><span class="token operator">*</span> list<span class="token punctuation">,</span> <span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> value<span class="token punctuation">,</span>    PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">,</span> Status<span class="token operator">*</span> s<span class="token punctuation">,</span>    MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">,</span> SequenceNumber<span class="token operator">*</span> max_covering_tombstone_seq<span class="token punctuation">,</span>    SequenceNumber<span class="token operator">*</span> seq<span class="token punctuation">,</span> <span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> read_opts<span class="token punctuation">,</span> ReadCallback<span class="token operator">*</span> callback<span class="token punctuation">,</span>    <span class="token keyword">bool</span><span class="token operator">*</span> is_blob_index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">*</span>seq <span class="token operator">=</span> kMaxSequenceNumber<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> memtable <span class="token operator">:</span> <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>memtable<span class="token operator">-></span><span class="token function">IsFragmentedRangeTombstonesConstructed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SequenceNumber current_seq <span class="token operator">=</span> kMaxSequenceNumber<span class="token punctuation">;</span>    <span class="token keyword">bool</span> done <span class="token operator">=</span>        memtable<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> timestamp<span class="token punctuation">,</span> s<span class="token punctuation">,</span> merge_context<span class="token punctuation">,</span>                      max_covering_tombstone_seq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>current_seq<span class="token punctuation">,</span> read_opts<span class="token punctuation">,</span>                      <span class="token boolean">true</span> <span class="token comment">/* immutable_memtable */</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> is_blob_index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>seq <span class="token operator">==</span> kMaxSequenceNumber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Store the most recent sequence number of any operation on this key.</span>      <span class="token comment">// Since we only care about the most recent change, we only need to</span>      <span class="token comment">// return the first operation found when searching memtables in</span>      <span class="token comment">// reverse-chronological order.</span>      <span class="token comment">// current_seq would be equal to kMaxSequenceNumber if the value was to be</span>      <span class="token comment">// skipped. This allows seq to be assigned again when the next value is</span>      <span class="token comment">// read.</span>      <span class="token operator">*</span>seq <span class="token operator">=</span> current_seq<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>seq <span class="token operator">!=</span> kMaxSequenceNumber <span class="token operator">||</span> s<span class="token operator">-></span><span class="token function">IsNotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>s<span class="token operator">-></span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>s<span class="token operator">-></span><span class="token function">IsMergeInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>s<span class="token operator">-></span><span class="token function">IsNotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该函数就是遍历链表，从每一个 immutable memtable 中调用 MemTable::Get()，一旦读取成功就返回。MemTable::Get() 就是上一篇博客分析的从 memtable 中读取，因此从 immutable memtable 中读和从 memtable 中读完全一致。</p><hr><p>至此，在内存中的读取操作已经分析完毕，下一篇博客将分析从磁盘 sstable 中的读取。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(二): 读(一)</title>
      <link href="/rocksdb-yuan-ma-xue-xi-er-du-yi/"/>
      <url>/rocksdb-yuan-ma-xue-xi-er-du-yi/</url>
      
        <content type="html"><![CDATA[<p>注：本篇博客所用代码版本均为 <code>v7.7.3</code>。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RocksDB 的所有对记录 delete 和 update 操作，都不是就地删或者就地更新，而是新增一个记录表示这个操作，而这个记录也是一个 &lt;k, v&gt;，和其他所有的 &lt;k, v&gt; 按照同样的方式存储。看完 <a href="https://yesiyuan.cn/">RocksDB源码学习(一)</a> 那一章就知道，key 实际上是存在 user_key =&gt; internal_key =&gt; memetable_key 这一个转化过程的，从 internl_key 开始，就可以通过 valueType 部分区分出这个 &lt;k, v&gt; 具体是什么操作类型，是插入、删除、更新还是别的什么。很直观的来看，我们只需要读取插入和更新的 &lt;k, v&gt;，删除的 &lt;k, v&gt; 就不用管了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">ValueType</span> <span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token punctuation">&#123;</span>  kTypeDeletion <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">,</span>  kTypeValue <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">,</span>  <span class="token comment">// 这个就是 put，表示插入或更新，即这个值是要读的</span>  kTypeMerge <span class="token operator">=</span> <span class="token number">0x2</span><span class="token punctuation">,</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同一个 key 通过 sequence num 区分不同记录的时间先后，就像一个时间戳一样。而我们的读操作，实际上就是如何读到一个 key 最新的记录，而且是带数据的记录。RocksDB中，数据是保存在两个地方，一个是 memtable（内存），一个是 sstable（磁盘），RocksDB 读数据也是主要从这两个地方读取。</p><ul><li><p><strong>writebatch</strong>：如果仍有 writebatch 还没有 commit，那么就先在这读，没读到在进入 DB 中读取。</p></li><li><p><strong>memtable</strong>：在 RocksDB 中 memtable 的默认实现是 skiplist，RocksDB 会将用户传入的 user_key 改变为memtable 内部的 key（internal_key_size+internal_key），然后再加上用户传入的 value 之后，作为一个element 加入到 skiplist，而我们读取的时候需要读取到最新的那条数据。</p></li><li><p><strong>immutable memtable</strong>：一旦一个 memtable 被写满，它就会转为 immutable memtable，用来作为向 sstable 过渡的中间态，然后被替换为一个新的 memtable。immutable memtable 和 memtable 的数据结构完全一致，只是前者只能读不能写，且一个 CF 只能有一个 memtable，但可以有多个 immutable memtable。当从 memtable 中没读到时，就会尝试在这些 immutable memtable 中读。</p></li><li><p><strong>sstable</strong>：如果上面三者都没读到，则开始从磁盘中读。除 L0 层之外，记录在每一层中有序，排序的依据依次是 user_key 升序，sequence num 降序，type 降序。除 L0 层之外，每一层中的各 sstable 所存储的 key 范围不会重叠，但 L0 层可能出现重叠。因此，在 L0 需要读取所有 sstable，在其他层只要读到一个就行。</p></li></ul><p>本篇博客分析读操作的框架以及在 memtable 中的读取，着急看结论可以直接跳到最后一张图。</p><hr><h3 id="从-GetImpl-开始分析"><a href="#从-GetImpl-开始分析" class="headerlink" title="从 GetImpl 开始分析"></a>从 GetImpl 开始分析</h3><p>我们知道，用户显示传入的 key 只是 user_key，它需要先被转换为 internal_key，其格式有两种，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">user_key <span class="token operator">+</span> sequence <span class="token operator">+</span> type<span class="token punctuation">;</span><span class="token punctuation">(</span>user_key <span class="token operator">+</span> ts<span class="token punctuation">)</span> <span class="token operator">+</span> sequence <span class="token operator">+</span> type<span class="token punctuation">;</span> <span class="token comment">// (since v6.6.4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>转换函数为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">InternalKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber s<span class="token punctuation">,</span> ValueType t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">AppendInternalKey</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rep_<span class="token punctuation">,</span> <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span>_user_key<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">InternalKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber s<span class="token punctuation">,</span> ValueType t<span class="token punctuation">,</span> Slice ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">AppendInternalKeyWithDifferentTimestamp</span><span class="token punctuation">(</span>        <span class="token operator">&amp;</span>rep_<span class="token punctuation">,</span> <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span>_user_key<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">AppendInternalKey</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> result<span class="token punctuation">,</span> <span class="token keyword">const</span> ParsedInternalKey<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    result<span class="token operator">-></span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PutFixed64</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">PackSequenceAndType</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> key<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">AppendInternalKeyWithDifferentTimestamp</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> result<span class="token punctuation">,</span>                                             <span class="token keyword">const</span> ParsedInternalKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                                             <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    result<span class="token operator">-></span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    result<span class="token operator">-></span><span class="token function">append</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PutFixed64</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">PackSequenceAndType</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> key<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，RocksDB 按照 user_key 升序，seq 降序，type 降序，三者优先级依次降低的方式组织 internal_key。因此，只要读取到对应 user_key 的最大 seq，就算读取成功。internal_key 的比较器如下所示，返回 0 表示 a == b，-1 表示 a &lt; b，+1 表示 a &gt; b。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token class-name">InternalKeyComparator</span><span class="token double-colon punctuation">::</span><span class="token function">Compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> ParsedInternalKey<span class="token operator">&amp;</span> a<span class="token punctuation">,</span>                                   <span class="token keyword">const</span> ParsedInternalKey<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Order by:</span>  <span class="token comment">//    increasing user key (according to user-supplied comparator)</span>  <span class="token comment">//    decreasing sequence number</span>  <span class="token comment">//    decreasing type (though sequence# should be enough to disambiguate)</span>  <span class="token keyword">int</span> r <span class="token operator">=</span> user_comparator_<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user_key<span class="token punctuation">,</span> b<span class="token punctuation">.</span>user_key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>sequence <span class="token operator">></span> b<span class="token punctuation">.</span>sequence<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>sequence <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>sequence<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      r <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>type <span class="token operator">></span> b<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>type <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      r <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LookupKey"><a href="#LookupKey" class="headerlink" title="LookupKey"></a>LookupKey</h4><p>当用户想要查找 user_key 时，RocksDB 会首先为本次查找构建一个 LookupKey，该类会在 DBImpl::Get() 中用的。LookupKey 和普通的 key 差不多，也是存在 user_key、 internal_key 和 memtable_key 的形式，其源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// A helper class useful for DBImpl::Get()</span><span class="token keyword">class</span> <span class="token class-name">LookupKey</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// Initialize *this for looking up user_key at a snapshot with</span>  <span class="token comment">// the specified sequence number.</span>  <span class="token function">LookupKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber sequence<span class="token punctuation">,</span>            <span class="token keyword">const</span> Slice<span class="token operator">*</span> ts <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">LookupKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Return a key suitable for lookup in a MemTable.</span>  Slice <span class="token function">memtable_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">Slice</span><span class="token punctuation">(</span>start_<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">></span></span></span><span class="token punctuation">(</span>end_ <span class="token operator">-</span> start_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// Return an internal key (suitable for passing to an internal iterator)</span>  Slice <span class="token function">internal_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">Slice</span><span class="token punctuation">(</span>kstart_<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">></span></span></span><span class="token punctuation">(</span>end_ <span class="token operator">-</span> kstart_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// Return the user key</span>  Slice <span class="token function">user_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">Slice</span><span class="token punctuation">(</span>kstart_<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">></span></span></span><span class="token punctuation">(</span>end_ <span class="token operator">-</span> kstart_ <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// We construct a char array of the form:</span>  <span class="token comment">//    klength  varint32               &lt;-- start_</span>  <span class="token comment">//    userkey  char[klength]          &lt;-- kstart_</span>  <span class="token comment">//    tag      uint64</span>  <span class="token comment">//                                    &lt;-- end_</span>  <span class="token comment">// The array is a suitable MemTable key.</span>  <span class="token comment">// The suffix starting with "userkey" can be used as an InternalKey.</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> start_<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> kstart_<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> end_<span class="token punctuation">;</span>  <span class="token keyword">char</span> space_<span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Avoid allocation for short keys</span>  <span class="token comment">// No copying allowed</span>  <span class="token function">LookupKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，kstart_ 就是 internal_key，start_ 就是 memtable_key。注意到，LookupKey 的构造函数中，需要传入一个 user_key 、一个 seq 和一个 ts，其中 user_key 当然是要查询的 user_key，那么 seq 是哪里来的呢？</p><p>我们查看 LookupKey 的调用者，也就是 DBImpl::GetImpl()，其部分源码如下，我们只看和 seq 有关的部分。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">DBImpl</span><span class="token double-colon punctuation">::</span><span class="token function">GetImpl</span><span class="token punctuation">(</span><span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> read_options<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                       GetImplOptions<span class="token operator">&amp;</span> get_impl_options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  SequenceNumber snapshot<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>read_options<span class="token punctuation">.</span>snapshot <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>get_impl_options<span class="token punctuation">.</span>callback<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Already calculated based on read_options.snapshot</span>      snapshot <span class="token operator">=</span> get_impl_options<span class="token punctuation">.</span>callback<span class="token operator">-></span><span class="token function">max_visible_seq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      snapshot <span class="token operator">=</span>          <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> SnapshotImpl<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>read_options<span class="token punctuation">.</span>snapshot<span class="token punctuation">)</span><span class="token operator">-></span>number_<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Note that the snapshot is assigned AFTER referencing the super</span>    <span class="token comment">// version because otherwise a flush happening in between may compact away</span>    <span class="token comment">// data for the snapshot, so the reader would see neither data that was be</span>    <span class="token comment">// visible to the snapshot before compaction nor the newer data inserted</span>    <span class="token comment">// afterwards.</span>    snapshot <span class="token operator">=</span> <span class="token function">GetLastPublishedSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>get_impl_options<span class="token punctuation">.</span>callback<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// The unprep_seqs are not published for write unprepared, so it could be</span>      <span class="token comment">// that max_visible_seq is larger. Seek to the std::max of the two.</span>      <span class="token comment">// However, we still want our callback to contain the actual snapshot so</span>      <span class="token comment">// that it can do the correct visibility filtering.</span>      get_impl_options<span class="token punctuation">.</span>callback<span class="token operator">-></span><span class="token function">Refresh</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Internally, WriteUnpreparedTxnReadCallback::Refresh would set</span>      <span class="token comment">// max_visible_seq = max(max_visible_seq, snapshot)</span>      <span class="token comment">//</span>      <span class="token comment">// Currently, the commented out assert is broken by</span>      <span class="token comment">// InvalidSnapshotReadCallback, but if write unprepared recovery followed</span>      <span class="token comment">// the regular transaction flow, then this special read callback would not</span>      <span class="token comment">// be needed.</span>      <span class="token comment">//</span>      <span class="token comment">// assert(callback->max_visible_seq() >= snapshot);</span>      snapshot <span class="token operator">=</span> get_impl_options<span class="token punctuation">.</span>callback<span class="token operator">-></span><span class="token function">max_visible_seq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// If timestamp is used, we use read callback to ensure &lt;key,t,s> is returned</span>  <span class="token comment">// only if t &lt;= read_opts.timestamp and s &lt;= snapshot.</span>  <span class="token comment">// HACK: temporarily overwrite input struct field but restore</span>  SaveAndRestore<span class="token operator">&lt;</span>ReadCallback<span class="token operator">*</span><span class="token operator">></span> <span class="token function">restore_callback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>get_impl_options<span class="token punctuation">.</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Comparator<span class="token operator">*</span> ucmp <span class="token operator">=</span> get_impl_options<span class="token punctuation">.</span>column_family<span class="token operator">-></span><span class="token function">GetComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>ucmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ucmp<span class="token operator">-></span><span class="token function">timestamp_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>get_impl_options                <span class="token punctuation">.</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// timestamp with callback is not supported</span>    read_cb<span class="token punctuation">.</span><span class="token function">Refresh</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>    get_impl_options<span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token operator">&amp;</span>read_cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">TEST_SYNC_POINT</span><span class="token punctuation">(</span><span class="token string">"DBImpl::GetImpl:3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">TEST_SYNC_POINT</span><span class="token punctuation">(</span><span class="token string">"DBImpl::GetImpl:4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Prepare to store a list of merge operations if merge occurs.</span>  MergeContext merge_context<span class="token punctuation">;</span>  SequenceNumber max_covering_tombstone_seq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Status s<span class="token punctuation">;</span>  <span class="token comment">// First look in the memtable, then in the immutable memtable (if any).</span>  <span class="token comment">// s is both in/out. When in, s could either be OK or MergeInProgress.</span>  <span class="token comment">// merge_operands will contain the sequence of merges in the latter case.</span>  LookupKey <span class="token function">lkey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> snapshot<span class="token punctuation">,</span> read_options<span class="token punctuation">.</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ...</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skip_memtable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-yi-shi-wu">RocksDB源码学习(一)</a> 中提到，RocksDB 的读实际上是快照读，即先生成一个 snapshot ，这个 snapshot 就是一个 seq，然后只读取该 seq 以及之前的记录，往后的均视为在读操作之后才发生的操作，所以不可见。而 GetImpl() 中就会生成这个 snapshot，然后把它视为 LookupKey 的 seq，然后只查找该 seq 之前的记录。</p><p>先不管 get_impl_options.callback 是什么。简单的来看，GetImpl() 首先会询问 read_options 中是否有对 snapshot 的要求，毕竟配置大于一切。如果没有，那么就通过 GetLastPublishedSequence() 获取到最新的 seq 作为 snapshot。该函数内容如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> SequenceNumber <span class="token function">GetLastPublishedSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_seq_same_as_publish_seq_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> versions_<span class="token operator">-></span><span class="token function">LastSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> versions_<span class="token operator">-></span><span class="token function">LastPublishedSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是，返回当前 version 的最新一个 seq。</p><p>GetImpl() 构造完 LookupKey 之后，会判断是否跳过 memtable，如果否，将会调用 MemTable::Get() 函数。该函数的部分内容如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">MemTable</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> value<span class="token punctuation">,</span>                   PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">,</span>                   Status<span class="token operator">*</span> s<span class="token punctuation">,</span> MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">,</span>                   SequenceNumber<span class="token operator">*</span> max_covering_tombstone_seq<span class="token punctuation">,</span>                   SequenceNumber<span class="token operator">*</span> seq<span class="token punctuation">,</span> <span class="token keyword">const</span> ReadOptions<span class="token operator">&amp;</span> read_opts<span class="token punctuation">,</span>                   <span class="token keyword">bool</span> immutable_memtable<span class="token punctuation">,</span> ReadCallback<span class="token operator">*</span> callback<span class="token punctuation">,</span>                   <span class="token keyword">bool</span><span class="token operator">*</span> is_blob_index<span class="token punctuation">,</span> <span class="token keyword">bool</span> do_merge<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token keyword">bool</span> bloom_checked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bloom_filter_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// when both memtable_whole_key_filtering and prefix_extractor_ are set,</span>    <span class="token comment">// only do whole key filtering for Get() to save CPU</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>moptions_<span class="token punctuation">.</span>memtable_whole_key_filtering<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      may_contain <span class="token operator">=</span> bloom_filter_<span class="token operator">-></span><span class="token function">MayContain</span><span class="token punctuation">(</span>user_key_without_ts<span class="token punctuation">)</span><span class="token punctuation">;</span>      bloom_checked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>prefix_extractor_<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix_extractor_<span class="token operator">-></span><span class="token function">InDomain</span><span class="token punctuation">(</span>user_key_without_ts<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        may_contain <span class="token operator">=</span> bloom_filter_<span class="token operator">-></span><span class="token function">MayContain</span><span class="token punctuation">(</span>            prefix_extractor_<span class="token operator">-></span><span class="token function">Transform</span><span class="token punctuation">(</span>user_key_without_ts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bloom_checked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bloom_filter_ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>may_contain<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// iter is null if prefix bloom says the key does not exist</span>    <span class="token function">PERF_COUNTER_ADD</span><span class="token punctuation">(</span>bloom_memtable_miss_count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>seq <span class="token operator">=</span> kMaxSequenceNumber<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bloom_checked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">PERF_COUNTER_ADD</span><span class="token punctuation">(</span>bloom_memtable_hit_count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">GetFromTable</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">*</span>max_covering_tombstone_seq<span class="token punctuation">,</span> do_merge<span class="token punctuation">,</span> callback<span class="token punctuation">,</span>                 is_blob_index<span class="token punctuation">,</span> value<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> timestamp<span class="token punctuation">,</span> s<span class="token punctuation">,</span> merge_context<span class="token punctuation">,</span>                 seq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>found_final_value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>merge_in_progress<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在截取的这部分代码中，会首先通过 bloom_filter 进行存在性检查，如果得到了阴性，那么就不会在往下进行读操作了，如果得到了阳性，那么就调用 MemTable::GetFromTable() 来进一步读取。所以，Get() 的核心就是使用 bloom_filter 进行存在性检查，之后的读操作由 GetFromTable() 来完成。</p><h4 id="Saver"><a href="#Saver" class="headerlink" title="Saver"></a>Saver</h4><p>GetFromTable() 的完整代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">MemTable</span><span class="token double-colon punctuation">::</span><span class="token function">GetFromTable</span><span class="token punctuation">(</span><span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                            SequenceNumber max_covering_tombstone_seq<span class="token punctuation">,</span>                            <span class="token keyword">bool</span> do_merge<span class="token punctuation">,</span> ReadCallback<span class="token operator">*</span> callback<span class="token punctuation">,</span>                            <span class="token keyword">bool</span><span class="token operator">*</span> is_blob_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> value<span class="token punctuation">,</span>                            PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">,</span>                            std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">,</span> Status<span class="token operator">*</span> s<span class="token punctuation">,</span>                            MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">,</span> SequenceNumber<span class="token operator">*</span> seq<span class="token punctuation">,</span>                            <span class="token keyword">bool</span><span class="token operator">*</span> found_final_value<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">*</span> merge_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Saver saver<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>status <span class="token operator">=</span> s<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>found_final_value <span class="token operator">=</span> found_final_value<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>merge_in_progress <span class="token operator">=</span> merge_in_progress<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token operator">&amp;</span>key<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>columns <span class="token operator">=</span> columns<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>timestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>seq <span class="token operator">=</span> kMaxSequenceNumber<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>mem <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>merge_context <span class="token operator">=</span> merge_context<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>max_covering_tombstone_seq <span class="token operator">=</span> max_covering_tombstone_seq<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>merge_operator <span class="token operator">=</span> moptions_<span class="token punctuation">.</span>merge_operator<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>logger <span class="token operator">=</span> moptions_<span class="token punctuation">.</span>info_log<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>inplace_update_support <span class="token operator">=</span> moptions_<span class="token punctuation">.</span>inplace_update_support<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>statistics <span class="token operator">=</span> moptions_<span class="token punctuation">.</span>statistics<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>clock <span class="token operator">=</span> clock_<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>callback_ <span class="token operator">=</span> callback<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>is_blob_index <span class="token operator">=</span> is_blob_index<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>do_merge <span class="token operator">=</span> do_merge<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>allow_data_in_errors <span class="token operator">=</span> moptions_<span class="token punctuation">.</span>allow_data_in_errors<span class="token punctuation">;</span>  saver<span class="token punctuation">.</span>protection_bytes_per_key <span class="token operator">=</span> moptions_<span class="token punctuation">.</span>protection_bytes_per_key<span class="token punctuation">;</span>  table_<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>saver<span class="token punctuation">,</span> SaveValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">*</span>seq <span class="token operator">=</span> saver<span class="token punctuation">.</span>seq<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一大堆代码只干了两件事，其一是构造 Saver，其二是将其交给 MemTableRep::Get() 来进一步执行读取。我们一个一个说，先看 Saver，这个结构用来保存读取时的上下文，比如 LookupKey、MemTable、SequenceNumber 等等，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Saver</span> <span class="token punctuation">&#123;</span>  Status<span class="token operator">*</span> status<span class="token punctuation">;</span>  <span class="token keyword">const</span> LookupKey<span class="token operator">*</span> key<span class="token punctuation">;</span>  <span class="token keyword">bool</span><span class="token operator">*</span> found_final_value<span class="token punctuation">;</span>  <span class="token comment">// Is value set correctly? Used by KeyMayExist</span>  <span class="token keyword">bool</span><span class="token operator">*</span> merge_in_progress<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> value<span class="token punctuation">;</span>  PinnableWideColumns<span class="token operator">*</span> columns<span class="token punctuation">;</span>  SequenceNumber seq<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> timestamp<span class="token punctuation">;</span>  <span class="token keyword">const</span> MergeOperator<span class="token operator">*</span> merge_operator<span class="token punctuation">;</span>  <span class="token comment">// the merge operations encountered;</span>  MergeContext<span class="token operator">*</span> merge_context<span class="token punctuation">;</span>  SequenceNumber max_covering_tombstone_seq<span class="token punctuation">;</span>  MemTable<span class="token operator">*</span> mem<span class="token punctuation">;</span>  Logger<span class="token operator">*</span> logger<span class="token punctuation">;</span>  Statistics<span class="token operator">*</span> statistics<span class="token punctuation">;</span>  <span class="token keyword">bool</span> inplace_update_support<span class="token punctuation">;</span>  <span class="token keyword">bool</span> do_merge<span class="token punctuation">;</span>  SystemClock<span class="token operator">*</span> clock<span class="token punctuation">;</span>  ReadCallback<span class="token operator">*</span> callback_<span class="token punctuation">;</span>  <span class="token keyword">bool</span><span class="token operator">*</span> is_blob_index<span class="token punctuation">;</span>  <span class="token keyword">bool</span> allow_data_in_errors<span class="token punctuation">;</span>  size_t protection_bytes_per_key<span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token function">CheckCallback</span><span class="token punctuation">(</span>SequenceNumber _seq<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> callback_<span class="token operator">-></span><span class="token function">IsVisible</span><span class="token punctuation">(</span>_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构造 Saver 部分，先看这几个字段：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">saver<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token operator">&amp;</span>key<span class="token punctuation">;</span>saver<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>saver<span class="token punctuation">.</span>seq <span class="token operator">=</span> kMaxSequenceNumber<span class="token punctuation">;</span>saver<span class="token punctuation">.</span>mem <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，saver.key 就是传入的 LookupKey，saver.value 就是要保存值的地址，saver.mem 就是当前的 MemTable 类。需要注意的是，saver.seq 被设置为了 kMaxSequenceNumber，即最大的 seq。</p><h4 id="MemTableRep"><a href="#MemTableRep" class="headerlink" title="MemTableRep"></a>MemTableRep</h4><p>接下来，查看 MemTable::Get()，其完整代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">MemTableRep</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">const</span> LookupKey<span class="token operator">&amp;</span> k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> callback_args<span class="token punctuation">,</span>                      <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">auto</span> iter <span class="token operator">=</span> <span class="token function">GetDynamicPrefixIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>iter<span class="token operator">-></span><span class="token function">Seek</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span><span class="token function">internal_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">.</span><span class="token function">memtable_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       iter<span class="token operator">-></span><span class="token function">Valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">callback_func</span><span class="token punctuation">(</span>callback_args<span class="token punctuation">,</span> iter<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       iter<span class="token operator">-></span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要知道的是，MemTableRep 这个类用来抽象不同的 MemTable 的实现，也就是说它是一个虚类，然后不同的MemTable 实现了它。实现它的数据结构有很多，每一个派生类都是一个实现方式，如下：</p><p><img src="https://s1.ax1x.com/2022/10/19/xsoPX9.png" alt="MemTableRep类关系"></p><p>但是注意，MemTableRep::Get() 没有被声明为 virtual ！也就说，具体使用哪一个函数体，将由调用者指针的类型决定，而非其指向的对象类型决定。在 MemTable::GetFromTable() 中，通过 table_ —&gt; Get(xx) 语句调用，而 table_ 的类型为 std::unique_ptr&lt; MemTable &gt;，即 MemTable*，所以不管 table_ 具体指向哪个派生类，其 Get() 的函数体均为 MemTableRep::Get() 中定义的函数体，而非派生类的函数体。</p><p>那么怎么区别不同的 MemTable 实现（也就是派生类）呢？关键在于迭代器的生成。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> iter <span class="token operator">=</span> <span class="token function">GetDynamicPrefixIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述通过 GetDynamicPrefixIterator() 生成一个迭代器，其类型为 auto。而 GetDynamicPrefixIterator() 被声明为了 virtual，说明其函数体由 table_ 具体指向的对象类型决定，即由派生类决定。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MemTableRep</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token keyword">virtual</span> Iterator<span class="token operator">*</span> <span class="token function">GetIterator</span><span class="token punctuation">(</span>Arena<span class="token operator">*</span> arena <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> Iterator<span class="token operator">*</span> <span class="token function">GetDynamicPrefixIterator</span><span class="token punctuation">(</span>Arena<span class="token operator">*</span> arena <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">GetIterator</span><span class="token punctuation">(</span>arena<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个派生均有自己的迭代器，而 RocksDB 默认使用 SkipList，即 table_ 实际指向 SkipListRep 对象。</p><p><img src="https://s1.ax1x.com/2022/10/19/xsTi8S.png" alt="迭代器的不同实现"></p><p>迭代器的具体实现这里先不说，后续会专门进行 SkipList 的源码分析，那篇博客里会细说。但是不论怎么实现的， Seek() 和 Next() 的功能都是一致的，只是性能的差异罢了。继续回到 MemTableRep::Get() 中，有两个关键问题，我们一个一个分析。</p><ul><li>iter —&gt; Seek()</li><li>callback_func()</li></ul><h5 id="iter-gt-Seek"><a href="#iter-gt-Seek" class="headerlink" title="iter -&gt; Seek()"></a>iter -&gt; Seek()</h5><p>iter —&gt; Seek() 传递了两个参数，internal_key 和 memtable_key，也就是 kstart_ 和 start_。为了搞清楚这两个成员的内容，我们进入 LookupKey 的构造函数中看一看：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">LookupKey</span><span class="token double-colon punctuation">::</span><span class="token function">LookupKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber s<span class="token punctuation">,</span>                     <span class="token keyword">const</span> Slice<span class="token operator">*</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  size_t usize <span class="token operator">=</span> _user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t ts_sz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">==</span> ts<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> ts<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t needed <span class="token operator">=</span> usize <span class="token operator">+</span> ts_sz <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">;</span>  <span class="token comment">// A conservative estimate</span>  <span class="token keyword">char</span><span class="token operator">*</span> dst<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>needed <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>space_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dst <span class="token operator">=</span> space_<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    dst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>needed<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  start_ <span class="token operator">=</span> dst<span class="token punctuation">;</span>  <span class="token comment">// NOTE: We don't support users keys of more than 2GB :)</span>  dst <span class="token operator">=</span> <span class="token function">EncodeVarint32</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>usize <span class="token operator">+</span> ts_sz <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  kstart_ <span class="token operator">=</span> dst<span class="token punctuation">;</span>  <span class="token function">memcpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> _user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> usize<span class="token punctuation">)</span><span class="token punctuation">;</span>  dst <span class="token operator">+=</span> usize<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">!=</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> ts<span class="token operator">-></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    dst <span class="token operator">+=</span> ts_sz<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">EncodeFixed64</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token function">PackSequenceAndType</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> kValueTypeForSeek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dst <span class="token operator">+=</span> <span class="token number">8</span><span class="token punctuation">;</span>  end_ <span class="token operator">=</span> dst<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，internal_key 就是 kstart_ ，memtable_key 就是start_。同样，LookupKey 也会选择是否给 internal_key 加上 ts，注意以下三行：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">!=</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> ts<span class="token operator">-></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    dst <span class="token operator">+=</span> ts_sz<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，ts 由 readoptions 决定，为 readoption.timestamp。在 ReadOptions 结构体中，对该字段有如下注释：</p><blockquote><p>Timestamp of operation. Read should return the latest data visible to the specified timestamp. All timestamps of the same database must be of the same length and format. The user is responsible for providing a customized compare function via Comparator to order &lt;key, timestamp&gt; tuples.<br>For iterator, iter_start_ts is the lower bound (older) and timestamp serves as the upper bound. Versions of the same record that fall in the timestamp range will be returned. If iter_start_ts is nullptr, only the most recent version visible to timestamp is returned. The user-specified timestamp feature is still under active development, and the API is subject to change.<br>Default: nullptr</p></blockquote><p>前两句话就解释了它的作用。在读取时，可以提供一个 timestamp，然后读取操作只会返回 key 在该 ts 可见范围内最新的记录，也就是 ts 可见的且 seq 最大的记录。那么问题来了，什么叫 ts 可见？这个我现在还没弄清，猜测是小于等于 ts 的都可见，即在该时间点之前就已经成功提交的记录。</p><p>讨论完 ts，来看一下 type，可以看到其值为 kValueTypeForSeek，官方对它的介绍如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// kValueTypeForSeek defines the ValueType that should be passed when</span><span class="token comment">// constructing a ParsedInternalKey object for seeking to a particular</span><span class="token comment">// sequence number (since we sort sequence numbers in decreasing order</span><span class="token comment">// and the value type is embedded as the low 8 bits in the sequence</span><span class="token comment">// number in internal keys, we need to use the highest-numbered</span><span class="token comment">// ValueType, not the lowest).</span><span class="token keyword">const</span> ValueType kValueTypeForSeek <span class="token operator">=</span> kTypeWideColumnEntity<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，它是所有 type 中最大的一个，值为 0x16。为什么要这么做呢？因为 type 是降序排列的，所以当 user_key、seq 都确定时，只有将 type 设为最大，LookupKey 才能成为最小的 key，然后开始向其他 type 的 key 迭代。</p><img src="https://s1.ax1x.com/2022/10/20/xyquHH.png" alt="简单示例" style="zoom: 67%;" /><p>接着我们来分析源码，看看 Seek() 函数，位于 <code>memtable/skiplistrep.cc</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Advance to the first entry with a key >= target</span><span class="token keyword">void</span> <span class="token function">Seek</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> user_key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> memtable_key<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>memtable_key <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        iter_<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span>memtable_key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        iter_<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span><span class="token function">EncodeKey</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp_<span class="token punctuation">,</span> user_key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先说明一点，第一个形参虽然叫 user_key，但它实际上是 LookupKey 的 internal_key。但是我们只考虑 memtable_key 不为空的情况下，即一般情况，所以 internal_key 没用了。一直追踪下去，发现它最后会调用 SkipList 的查找函数，名为 InlineSkipList&lt; Comparator &gt;::FindGreaterOrEqual()，从这一步起，开始正式在 MemTable 中查找记录。函数源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">InlineSkipList</span><span class="token operator">&lt;</span>Comparator<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">FindGreaterOrEqual</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> key<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Note: It looks like we could reduce duplication by implementing</span>  <span class="token comment">// this function as FindLessThan(key)->Next(0), but we wouldn't be able</span>  <span class="token comment">// to exit early on equality and the result wouldn't even be correct.</span>  <span class="token comment">// A concurrent insert might occur after FindLessThan(key) but before</span>  <span class="token comment">// we get a chance to call Next(0).</span>  Node<span class="token operator">*</span> x <span class="token operator">=</span> head_<span class="token punctuation">;</span>  <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">GetMaxHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  Node<span class="token operator">*</span> last_bigger <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> DecodedKey key_decoded <span class="token operator">=</span> compare_<span class="token punctuation">.</span><span class="token function">decode_key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> next <span class="token operator">=</span> x<span class="token operator">-></span><span class="token function">Next</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">PREFETCH</span><span class="token punctuation">(</span>next<span class="token operator">-></span><span class="token function">Next</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Make sure the lists are sorted</span>    <span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> head_ <span class="token operator">||</span> next <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> <span class="token function">KeyIsAfterNode</span><span class="token punctuation">(</span>next<span class="token operator">-></span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Make sure we haven't overshot during our search</span>    <span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> head_ <span class="token operator">||</span> <span class="token function">KeyIsAfterNode</span><span class="token punctuation">(</span>key_decoded<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> next <span class="token operator">==</span> last_bigger<span class="token punctuation">)</span>                  <span class="token operator">?</span> <span class="token number">1</span>                  <span class="token operator">:</span> <span class="token function">compare_</span><span class="token punctuation">(</span>next<span class="token operator">-></span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key_decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> level <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Keep searching in this list</span>      x <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Switch to next list, reuse compare_() result</span>      last_bigger <span class="token operator">=</span> next<span class="token punctuation">;</span>      level<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先不具体分析这段源码，但可以看出它的目的。都知道 SkipList 是多层的结构，迭代起点为最高层的最小节点，然后通过二分慢慢往低层行进。在该函数中，一旦找到了相同的 memtable_key，或者在最底层找到了恰好大于该目标的 memtable_key，那么就返回，否则继续找。SkipList 的逻辑可以看这篇文章：<a href="https://www.jianshu.com/p/9d8296562806">SkipList数据结构</a>。该上段代码中，最为核心的就是 Next() 的实现以及 compare_() 的实现，这就涉及到 RocksDB 是如何实现 SkipList 的了，这里我们先不深入分析，后续会有一篇博客单独分析 SkipList 的源码实现：<a href="xxx">待填坑</a>。</p><p>得到查找结果后，我们还有两个问题需要解决：</p><ol><li>由于 memtable_key 是按照 user_key 是升序排列的，所以上述查找得到的 user_key 可能大于我们目标的 user_key，因此需要判断查找结果的 user_key 是否合目标吻合。</li><li>需要根据 type 的类型来判断这条记录是不是用来读值，如果是 delete 那当然不行。</li></ol><h5 id="SaveValue"><a href="#SaveValue" class="headerlink" title="SaveValue()"></a>SaveValue()</h5><p>callback_func() 就是解决这两个问题的，当然，不止解决他们。</p><p>注意在 MemTable::GetFromTable() 调用 MemTable::Get() 时，传递的参数为 (key, &amp;saver, SaveValue)。因此，callback_func() 实际长这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SaveValue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>saver<span class="token punctuation">,</span> iter<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SaveValue() 函数比较长，但 switch-case 占了大部分，而且实现逻辑也很简单，这里截取重要的部分：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">SaveValue</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> entry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Saver<span class="token operator">*</span> s <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Saver<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// ...</span>      <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> key_ptr <span class="token operator">=</span> <span class="token function">GetVarint32Ptr</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> entry <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>key_length<span class="token punctuation">)</span><span class="token punctuation">;</span>  Slice user_key_slice <span class="token operator">=</span> <span class="token function">Slice</span><span class="token punctuation">(</span>key_ptr<span class="token punctuation">,</span> key_length <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Comparator<span class="token operator">*</span> user_comparator <span class="token operator">=</span>      s<span class="token operator">-></span>mem<span class="token operator">-></span><span class="token function">GetInternalKeyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">user_comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t ts_sz <span class="token operator">=</span> user_comparator<span class="token operator">-></span><span class="token function">timestamp_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ts_sz <span class="token operator">&amp;&amp;</span> s<span class="token operator">-></span>timestamp <span class="token operator">&amp;&amp;</span> max_covering_tombstone_seq <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// timestamp should already be set to range tombstone timestamp</span>    <span class="token function">assert</span><span class="token punctuation">(</span>s<span class="token operator">-></span>timestamp<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ts_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>user_comparator<span class="token operator">-></span><span class="token function">EqualWithoutTimestamp</span><span class="token punctuation">(</span>user_key_slice<span class="token punctuation">,</span>                                             s<span class="token operator">-></span>key<span class="token operator">-></span><span class="token function">user_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Correct user key</span>    <span class="token keyword">const</span> <span class="token keyword">uint64_t</span> tag <span class="token operator">=</span> <span class="token function">DecodeFixed64</span><span class="token punctuation">(</span>key_ptr <span class="token operator">+</span> key_length <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ValueType type<span class="token punctuation">;</span>    SequenceNumber seq<span class="token punctuation">;</span>    <span class="token function">UnPackSequenceAndType</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token operator">&amp;</span>seq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// If the value is not in the snapshot, skip it</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token operator">-></span><span class="token function">CheckCallback</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// to continue to the next seq</span>    <span class="token punctuation">&#125;</span>          <span class="token comment">// ...</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>ts_sz <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token operator">-></span>timestamp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token operator">-></span>timestamp<span class="token operator">-></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>ts_sz <span class="token operator">==</span> s<span class="token operator">-></span>timestamp<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// TODO optimize for smaller size ts</span>      <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">kMaxTs</span><span class="token punctuation">(</span>ts_sz<span class="token punctuation">,</span> <span class="token char">'\xff'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>timestamp<span class="token operator">-></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>          user_comparator<span class="token operator">-></span><span class="token function">CompareTimestamp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>timestamp<span class="token punctuation">)</span><span class="token punctuation">,</span> kMaxTs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Slice ts <span class="token operator">=</span> <span class="token function">ExtractTimestampFromUserKey</span><span class="token punctuation">(</span>user_key_slice<span class="token punctuation">,</span> ts_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>timestamp<span class="token operator">-></span><span class="token function">assign</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// ...</span>       <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// ... case xxx</span>      <span class="token keyword">case</span> kTypeValue<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>inplace_update_support<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          s<span class="token operator">-></span>mem<span class="token operator">-></span><span class="token function">GetLock</span><span class="token punctuation">(</span>s<span class="token operator">-></span>key<span class="token operator">-></span><span class="token function">user_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">ReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        Slice v <span class="token operator">=</span> <span class="token function">GetLengthPrefixedSlice</span><span class="token punctuation">(</span>key_ptr <span class="token operator">+</span> key_length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>merge_in_progress<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>do_merge<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>value <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">MergeHelper</span><span class="token double-colon punctuation">::</span><span class="token function">TimedFullMerge</span><span class="token punctuation">(</span>                  merge_operator<span class="token punctuation">,</span> s<span class="token operator">-></span>key<span class="token operator">-></span><span class="token function">user_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span>                  merge_context<span class="token operator">-></span><span class="token function">GetOperands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token operator">-></span>value<span class="token punctuation">,</span> s<span class="token operator">-></span>logger<span class="token punctuation">,</span>                  s<span class="token operator">-></span>statistics<span class="token punctuation">,</span> s<span class="token operator">-></span>clock<span class="token punctuation">,</span> <span class="token keyword">nullptr</span> <span class="token comment">/* result_operand */</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Preserve the value with the goal of returning it as part of</span>            <span class="token comment">// raw merge operands to the user</span>            merge_context<span class="token operator">-></span><span class="token function">PushOperand</span><span class="token punctuation">(</span>                v<span class="token punctuation">,</span> s<span class="token operator">-></span>inplace_update_support <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token comment">/* operand_pinned */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token operator">-></span>do_merge<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// Preserve the value with the goal of returning it as part of</span>          <span class="token comment">// raw merge operands to the user</span>          merge_context<span class="token operator">-></span><span class="token function">PushOperand</span><span class="token punctuation">(</span>              v<span class="token punctuation">,</span> s<span class="token operator">-></span>inplace_update_support <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token comment">/* operand_pinned */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> kTypeWideColumnEntity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">assert</span><span class="token punctuation">(</span>type <span class="token operator">==</span> kTypeValue <span class="token operator">||</span> type <span class="token operator">==</span> kTypeBlobIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token operator">-></span>value<span class="token operator">-></span><span class="token function">assign</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            Slice value<span class="token punctuation">;</span>            <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span>                <span class="token class-name">WideColumnSerialization</span><span class="token double-colon punctuation">::</span><span class="token function">GetValueOfDefaultColumn</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token operator">-></span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              s<span class="token operator">-></span>value<span class="token operator">-></span><span class="token function">assign</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>columns<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> kTypeWideColumnEntity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            s<span class="token operator">-></span>columns<span class="token operator">-></span><span class="token function">SetPlainValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span> s<span class="token operator">-></span>columns<span class="token operator">-></span><span class="token function">SetWideColumnValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>inplace_update_support<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          s<span class="token operator">-></span>mem<span class="token operator">-></span><span class="token function">GetLock</span><span class="token punctuation">(</span>s<span class="token operator">-></span>key<span class="token operator">-></span><span class="token function">user_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">ReadUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>found_final_value<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>is_blob_index <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>is_blob_index<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> kTypeBlobIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">case</span> kTypeDeletion<span class="token operator">:</span>      <span class="token keyword">case</span> kTypeDeletionWithTimestamp<span class="token operator">:</span>      <span class="token keyword">case</span> kTypeSingleDeletion<span class="token operator">:</span>      <span class="token keyword">case</span> kTypeRangeDeletion<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>merge_in_progress<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>value <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">MergeHelper</span><span class="token double-colon punctuation">::</span><span class="token function">TimedFullMerge</span><span class="token punctuation">(</span>                merge_operator<span class="token punctuation">,</span> s<span class="token operator">-></span>key<span class="token operator">-></span><span class="token function">user_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span>                merge_context<span class="token operator">-></span><span class="token function">GetOperands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token operator">-></span>value<span class="token punctuation">,</span> s<span class="token operator">-></span>logger<span class="token punctuation">,</span>                s<span class="token operator">-></span>statistics<span class="token punctuation">,</span> s<span class="token operator">-></span>clock<span class="token punctuation">,</span> <span class="token keyword">nullptr</span> <span class="token comment">/* result_operand */</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">NotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>found_final_value<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">case</span> kTypeMerge<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// ...</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，该函数判断找到的 user_key 是否为目标 user_key，使用的函数为 EqualWithoutTimestamp()，即在不考虑 ts 部分的情况下去比较两个 user_key 是否相同。接着，从找到的 user_key 中将其的 ts 提取出来，赋值给 saver 的 timestamp 字段。</p><p>在 switch-case 代码中，要注意，<strong>没有 break</strong>。</p><p>在 switch-case 代码中，我们先看 delete 相关。kTypeDeletion、kTypeDeletionWithTimestamp、kTypeSingleDeletion 都没有加 break，说明它们的操作都一样，交给 kTypeRangeDeletion 来做。简单的来看，当读到 delete 时，会触发一些 merge 操作，促使这个 user_key 被清理掉，或者直接返回 NotFound。</p><p>只有当 type 为 kTypeValue，才说明这条记录是被 Put 的，应该读值，所以我们重点关注它。在代码块中，有一些 merge 操作和 column 操作，我们不过，merge 会在另一篇博客中详细说明：<a href="xxx">待填坑</a>。但是，可以看出的是，这一块主要是把找到的 user_key 的 value 赋值给 saver 中的 value，来作为最终的 Get 结果，然后将 found_final_value 设为 true，代表成功读取到 value。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> kTypeWideColumnEntity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>type <span class="token operator">==</span> kTypeValue <span class="token operator">||</span> type <span class="token operator">==</span> kTypeBlobIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>value<span class="token operator">-></span><span class="token function">assign</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        Slice value<span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token punctuation">)</span> <span class="token operator">=</span>            <span class="token class-name">WideColumnSerialization</span><span class="token double-colon punctuation">::</span><span class="token function">GetValueOfDefaultColumn</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>status<span class="token operator">-></span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            s<span class="token operator">-></span>value<span class="token operator">-></span><span class="token function">assign</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那现在问题来了，只有当 s-&gt;value != nullptr 的时候，才会进行其中执行赋值，可是 s-&gt;value 本身就是用来保存查询结果的，那么此时它不应该还是空吗？还真不是，它确实没有值，但它不是 nullptr，它明确的指向了一个变量，所以判断能够成立。</p><h3 id="从-Txn-复盘调用链"><a href="#从-Txn-复盘调用链" class="headerlink" title="从 Txn 复盘调用链"></a>从 Txn 复盘调用链</h3><p>接下来我们就追溯这个 saver.value，看看它到底指向谁。这里一直要追溯到最上层的调用者，不管是读是写，调用者均为事务，因此要从 Transaction 开始追溯。RocksDB 提供了一段关于事务的示例代码，位于 <code>examples/transaction_example.cc</code> 中。刚好，借这个机会，我们从头开始捋一遍读取的流程，一直到从 MemTable 中找到 user_key。</p><p>函数链太长了，直接用图来表示，画板地址：<a href="https://www.yuque.com/u2153859/opg8lz/bq8l1y">读操作函数调用链（上）- memtable</a></p><p><img src="https://s1.ax1x.com/2022/10/20/x6nuSx.png" alt="读操作函数调用链（上）"></p><p>由此就可以回答上一章节遗留的问题了，saver.value 从始至终都指向了一个空值的 string，这个 string 是调用者用来保存读取结果 value 的，所以它并不是 nullptr。故 SaveValue 会在赋值前先判断 saver.value 是否为 nullptr，因为要确保调用者确确实实给它分配了一块空间用来存储，如果 saver.value 为 nullptr，则说明调用者根本没有分配空间来保存结果，当然不会在执行赋值了。</p><hr><p>至此，RocksDB 的读框架以及在 memtable 的读操作就大致理完了，下一篇博客将关注在 immutable memtable 中的读取。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s源码系列文章</title>
      <link href="/k8s-yuan-ma-xi-lie-wen-zhang/"/>
      <url>/k8s-yuan-ma-xi-lie-wen-zhang/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://yesiyuan.cn/k8s-yuan-ma-yi-pod-chuang-jian-liu-cheng/">k8s源码(一): Pod创建流程</a></li><li><a href="https://yesiyuan.cn/k8s-yuan-ma-er-pod-chuang-jian-guo-cheng-zhong-container-de-juan-gua-zai/">k8s源码(二): Pod创建过程中Container的卷挂载</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> k8s源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSM-Tree系列文章</title>
      <link href="/lsm-tree-xi-lie-wen-zhang/"/>
      <url>/lsm-tree-xi-lie-wen-zhang/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://yesiyuan.cn/lsm-tree-yi-chu-shi/">LSM-Tree(一) 初识</a></p></li><li><p><a href="https://yesiyuan.cn/bu-long-guo-lu-qi/">布隆过滤器</a></p></li><li><p><a href="https://yesiyuan.cn/sstable-jie-shao/">SSTable</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSM-Tree </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB系列文章</title>
      <link href="/rocksdb-xi-lie-wen-zhang/"/>
      <url>/rocksdb-xi-lie-wen-zhang/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-yi-shi-wu/">RocksDB源码学习(一): 事务</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-er-du-yi/">RocksDB源码学习(二): 读(一)</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-san-du-er/">RocksDB源码学习(三): 读(二)</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-si-du-san/">RocksDB源码学习(四): 读(三)</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-wu-xie-yi-kuang-jia/">RocksDB源码学习(五): 写(一)-框架</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-liu-xie-er-writegroup/">RocksDB源码学习(六): 写(二)-WriteGroup</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-qi-xie-san-wal/">RocksDB源码学习(七): 写(三)-WAL</a></li><li><a href="https://yesiyuan.cn/rocksdb-yuan-ma-xue-xi-ba-xie-si-memtable/">RocksDB源码学习(八): 写(四)-Memtable</a></li><li><a href="https://yesiyuan.cn/rocksdb-userthread-backgroundthread/">RocksDB: UserThread &amp; BackgroundThread</a></li><li><a href="https://yesiyuan.cn/rocksdb-version-versionset/">RocksDB: Version &amp; VersionSet</a></li><li><a href="https://yesiyuan.cn/db-bench-bi-ji/">db_bench使用笔记</a></li><li><a href="https://yesiyuan.cn/db-bench-yuan-ma-yi-random-xia-dan-ge-thread-de-key-sheng-cheng-fang-shi-yu-xie-ru/">db_bench源码(一)：random下单个thread的key生成方式与写入</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocksDB源码学习(一): 事务</title>
      <link href="/rocksdb-yuan-ma-xue-xi-yi-shi-wu/"/>
      <url>/rocksdb-yuan-ma-xue-xi-yi-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>本篇博客试图从宏观上理一下 RocksDB 有关事务的部分。内容包含 DB、Transaction、WriteBatch、Sequence Num、Snapshot、Lock 等等。</p><p>注：本篇博客除了另行说明的代码截图版本为<code>v5.18.4</code>，其余所有代码框里的代码版本均为 <code>v7.7.3</code>。</p><h2 id="事务类"><a href="#事务类" class="headerlink" title="事务类"></a>事务类</h2><p>首先，和事务有关的主要类关系，如下图所示（<a href="https://www.yuque.com/u2153859/opg8lz/glq0ay/edit">画板地址</a>），图只罗列了部分，很不全，画板会更新。</p><p><img src="https://s1.ax1x.com/2022/10/16/xBaYq0.png" alt="事务类关系"></p><h3 id="DB-相关"><a href="#DB-相关" class="headerlink" title="DB 相关"></a>DB 相关</h3><p>这一部分的类会实现底层的读写等操作，提供 API 供真正的事务去调用，相当于整个事务模块的基石，由接口类 DB 派生而来。</p><img src="https://s1.ax1x.com/2022/10/18/xrmfnH.png" alt="DB类关系" style="zoom: 67%;" /><p>其中，最重要的两个类为 TransactionDB 与 DBImpl，前者实现事务的管理，后者实现 DB 接口类中的各个函数。</p><h4 id="TransactionDB"><a href="#TransactionDB" class="headerlink" title="TransactionDB"></a>TransactionDB</h4><p>TransactionDB 声明于 <code>include\rocksdb\utilities\transaction_db.h</code> 中，其可以理解为 Transaction 的容器，一个 TransactionDB 内部可以有多个 Transaction，看下这个类的源码，其中就有创建和获取 Transaction。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TransactionDB</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">StackableDB</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// Starts a new Transaction.</span>  <span class="token comment">//</span>  <span class="token comment">// Caller is responsible for deleting the returned transaction when no</span>  <span class="token comment">// longer needed.</span>  <span class="token comment">//</span>  <span class="token comment">// If old_txn is not null, BeginTransaction will reuse this Transaction</span>  <span class="token comment">// handle instead of allocating a new one.  This is an optimization to avoid</span>  <span class="token comment">// extra allocations when repeatedly creating transactions.</span>  <span class="token keyword">virtual</span> Transaction<span class="token operator">*</span> <span class="token function">BeginTransaction</span><span class="token punctuation">(</span>      <span class="token keyword">const</span> WriteOptions<span class="token operator">&amp;</span> write_options<span class="token punctuation">,</span>      <span class="token keyword">const</span> TransactionOptions<span class="token operator">&amp;</span> txn_options <span class="token operator">=</span> <span class="token function">TransactionOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      Transaction<span class="token operator">*</span> old_txn <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> Transaction<span class="token operator">*</span> <span class="token function">GetTransactionByName</span><span class="token punctuation">(</span><span class="token keyword">const</span> TransactionName<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">GetAllPreparedTransactions</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Transaction<span class="token operator">*</span><span class="token operator">></span><span class="token operator">*</span> trans<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DBImpl"><a href="#DBImpl" class="headerlink" title="DBImpl"></a>DBImpl</h4><p>接下来关注 DBImpl，这个类声明于 <code>db\db_impl\db_impl.h</code> 中，可以说是整个事务框架中<strong>最重要</strong>的一个类，因为它才是真正实现所有读写以及 LSM-Tree 相关操作的实现类，先来看下官方的解释：</p><blockquote><p>While DB is the public interface of RocksDB, and DBImpl is the actual class implementing it. It’s the entrance of the core RocksdB engine. All other DB implementations, e.g. TransactionDB, BlobDB, etc, wrap a DBImpl internally. Other than functions implementing the DB interface, some public functions are there for other internal components to call. For example, TransactionDB directly calls DBImpl::WriteImpl() and BlobDB directly calls DBImpl::GetImpl(). Some other functions are for sub-components to call. For example, ColumnFamilyHandleImpl calls DBImpl::FindObsoleteFiles().</p><p>Since it’s a very large class, the definition of the functions is divided in several db_impl_*.cc files, besides db_impl.cc.</p></blockquote><p>也就是说，DB 这个类声明了整个 RocksDB 事务有关的接口，也就是接口类，而 DBImpl 真正实现了这些接口，相当于内部存储引擎的入口类。其他所有的相关实现类，包括 TransactionDB、BlobDB 等等，实际上都是在内部封装了 DBImpl 罢了。所以记住，这个类实现了最底层的读写。</p><p>这个类中的成员函数超级多，比如 PUT、Merge、Delete、Write、Get、MultiGet、NewIterator、CreateColumnFamilies、Flush 等等，这里有罗列几个，因为太多了。这些函数的定义大部分都位于同目录下的 <code>db_impl.cc</code> 中，进去就可以看见这些函数的函数体。</p><p>注意，我说的是大部分。DBImpl 中的函数太多太复杂了，因此 RocksDB 没有在一个文件中把他们全部定义完，而是又分出了两个派生类：DBImplSecondary 和 DBImplReadOnly，都是 DBImpl 的派生类，位于同级目录下。在 <code>db_impl.cc</code> 中没有定义的函数，均在两个派生类中以 override 的方式实现，定义于 <code>db_impl_secondary.h</code>、<code>db_impl_secondary.cc</code>、<code>db_impl_readonly.h</code>、<code>db_impl_readonly.cc</code> 中，这里不展示代码了。</p><p>因此，想要看事务的底层实现，那就着重去看 <code>db_impl_*.cc / .h </code> 。</p><h3 id="Transaction-相关"><a href="#Transaction-相关" class="headerlink" title="Transaction 相关"></a>Transaction 相关</h3><p>事务最直接的类就是 Transaction，声明于 <code>include\rocksdb\utilities\transaction.h</code> 中，其中声明了与 snapshot、lock、commit 有关的函数，还有基本的 Get 和 Put。当然，它的底层操作还是要基于 DB 的。</p><p>官方对该类的解释如下：</p><blockquote><p>Provides BEGIN/COMMIT/ROLLBACK transactions.</p><p>To use transactions, you must first create either an OptimisticTransactionDB or a TransactionDB.  See examples/[optimistic_]transaction_example.cc for more information.</p><p>To create a transaction, use [Optimistic]TransactionDB::BeginTransaction(). It is up to the caller to synchronize access to this object.</p><p>See examples/transaction_example.cc for some simple examples.</p></blockquote><p>可以看出，这个类的创建是基于 OptimisticTransactionDB 或 TransactionDB，所以在前文中说 TransactionDB 就是 Transaction 的容器。该类中的方法由派生类 TransactionBaseImpl 实现，其声明于 <code>utilities\transactions\transaction_base.h</code> 中，方法定义于同级目录下的 <code>transaction_base.cc</code> 中。</p><img src="https://s1.ax1x.com/2022/10/18/xrnCCV.png" alt="Transaction类关系.png" style="zoom:67%;" /><p>事务分为悲观事务和乐观事务，分别为 PessimisticTransaction 和 OptimisticTransaction。其中，前者认为会通过加锁的方式解决写冲突，后者会通过 version 的方式来解决写冲突。</p><p>为了明晰两者的差别，我们先看一下 Transaction::Put 方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">TransactionBaseImpl</span><span class="token double-colon punctuation">::</span><span class="token function">Put</span><span class="token punctuation">(</span>ColumnFamilyHandle<span class="token operator">*</span> column_family<span class="token punctuation">,</span>                                <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> value<span class="token punctuation">,</span>                                <span class="token keyword">const</span> <span class="token keyword">bool</span> assume_tracked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token keyword">bool</span> do_validate <span class="token operator">=</span> <span class="token operator">!</span>assume_tracked<span class="token punctuation">;</span>  Status s <span class="token operator">=</span> <span class="token function">TryLock</span><span class="token punctuation">(</span>column_family<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* read_only */</span><span class="token punctuation">,</span>                     <span class="token boolean">true</span> <span class="token comment">/* exclusive */</span><span class="token punctuation">,</span> do_validate<span class="token punctuation">,</span> assume_tracked<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> <span class="token function">GetBatchForWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Put</span><span class="token punctuation">(</span>column_family<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      num_puts_<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细节我们先不深究，但是可以看出来，Put 操作，首先要对 key 进行 “加锁”，然后在把写操作写进 WriteBatch 中。Transaction 不会直接把写操作执行，而是写放进 WriteBatch 中，等 Commit 了之后一同写进去，这点和 TinyKV 类似。 至于 WriteBatch 的内容，后面会分析，这里先过掉。</p><p>实际上，不管是 PessimisticTransaction  还是 OptimisticTransaction，Put 的时候用到都是上面那个方法体，只不过，那个所谓的 “加锁” 操作变了，也就是 TryLock，直接区分了两种事务的核心。二者均重载了 TryLock，一个以 lock 的方式，一个以 version 的方式。</p><h4 id="PessimisticTransaction"><a href="#PessimisticTransaction" class="headerlink" title="PessimisticTransaction"></a>PessimisticTransaction</h4><p>其 TryLock 部分源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Attempt to lock this key.</span><span class="token comment">// Returns OK if the key has been successfully locked.  Non-ok, otherwise.</span><span class="token comment">// If check_shapshot is true and this transaction has a snapshot set,</span><span class="token comment">// this key will only be locked if there have been no writes to this key since</span><span class="token comment">// the snapshot time.</span>Status <span class="token class-name">PessimisticTransaction</span><span class="token double-colon punctuation">::</span><span class="token function">TryLock</span><span class="token punctuation">(</span>ColumnFamilyHandle<span class="token operator">*</span> column_family<span class="token punctuation">,</span>                                       <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">bool</span> read_only<span class="token punctuation">,</span>                                       <span class="token keyword">bool</span> exclusive<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">bool</span> do_validate<span class="token punctuation">,</span>                                       <span class="token keyword">const</span> <span class="token keyword">bool</span> assume_tracked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token comment">// Lock this key if this transactions hasn't already locked it or we require</span>  <span class="token comment">// an upgrade.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>previously_locked <span class="token operator">||</span> lock_upgrade<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> txn_db_impl_<span class="token operator">-></span><span class="token function">TryLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> cfh_id<span class="token punctuation">,</span> key_str<span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> ColumnFamilyHandle<span class="token operator">*</span> <span class="token keyword">const</span> cfh <span class="token operator">=</span>      column_family <span class="token operator">?</span> column_family <span class="token operator">:</span> db_impl_<span class="token operator">-></span><span class="token function">DefaultColumnFamily</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>cfh<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Comparator<span class="token operator">*</span> <span class="token keyword">const</span> ucmp <span class="token operator">=</span> cfh<span class="token operator">-></span><span class="token function">GetComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>ucmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t ts_sz <span class="token operator">=</span> ucmp<span class="token operator">-></span><span class="token function">timestamp_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SetSnapshotIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Even though we do not care about doing conflict checking for this write,</span>  <span class="token comment">// we still need to take a lock to make sure we do not cause a conflict with</span>  <span class="token comment">// some other write.  However, we do not need to check if there have been</span>  <span class="token comment">// any writes since this transaction's snapshot.</span>  <span class="token comment">// TODO(agiardullo): could optimize by supporting shared txn locks in the</span>  <span class="token comment">// future.</span>  SequenceNumber tracked_at_seq <span class="token operator">=</span>      status<span class="token punctuation">.</span>locked <span class="token operator">?</span> status<span class="token punctuation">.</span>seq <span class="token operator">:</span> kMaxSequenceNumber<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>do_validate <span class="token operator">||</span> <span class="token punctuation">(</span>snapshot_ <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span>                       <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> ts_sz <span class="token operator">||</span> kMaxTxnTimestamp <span class="token operator">==</span> read_timestamp_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>assume_tracked <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>previously_locked <span class="token operator">&amp;&amp;</span>        tracked_locks_<span class="token operator">-></span><span class="token function">IsPointLockSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      s <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">InvalidArgument</span><span class="token punctuation">(</span>          <span class="token string">"assume_tracked is set but it is not tracked yet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Need to remember the earliest sequence number that we know that this</span>    <span class="token comment">// key has not been modified after.  This is useful if this same</span>    <span class="token comment">// transaction later tries to lock this key again.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tracked_at_seq <span class="token operator">==</span> kMaxSequenceNumber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Since we haven't checked a snapshot, we only know this key has not</span>      <span class="token comment">// been modified since after we locked it.</span>      <span class="token comment">// Note: when last_seq_same_as_publish_seq_==false this is less than the</span>      <span class="token comment">// latest allocated seq but it is ok since i) this is just a heuristic</span>      <span class="token comment">// used only as a hint to avoid actual check for conflicts, ii) this would</span>      <span class="token comment">// cause a false positive only if the snapthot is taken right after the</span>      <span class="token comment">// lock, which would be an unusual sequence.</span>      tracked_at_seq <span class="token operator">=</span> db_<span class="token operator">-></span><span class="token function">GetLatestSequenceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// If a snapshot is set, we need to make sure the key hasn't been modified</span>    <span class="token comment">// since the snapshot.  This must be done after we locked the key.</span>    <span class="token comment">// If we already have validated an earilier snapshot it must has been</span>    <span class="token comment">// reflected in tracked_at_seq and ValidateSnapshot will return OK.</span>    s <span class="token operator">=</span> <span class="token function">ValidateSnapshot</span><span class="token punctuation">(</span>column_family<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tracked_at_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Failed to validate key</span>      <span class="token comment">// Unlock key we just locked</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>lock_upgrade<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> txn_db_impl_<span class="token operator">-></span><span class="token function">TryLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> cfh_id<span class="token punctuation">,</span> key_str<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* exclusive */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>previously_locked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        txn_db_impl_<span class="token operator">-></span><span class="token function">UnLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> cfh_id<span class="token punctuation">,</span> key<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// We must track all the locked keys so that we can unlock them later. If</span>    <span class="token comment">// the key is already locked, this func will update some stats on the</span>    <span class="token comment">// tracked key. It could also update the tracked_at_seq if it is lower</span>    <span class="token comment">// than the existing tracked key seq. These stats are necessary for</span>    <span class="token comment">// RollbackToSavePoint to determine whether a key can be safely removed</span>    <span class="token comment">// from tracked_keys_. Removal can only be done if a key was only locked</span>    <span class="token comment">// during the current savepoint.</span>    <span class="token comment">//</span>    <span class="token comment">// Recall that if assume_tracked is true, we assume that TrackKey has been</span>    <span class="token comment">// called previously since the last savepoint, with the same exclusive</span>    <span class="token comment">// setting, and at a lower sequence number, so skipping here should be</span>    <span class="token comment">// safe.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>assume_tracked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">TrackKey</span><span class="token punctuation">(</span>cfh_id<span class="token punctuation">,</span> key_str<span class="token punctuation">,</span> tracked_at_seq<span class="token punctuation">,</span> read_only<span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">NDEBUG</span></span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>tracked_locks_<span class="token operator">-></span><span class="token function">IsPointLockSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        PointLockStatus lock_status <span class="token operator">=</span>            tracked_locks_<span class="token operator">-></span><span class="token function">GetPointLockStatus</span><span class="token punctuation">(</span>cfh_id<span class="token punctuation">,</span> key_str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>lock_status<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>lock_status<span class="token punctuation">.</span>seq <span class="token operator">&lt;=</span> tracked_at_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>lock_status<span class="token punctuation">.</span>exclusive <span class="token operator">==</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该函数的核心就是通过调用 txn_db_impl_-&gt;TryLock 来进行加锁。其中，txn_db_impl 的类型就是 PessimisticTransactionDB，这也反映了 xxxTransaction  调到最后都是 TransactionDB。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">PessimisticTransactionDB<span class="token operator">*</span> txn_db_impl_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那我们就看一下 PessimisticTransactionDB 的 TryLock 是什么样的，其源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">PessimisticTransactionDB</span><span class="token double-colon punctuation">::</span><span class="token function">TryLock</span><span class="token punctuation">(</span>PessimisticTransaction<span class="token operator">*</span> txn<span class="token punctuation">,</span>                                         <span class="token keyword">uint32_t</span> cfh_id<span class="token punctuation">,</span>                                         <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                                         <span class="token keyword">bool</span> exclusive<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> lock_manager_<span class="token operator">-></span><span class="token function">TryLock</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> cfh_id<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token function">GetEnv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 补充</span><span class="token comment">// std::shared_ptr&lt;LockManager> lock_manager_; </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，最后实际执行加锁的其实是 LockManager 这个类，这个类我们先不管，到这只需要明白 PessimisticTransaction 是通过它来对 key 进行加锁的就行，细节之后再分析。</p><h4 id="OptimisticTransaction"><a href="#OptimisticTransaction" class="headerlink" title="OptimisticTransaction"></a>OptimisticTransaction</h4><p>不同于 PessimisticTransaction ，OptimisticTransaction 没有 lock 一说，用的是 version 的思想，也就是 MVCC，多版本并发控制。其 TryLock 全部源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Record this key so that we can check it for conflicts at commit time.</span><span class="token comment">//</span><span class="token comment">// 'exclusive' is unused for OptimisticTransaction.</span>Status <span class="token class-name">OptimisticTransaction</span><span class="token double-colon punctuation">::</span><span class="token function">TryLock</span><span class="token punctuation">(</span>ColumnFamilyHandle<span class="token operator">*</span> column_family<span class="token punctuation">,</span>                                      <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">bool</span> read_only<span class="token punctuation">,</span>                                      <span class="token keyword">bool</span> exclusive<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">bool</span> do_validate<span class="token punctuation">,</span>                                      <span class="token keyword">const</span> <span class="token keyword">bool</span> assume_tracked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>assume_tracked<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// not supported</span>  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>assume_tracked<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>do_validate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">uint32_t</span> cfh_id <span class="token operator">=</span> <span class="token function">GetColumnFamilyID</span><span class="token punctuation">(</span>column_family<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SetSnapshotIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  SequenceNumber seq<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>snapshot_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    seq <span class="token operator">=</span> snapshot_<span class="token operator">-></span><span class="token function">GetSequenceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    seq <span class="token operator">=</span> db_<span class="token operator">-></span><span class="token function">GetLatestSequenceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  std<span class="token double-colon punctuation">::</span>string key_str <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">TrackKey</span><span class="token punctuation">(</span>cfh_id<span class="token punctuation">,</span> key_str<span class="token punctuation">,</span> seq<span class="token punctuation">,</span> read_only<span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Always return OK. Confilct checking will happen at commit time.</span>  <span class="token keyword">return</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 TryLock 就比较简单了，根本就没有锁，它会先生产一个新的 sequenceNum ，然后通过 TrackKey 将其和 key 整合起来。怎么整合的，以及整合后 key 的结构是什么，这些以后都会说，这里先不管这么细。</p><p>这个 sequenceNum ，会在 Commit 的时候用来检测冲突，检测操作封装在 CheckTransactionForConflict 中，Commit 会调用这个函数。该函数源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Returns OK if it is safe to commit this transaction.  Returns Status::Busy</span><span class="token comment">// if there are read or write conflicts that would prevent us from committing OR</span><span class="token comment">// if we can not determine whether there would be any such conflicts.</span><span class="token comment">//</span><span class="token comment">// Should only be called on writer thread in order to avoid any race conditions</span><span class="token comment">// in detecting write conflicts.</span>Status <span class="token class-name">OptimisticTransaction</span><span class="token double-colon punctuation">::</span><span class="token function">CheckTransactionForConflicts</span><span class="token punctuation">(</span>DB<span class="token operator">*</span> db<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">auto</span> db_impl <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast_with_check</span><span class="token generic class-name"><span class="token operator">&lt;</span>DBImpl<span class="token operator">></span></span></span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Since we are on the write thread and do not want to block other writers,</span>  <span class="token comment">// we will do a cache-only conflict check.  This can result in TryAgain</span>  <span class="token comment">// getting returned if there is not sufficient memtable history to check</span>  <span class="token comment">// for conflicts.</span>  <span class="token keyword">return</span> <span class="token class-name">TransactionUtil</span><span class="token double-colon punctuation">::</span><span class="token function">CheckKeysForConflicts</span><span class="token punctuation">(</span>db_impl<span class="token punctuation">,</span> <span class="token operator">*</span>tracked_locks_<span class="token punctuation">,</span>                                                <span class="token boolean">true</span> <span class="token comment">/* cache_only */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体怎么检测的，我们先不管。</p><h3 id="WriteBatch-相关"><a href="#WriteBatch-相关" class="headerlink" title="WriteBatch 相关"></a>WriteBatch 相关</h3><p>如前文所述，事务会将所有的写操作追加进同一个 WriteBatch 中，直到 Commit 时才向 DB 中进行写入。与 WriteBatch 有关的主要为 4 个类，如下：</p><img src="https://s1.ax1x.com/2022/10/18/xrnP3T.png" alt="WriteBatch类关系.png" style="zoom:67%;" /><h4 id="WriteBatchWithIndex"><a href="#WriteBatchWithIndex" class="headerlink" title="WriteBatchWithIndex"></a>WriteBatchWithIndex</h4><p>WriteBatchWithIndex 是 WriteBatch 的辅助结构，额外搞一个 skip-list 来记录每一个操作在 WriteBatch 中的 offset 等信息。其声明于 <code>include/rocksdb/utilities/write_batch_with_index.h</code> 中，官方对它的解释如下：</p><blockquote><p>A WriteBatchWithIndex with a binary searchable index built for all the keys inserted.<br>In Put(), Merge() Delete(), or SingleDelete(), the same function of the wrapped will be called. At the same time, indexes will be built.<br>By calling GetWriteBatch(), a user will get the WriteBatch for the data they inserted, which can be used for DB::Write().<br>A user can call NewIterator() to create an iterator.</p></blockquote><p>从上述可以得到两个信息：</p><ol><li>每一个写操作都会被赋予一个 index；</li><li>通过函数 GetWriteBatch()，可以得到这个事务的 WriteBatch；</li></ol><p>这里我们提下第二点。GetWriteBatch() 的定义很简单，就一句话，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">WriteBatch<span class="token operator">*</span> <span class="token class-name">WriteBatchWithIndex</span><span class="token double-colon punctuation">::</span><span class="token function">GetWriteBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span>rep<span class="token operator">-></span>write_batch<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也即，它会返回 WriteBatchWithIndex 中一个名为 rep 的成员的 write_batch 字段。而 rep 是一个 Rep 类型的结构指针，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WriteBatchWithIndex</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">Rep</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Rep<span class="token operator">></span> rep<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟进 Rep 结构，其结构体如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">WriteBatchWithIndex</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Rep</span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">explicit</span> <span class="token function">Rep</span><span class="token punctuation">(</span><span class="token keyword">const</span> Comparator<span class="token operator">*</span> index_comparator<span class="token punctuation">,</span> size_t reserved_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>               size_t max_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> _overwrite_key <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>               size_t protection_bytes_per_key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">write_batch</span><span class="token punctuation">(</span>reserved_bytes<span class="token punctuation">,</span> max_bytes<span class="token punctuation">,</span> protection_bytes_per_key<span class="token punctuation">,</span>                    index_comparator <span class="token operator">?</span> index_comparator<span class="token operator">-></span><span class="token function">timestamp_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">comparator</span><span class="token punctuation">(</span>index_comparator<span class="token punctuation">,</span> <span class="token operator">&amp;</span>write_batch<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">skip_list</span><span class="token punctuation">(</span>comparator<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arena<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">overwrite_key</span><span class="token punctuation">(</span>_overwrite_key<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">last_entry_offset</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">last_sub_batch_offset</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sub_batch_cnt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  ReadableWriteBatch write_batch<span class="token punctuation">;</span>  WriteBatchEntryComparator comparator<span class="token punctuation">;</span>  Arena arena<span class="token punctuation">;</span>  WriteBatchEntrySkipList skip_list<span class="token punctuation">;</span>  <span class="token keyword">bool</span> overwrite_key<span class="token punctuation">;</span>  size_t last_entry_offset<span class="token punctuation">;</span>  <span class="token comment">// The starting offset of the last sub-batch. A sub-batch starts right before</span>  <span class="token comment">// inserting a key that is a duplicate of a key in the last sub-batch. Zero,</span>  <span class="token comment">// the default, means that no duplicate key is detected so far.</span>  size_t last_sub_batch_offset<span class="token punctuation">;</span>  <span class="token comment">// Total number of sub-batches in the write batch. Default is 1.</span>  size_t sub_batch_cnt<span class="token punctuation">;</span>  <span class="token comment">// Remember current offset of internal write batch, which is used as</span>  <span class="token comment">// the starting offset of the next record.</span>  <span class="token keyword">void</span> <span class="token function">SetLastEntryOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> last_entry_offset <span class="token operator">=</span> write_batch<span class="token punctuation">.</span><span class="token function">GetDataSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// In overwrite mode, find the existing entry for the same key and update it</span>  <span class="token comment">// to point to the current entry.</span>  <span class="token comment">// Return true if the key is found and updated.</span>  <span class="token keyword">bool</span> <span class="token function">UpdateExistingEntry</span><span class="token punctuation">(</span>ColumnFamilyHandle<span class="token operator">*</span> column_family<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                           WriteType type<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token function">UpdateExistingEntryWithCfId</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> column_family_id<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                                   WriteType type<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Add the recent entry to the update.</span>  <span class="token comment">// In overwrite mode, if key already exists in the index, update it.</span>  <span class="token keyword">void</span> <span class="token function">AddOrUpdateIndex</span><span class="token punctuation">(</span>ColumnFamilyHandle<span class="token operator">*</span> column_family<span class="token punctuation">,</span> <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                        WriteType type<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">AddOrUpdateIndex</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> WriteType type<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Allocate an index entry pointing to the last entry in the write batch and</span>  <span class="token comment">// put it to skip list.</span>  <span class="token keyword">void</span> <span class="token function">AddNewEntry</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> column_family_id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Clear all updates buffered in this batch.</span>  <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">ClearIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Rebuild index by reading all records from the batch.</span>  <span class="token comment">// Returns non-ok status on corruption.</span>  Status <span class="token function">ReBuildIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到，write_batch 的类型为 ReadableWriteBatch，字面意思就是可读的 WriteBatch，而整个类型里只有一个函数，专门用于通过 offset 来找到 WriteBatch 中某一条写操作，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ReadableWriteBatch</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">WriteBatch</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">ReadableWriteBatch</span><span class="token punctuation">(</span>size_t reserved_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size_t max_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>                              size_t protection_bytes_per_key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>                              size_t default_cf_ts_sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">WriteBatch</span><span class="token punctuation">(</span>reserved_bytes<span class="token punctuation">,</span> max_bytes<span class="token punctuation">,</span> protection_bytes_per_key<span class="token punctuation">,</span>                   default_cf_ts_sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// Retrieve some information from a write entry in the write batch, given</span>  <span class="token comment">// the start offset of the write entry.</span>  Status <span class="token function">GetEntryFromDataOffset</span><span class="token punctuation">(</span>size_t data_offset<span class="token punctuation">,</span> WriteType<span class="token operator">*</span> type<span class="token punctuation">,</span> Slice<span class="token operator">*</span> Key<span class="token punctuation">,</span>                                Slice<span class="token operator">*</span> value<span class="token punctuation">,</span> Slice<span class="token operator">*</span> blob<span class="token punctuation">,</span> Slice<span class="token operator">*</span> xid<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，重现表述一下第 2 点。WriteBatchWithIndex 可以通过 GetWriteBatch() 获取到事务的 ReadableWriteBatch，进而凭借它来通过 offset 读取到 WriteBatch 中的某一条写操作。</p><p>总结一下，在事务没有 Commit 之前，数据还不在 Memtable 中，而是存在 WriteBatch 里，如果有需要，这时候可以通过 WriteBatchWithIndex 来拿到自己刚刚写入的但还没有提交的数据。</p><h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p>RocksDB 提供了乐观事务和悲观事务，前者通过 MVCC 进行并发控制，后者采用锁机制，本节就大体介绍一下相关的内容。</p><h3 id="乐观事务"><a href="#乐观事务" class="headerlink" title="乐观事务"></a>乐观事务</h3><h4 id="sequence-number"><a href="#sequence-number" class="headerlink" title="sequence number"></a>sequence number</h4><p>RocksDB 中的每一条记录都有一个 sequence number, 这个 sequence number 存储在记录的 key 中，整合后的类名为 InternalKey，对应结构名为 ParsedInternalKey。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">InternalKey</span> <span class="token punctuation">&#123;</span> <span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token double-colon punctuation">::</span>string rep_<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">InternalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// Leave rep_ as empty to indicate it is invalid</span>  <span class="token function">InternalKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber s<span class="token punctuation">,</span> ValueType t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">AppendInternalKey</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rep_<span class="token punctuation">,</span> <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span>_user_key<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">InternalKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber s<span class="token punctuation">,</span> ValueType t<span class="token punctuation">,</span> Slice ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">AppendInternalKeyWithDifferentTimestamp</span><span class="token punctuation">(</span>        <span class="token operator">&amp;</span>rep_<span class="token punctuation">,</span> <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span>_user_key<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，InternalKey 有两个构造函数，一个含有 ts（time stamp），一个没有。这里需要特别关注的是，ts 是从 v6.6.4 版本才开始有的，在 v5.18.4 以及之前的代码中，根本没有 ts 这个东西。</p><p><img src="https://s1.ax1x.com/2022/10/19/xsvnaQ.png" alt="xsvnaQ.png"></p><p>在这一小节，我们先不管 ts 是个啥，就按照没有 ts 的 InternalKey 来分析。</p><p>那么，rep_ 就是 string 形式的 ParsedInternalKey。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ParsedInternalKey</span> <span class="token punctuation">&#123;</span>  Slice user_key<span class="token punctuation">;</span>  SequenceNumber sequence<span class="token punctuation">;</span>  ValueType type<span class="token punctuation">;</span>  <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">sequence</span><span class="token punctuation">(</span>kMaxSequenceNumber<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">type</span><span class="token punctuation">(</span>kTypeDeletion<span class="token punctuation">)</span>  <span class="token comment">// Make code analyzer happy</span>  <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                         <span class="token comment">// Intentionally left uninitialized (for speed)</span>  <span class="token comment">// u contains timestamp if user timestamp feature is enabled.</span>  <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> u<span class="token punctuation">,</span> <span class="token keyword">const</span> SequenceNumber<span class="token operator">&amp;</span> seq<span class="token punctuation">,</span> ValueType t<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">user_key</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sequence</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">type</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  std<span class="token double-colon punctuation">::</span>string <span class="token function">DebugString</span><span class="token punctuation">(</span><span class="token keyword">bool</span> log_err_key<span class="token punctuation">,</span> <span class="token keyword">bool</span> hex<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    user_key<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    type <span class="token operator">=</span> kTypeDeletion<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">SetTimestamp</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> addr <span class="token operator">=</span> user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，InternalKey 的结构如下：</p><img src="https://s1.ax1x.com/2022/10/18/xrKhB4.png" alt="InternalKey结构" style="zoom: 67%;" /><ul><li>user_key：key。</li><li>seq_num：全局递增 sequence number，用于给同一个 key 的不同操作区分先后。</li><li>value_type：这个和 &lt;key,value&gt; 中的 value 不一样，它实际指的是对这个 key 的操作类型，而不是值类型。比如 Delete、Merge、Rollback 等。</li></ul><p>接着，internl_key 会被封装为 memtable_key，与 memtable_value（这个结构我还没找到在哪）一起组成 &lt;key, value&gt; 写进 memtable 中。整个 &lt;key, value&gt; 结构如下：</p><p><img src="https://s1.ax1x.com/2022/10/18/xrMd8x.png" alt="memtable中的&lt;key,value&gt;"></p><p>对于同样的 user_key 记录，在 RocksDB 中可能存在多条，但他们的 sequence number 不同。</p><p>以我的理解，seq 的主要作用如下：</p><ul><li>区分对同一个 key 的所有操作的先后顺序；</li><li>用于快照；</li><li>无需加锁了；</li></ul><h4 id="time-stamp-since-v6-6-4"><a href="#time-stamp-since-v6-6-4" class="headerlink" title="time stamp (since v6.6.4)"></a>time stamp (since v6.6.4)</h4><p>自从 v6.6.4 开始，InternalKey 就加入了 ts 来进行多版本并发控制了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">InternalKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> _user_key<span class="token punctuation">,</span> SequenceNumber s<span class="token punctuation">,</span> ValueType t<span class="token punctuation">,</span> Slice ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">AppendInternalKeyWithDifferentTimestamp</span><span class="token punctuation">(</span>        <span class="token operator">&amp;</span>rep_<span class="token punctuation">,</span> <span class="token function">ParsedInternalKey</span><span class="token punctuation">(</span>_user_key<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是 ParsedInternalKey 的字段并没有变，只是在转化为 string 时，多整合了一个 ts，且是整合进 user_key 中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">AppendInternalKeyWithDifferentTimestamp</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> result<span class="token punctuation">,</span>                                             <span class="token keyword">const</span> ParsedInternalKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span>                                             <span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  result<span class="token operator">-></span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">.</span>user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  result<span class="token operator">-></span><span class="token function">append</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PutFixed64</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">PackSequenceAndType</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>sequence<span class="token punctuation">,</span> key<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到，虽然加上了 ts，但 ts 使用的是原来 user_key 的末尾空间，也就是 internal_key 的大小并没有变，只是在 user_key 的末尾部分整合上了 ts。同时，在 ParsedInternalKey 中也加入了新的函数，名为 SetTimestamp() ，其功能就是把 ts 整合进 user_key 的末尾成为新的 user_key。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ParsedInternalKey</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token keyword">void</span> <span class="token function">SetTimestamp</span><span class="token punctuation">(</span><span class="token keyword">const</span> Slice<span class="token operator">&amp;</span> ts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> addr <span class="token operator">=</span> user_key<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> user_key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，InternalKey 的结构就变成了下面这样：</p><img src="https://s1.ax1x.com/2022/10/20/xy7qbj.png" alt="xy7qbj.png" style="zoom: 50%;" /><p>至于为什么要引入 ts，我现在也没有搞清除。但可以确定的是，它是用来解决并发冲突的，ts 可以充当 version，用来表明每一个记录的产生时间，从而区分出并发事务的先后。可以猜想，seq 做不到的一些并发控制，致使了 ts 的出现。但至于怎么用，这要到后面具体研究读写源码时才能清除，现在我也不知道。</p><p>同样的，既然 InternalKey _key 被加上了 ts，那么 memtale_key 中的 internal_key 也要加上对应的 ts。</p><p><img src="https://s1.ax1x.com/2022/10/20/xyTUtP.png" alt="新的&lt;key, value&gt;"></p><h4 id="snapshot"><a href="#snapshot" class="headerlink" title="snapshot"></a>snapshot</h4><p>snapshot 是 RocksDB 的快照信息，它实际就是对应一个 sequence number 。简单来讲，假设 snapshot 的 sequence number 为 sa，那么对于此 snapshot 来说，只能看到 sequence number &lt;= sa 的记录，其余的均看不见。</p><p>snapshot 没有复杂的类继承关系，主要就一条 Snapshot —&gt; SnapshotImpl。</p><p><img src="https://s1.ax1x.com/2022/10/18/xrQARx.png" alt="snapshot类关系"></p><p>其实现类如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Each SnapshotImpl corresponds to a particular sequence number.</span><span class="token keyword">class</span> <span class="token class-name">SnapshotImpl</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Snapshot</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  SequenceNumber number_<span class="token punctuation">;</span>  <span class="token comment">// const after creation</span>  <span class="token comment">// It indicates the smallest uncommitted data at the time the snapshot was</span>  <span class="token comment">// taken. This is currently used by WritePrepared transactions to limit the</span>  <span class="token comment">// scope of queries to IsInSnapshot.</span>  SequenceNumber min_uncommitted_ <span class="token operator">=</span> kMinUnCommittedSeq<span class="token punctuation">;</span>  SequenceNumber <span class="token function">GetSequenceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> number_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">int64_t</span> <span class="token function">GetUnixTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> unix_time_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">uint64_t</span> <span class="token function">GetTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> timestamp_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">SnapshotList</span><span class="token punctuation">;</span>  <span class="token comment">// SnapshotImpl is kept in a doubly-linked circular list</span>  SnapshotImpl<span class="token operator">*</span> prev_<span class="token punctuation">;</span>  SnapshotImpl<span class="token operator">*</span> next_<span class="token punctuation">;</span>  SnapshotList<span class="token operator">*</span> list_<span class="token punctuation">;</span>                 <span class="token comment">// just for sanity checks</span>  <span class="token keyword">int64_t</span> unix_time_<span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> timestamp_<span class="token punctuation">;</span>  <span class="token comment">// Will this snapshot be used by a Transaction to do write-conflict checking?</span>  <span class="token keyword">bool</span> is_write_conflict_boundary_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要得到的信息如下：</p><ul><li>snapshot 核心成员为 sequence number，一旦创建就保持不变。</li><li>每个 snapshot 创建时都会分配个实际时间和时间戳，分别为 unix_time_ 和 timestmap_。</li><li>所有的 snapshot 通过全局双向链表来管理，snapshot 内部维护前后指针。</li></ul><p>我们知道，删除记录并不是直接删掉，而是追加一条 Delete 日志，原记录依旧保持。但是，老旧的无用记录不可能一直保存着，所以会在 Merge（又叫 Compact）时清除掉。清除的大致逻辑为，从全局双向链表中取出 sequence number 最小的 snapshot。 如果已删除的老记录 sequence number &lt;= 该snapshot， 那么这些老记录在 Merge 时可以清理掉。</p><h3 id="悲观事务"><a href="#悲观事务" class="headerlink" title="悲观事务"></a>悲观事务</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>悲观事务通过锁机制来进行并发控制，与其有关的有三大结构体：LockInfo、LockMapStripe、LockMap，三者均位于 <code>utilities/transactions/lock/point/point_lock_manager.cc</code> 中。</p><p>LockInfo：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">LockInfo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">bool</span> exclusive<span class="token punctuation">;</span>  autovector<span class="token operator">&lt;</span>TransactionID<span class="token operator">></span> txn_ids<span class="token punctuation">;</span>  <span class="token comment">// Transaction locks are not valid after this time in us</span>  <span class="token keyword">uint64_t</span> expiration_time<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LockInfo 代表一个锁，分为独占锁和共享锁，由 txn_ids 表示其被哪些事务持有。如果 exclusive 为 true，说明该锁为独占锁，那么仅由 txn_ids[0] 来持有该锁；如果 exclusive 为 false，说明该锁为共享锁，那么由 txn_ids 中的全部事务共同持有。expiration_time 为该锁的超时时间，超过该时间后锁失效。</p><p>LockMapStripe：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">LockMapStripe</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  UnorderedMap<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> LockInfo<span class="token operator">></span> keys<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>LockMapStripe 维护一个 map，用来指明 key 与 lock 的对应关系，即哪个 key 被哪个 lock 锁住。</p><p>LockMap：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">LockMap</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token comment">// Number of sepearate LockMapStripes to create, each with their own Mutex</span>  <span class="token keyword">const</span> size_t num_stripes_<span class="token punctuation">;</span>  <span class="token comment">// Count of keys that are currently locked in this column family.</span>  <span class="token comment">// (Only maintained if PointLockManager::max_num_locks_ is positive.)</span>  std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int64_t</span><span class="token operator">></span> lock_cnt<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>LockMapStripe<span class="token operator">*</span><span class="token operator">></span> lock_map_stripes_<span class="token punctuation">;</span>  size_t <span class="token function">GetStripe</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个结构看上去就很奇怪，为什么还要费心思维护一个 LockMapStripe* 的 vector，难道一个 LockMapStripe 不够吗？</p><p>我是这样猜想的。LockMapStripe 内部就是 hash 映射，那么一旦 key 多起来了，那么就有可能发生 hash 冲突，导致两个不同的 key 映射到了一个 LockInfo 上，很显然是错的。为了减少冲突，RocksDB 采用了多个 LockMapStripe，先把每一个 key 按照自定义的 hash 分到某一个 LockMapStripe 中，然后才在其中 hash 映射到 LockInfo 里，两次不同的 hash，可以大大减少冲突率。</p><p>我为什么会这么猜想，来看看 TryLock 的定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status <span class="token class-name">PointLockManager</span><span class="token double-colon punctuation">::</span><span class="token function">TryLock</span><span class="token punctuation">(</span>PessimisticTransaction<span class="token operator">*</span> txn<span class="token punctuation">,</span>                                 ColumnFamilyId column_family_id<span class="token punctuation">,</span>                                 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> Env<span class="token operator">*</span> env<span class="token punctuation">,</span>                                 <span class="token keyword">bool</span> exclusive<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Lookup lock map for this column family id</span>  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>LockMap<span class="token operator">></span> lock_map_ptr <span class="token operator">=</span> <span class="token function">GetLockMap</span><span class="token punctuation">(</span>column_family_id<span class="token punctuation">)</span><span class="token punctuation">;</span>  LockMap<span class="token operator">*</span> lock_map <span class="token operator">=</span> lock_map_ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lock_map <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> msg<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Column family id not found: %"</span> PRIu32<span class="token punctuation">,</span>             column_family_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">InvalidArgument</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// Need to lock the mutex for the stripe that this key hashes to</span>  size_t stripe_num <span class="token operator">=</span> lock_map<span class="token operator">-></span><span class="token function">GetStripe</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>lock_map<span class="token operator">-></span>lock_map_stripes_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> stripe_num<span class="token punctuation">)</span><span class="token punctuation">;</span>  LockMapStripe<span class="token operator">*</span> stripe <span class="token operator">=</span> lock_map<span class="token operator">-></span>lock_map_stripes_<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>stripe_num<span class="token punctuation">)</span><span class="token punctuation">;</span>  LockInfo <span class="token function">lock_info</span><span class="token punctuation">(</span>txn<span class="token operator">-></span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> txn<span class="token operator">-></span><span class="token function">GetExpirationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int64_t</span> timeout <span class="token operator">=</span> txn<span class="token operator">-></span><span class="token function">GetLockTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">AcquireWithTimeout</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> lock_map<span class="token punctuation">,</span> stripe<span class="token punctuation">,</span> column_family_id<span class="token punctuation">,</span> key<span class="token punctuation">,</span> env<span class="token punctuation">,</span>                            timeout<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>lock_info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是三句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t stripe_num <span class="token operator">=</span> lock_map<span class="token operator">-></span><span class="token function">GetStripe</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>lock_map<span class="token operator">-></span>lock_map_stripes_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> stripe_num<span class="token punctuation">)</span><span class="token punctuation">;</span>LockMapStripe<span class="token operator">*</span> stripe <span class="token operator">=</span> lock_map<span class="token operator">-></span>lock_map_stripes_<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>stripe_num<span class="token punctuation">)</span><span class="token punctuation">;</span>LockInfo <span class="token function">lock_info</span><span class="token punctuation">(</span>txn<span class="token operator">-></span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> txn<span class="token operator">-></span><span class="token function">GetExpirationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们看下 GetStripe() 函数的定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">LockMap</span><span class="token double-colon punctuation">::</span><span class="token function">GetStripe</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>num_stripes_ <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">FastRange64</span><span class="token punctuation">(</span><span class="token function">GetSliceNPHash64</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> num_stripes_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数就是把 key 做了一遍 hash 映射，然后再转换为小于 num_stripes_ 的一个数，也就是致命 key 到底位于哪一个 LockMapStripe 中（实际上是指针，但为了直观就不写 * 了）。</p><p>再来看那三句话，首先通过 GetStripe() 找到 key 所处的 LockMapStripe 在 lock_map_stripes_ 中的下标，然后通过 lock_map_stripes_.at() 取出这个 LockMapStripe。这样一看，猜想应该是合理的。</p><p>明白了三大结构体之后，继续分析 TryLock() 函数，在获取到 LockMapStripe 之后，执行如下代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LockInfo <span class="token function">lock_info</span><span class="token punctuation">(</span>txn<span class="token operator">-></span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> txn<span class="token operator">-></span><span class="token function">GetExpirationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int64_t</span> timeout <span class="token operator">=</span> txn<span class="token operator">-></span><span class="token function">GetLockTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">AcquireWithTimeout</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> lock_map<span class="token punctuation">,</span> stripe<span class="token punctuation">,</span> column_family_id<span class="token punctuation">,</span> key<span class="token punctuation">,</span> env<span class="token punctuation">,</span>                          timeout<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>lock_info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它会为当前的事务创建一个 LockInfo，接着进入 AcquireWithTimeout 之中。AcquireWithTimeout 主要是进行 timeout 检查，检查通过之后调用另外的函数进行加锁申请，timeout 检查我们就先跳过。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Helper function for TryLock().</span>Status <span class="token class-name">PointLockManager</span><span class="token double-colon punctuation">::</span><span class="token function">AcquireWithTimeout</span><span class="token punctuation">(</span>    PessimisticTransaction<span class="token operator">*</span> txn<span class="token punctuation">,</span> LockMap<span class="token operator">*</span> lock_map<span class="token punctuation">,</span> LockMapStripe<span class="token operator">*</span> stripe<span class="token punctuation">,</span>    ColumnFamilyId column_family_id<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> Env<span class="token operator">*</span> env<span class="token punctuation">,</span>    <span class="token keyword">int64_t</span> timeout<span class="token punctuation">,</span> LockInfo<span class="token operator">&amp;&amp;</span> lock_info<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ... timeout 检查</span>  <span class="token comment">// 申请加锁</span>  result <span class="token operator">=</span> <span class="token function">AcquireLocked</span><span class="token punctuation">(</span>lock_map<span class="token punctuation">,</span> stripe<span class="token punctuation">,</span> key<span class="token punctuation">,</span> env<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>lock_info<span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token operator">&amp;</span>expire_time_hint<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait_ids<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ... 根据 result 继续操作</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AcquireWithTimeout 通过 timeout 检查之后，调用 AcquireLocked 申请加锁。注意一下函数传入的最后一个参数 wait_ids，或者说变量 wait_ids。它用来指明当前事务正在等待哪些事务，可以通过它来表示事务之间的等待顺序，从而检测环路，避免死锁，这个后面会说。</p><p>重点来了，进入 AcquireLocked，看看锁是怎么加的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Try to lock this key after we have acquired the mutex.</span><span class="token comment">// Sets *expire_time to the expiration time in microseconds</span><span class="token comment">//  or 0 if no expiration.</span><span class="token comment">// REQUIRED:  Stripe mutex must be held.</span>Status <span class="token class-name">PointLockManager</span><span class="token double-colon punctuation">::</span><span class="token function">AcquireLocked</span><span class="token punctuation">(</span>LockMap<span class="token operator">*</span> lock_map<span class="token punctuation">,</span> LockMapStripe<span class="token operator">*</span> stripe<span class="token punctuation">,</span>                                       <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> Env<span class="token operator">*</span> env<span class="token punctuation">,</span>                                       LockInfo<span class="token operator">&amp;&amp;</span> txn_lock_info<span class="token punctuation">,</span>                                       <span class="token keyword">uint64_t</span><span class="token operator">*</span> expire_time<span class="token punctuation">,</span>                                       autovector<span class="token operator">&lt;</span>TransactionID<span class="token operator">></span><span class="token operator">*</span> txn_ids<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>txn_lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Status result<span class="token punctuation">;</span>  <span class="token comment">// Check if this key is already locked</span>  <span class="token keyword">auto</span> stripe_iter <span class="token operator">=</span> stripe<span class="token operator">-></span>keys<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stripe_iter <span class="token operator">!=</span> stripe<span class="token operator">-></span>keys<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Lock already held</span>    LockInfo<span class="token operator">&amp;</span> lock_info <span class="token operator">=</span> stripe_iter<span class="token operator">-></span>second<span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token operator">!</span>lock_info<span class="token punctuation">.</span>exclusive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock_info<span class="token punctuation">.</span>exclusive <span class="token operator">||</span> txn_lock_info<span class="token punctuation">.</span>exclusive<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span>          lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> txn_lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// The list contains one txn and we're it, so just take it.</span>        lock_info<span class="token punctuation">.</span>exclusive <span class="token operator">=</span> txn_lock_info<span class="token punctuation">.</span>exclusive<span class="token punctuation">;</span>        lock_info<span class="token punctuation">.</span>expiration_time <span class="token operator">=</span> txn_lock_info<span class="token punctuation">.</span>expiration_time<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Check if it's expired. Skips over txn_lock_info.txn_ids[0] in case</span>        <span class="token comment">// it's there for a shared lock with multiple holders which was not</span>        <span class="token comment">// caught in the first case.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsLockExpired</span><span class="token punctuation">(</span>txn_lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lock_info<span class="token punctuation">,</span> env<span class="token punctuation">,</span>                          expire_time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// lock is expired, can steal it</span>          lock_info<span class="token punctuation">.</span>txn_ids <span class="token operator">=</span> txn_lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">;</span>          lock_info<span class="token punctuation">.</span>exclusive <span class="token operator">=</span> txn_lock_info<span class="token punctuation">.</span>exclusive<span class="token punctuation">;</span>          lock_info<span class="token punctuation">.</span>expiration_time <span class="token operator">=</span> txn_lock_info<span class="token punctuation">.</span>expiration_time<span class="token punctuation">;</span>          <span class="token comment">// lock_cnt does not change</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          result <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">TimedOut</span><span class="token punctuation">(</span>Status<span class="token double-colon punctuation">::</span>SubCode<span class="token double-colon punctuation">::</span>kLockTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">*</span>txn_ids <span class="token operator">=</span> lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// We are requesting shared access to a shared lock, so just grant it.</span>      lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>txn_lock_info<span class="token punctuation">.</span>txn_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Using std::max means that expiration time never goes down even when</span>      <span class="token comment">// a transaction is removed from the list. The correct solution would be</span>      <span class="token comment">// to track expiry for every transaction, but this would also work for</span>      <span class="token comment">// now.</span>      lock_info<span class="token punctuation">.</span>expiration_time <span class="token operator">=</span>          std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>lock_info<span class="token punctuation">.</span>expiration_time<span class="token punctuation">,</span> txn_lock_info<span class="token punctuation">.</span>expiration_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Lock not held.</span>    <span class="token comment">// Check lock limit</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>max_num_locks_ <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        lock_map<span class="token operator">-></span>lock_cnt<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">>=</span> max_num_locks_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      result <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">Busy</span><span class="token punctuation">(</span>Status<span class="token double-colon punctuation">::</span>SubCode<span class="token double-colon punctuation">::</span>kLockLimit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// acquire lock</span>      stripe<span class="token operator">-></span>keys<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>txn_lock_info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Maintain lock count if there is a limit on the number of locks</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>max_num_locks_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        lock_map<span class="token operator">-></span>lock_cnt<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>通过 LockMapStripe 来判断这个 key 是否已经被加锁了，如果是，进入2，如果否，进入 6。</li><li>key 已经被加锁，那么判断 key 的锁是否为独占锁，或者当前事务的锁是否为独占锁，两者任意一个通过，进入3，否则进入 5。</li><li>判断持有该 key 的锁的事务是否为当前事务，如果是，就按照事务的锁更新一些字段然后返回即可，如果不是，进入 4。</li><li>判断该 key 的锁是否超时，如果是，那么该锁会被当前事务的锁替代，该 key 成功由当前事务锁住，然后返回；如果不是，给个 kLockTimeout 错误状态，然后把 txn_ids（wait_ids）赋值为持有该 key 锁的所有事务id，表示当前事务要等他们释放锁，返回。</li><li>进入这一步说明 key 的锁和当前事务的锁其中至少有一个是共享锁。那么就直接把当前事务加入进 key 锁的事务 vector 中，一起共享这个锁，然后重算锁的超时时间，取两者之间的最大值，返回。</li><li>进入这一步说明 key 并没有被锁住。查看 LockMap 中的锁数量是否超过了限制，如果是，给个 kLockLimit 错误状态然后返回即可；如果否，就在 kLockTimeout 加一条映射，表示该 key 被当前事务锁住了，之后吧 LockMap 中的锁数量加一，返回。</li></ol><p>至此，加锁申请完毕，对锁的大致流程也有了一定的了解。</p><p>实际上，上述流程是以 CF 为单位的，一个 CF 拥有一个 LockMap。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PointLockManager</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">LockManager</span></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// ...</span>  <span class="token comment">// Map of ColumnFamilyId to locked key info</span>  <span class="token keyword">using</span> LockMaps <span class="token operator">=</span> UnorderedMap<span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>LockMap<span class="token operator">>></span><span class="token punctuation">;</span>  LockMaps lock_maps_<span class="token punctuation">;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来关注 wait_ids。当 AcquireWithTimeout 调用完 AcquireLocked 之后，在后续执行了如下一段代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// We are dependent on a transaction to finish, so perform deadlock</span><span class="token comment">// detection.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>wait_ids<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>txn<span class="token operator">-></span><span class="token function">IsDeadlockDetect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IncrementWaiters</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> wait_ids<span class="token punctuation">,</span> key<span class="token punctuation">,</span> column_family_id<span class="token punctuation">,</span>                             lock_info<span class="token punctuation">.</span>exclusive<span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            result <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">Busy</span><span class="token punctuation">(</span>Status<span class="token double-colon punctuation">::</span>SubCode<span class="token double-colon punctuation">::</span>kDeadlock<span class="token punctuation">)</span><span class="token punctuation">;</span>            stripe<span class="token operator">-></span>stripe_mutex<span class="token operator">-></span><span class="token function">UnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    txn<span class="token operator">-></span><span class="token function">SetWaitingTxn</span><span class="token punctuation">(</span>wait_ids<span class="token punctuation">,</span> column_family_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，函数通过 wait_ids 维护的事务等待队列来进行死锁检测。死锁检测的核心函数即为 IncrementWaiters()，其定义我们暂且先不看，后续会专门总结一篇博客分析 RocksDB 检测死锁的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> rocksdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTable 介绍</title>
      <link href="/sstable-jie-shao/"/>
      <url>/sstable-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>SSTable（Sorted String Table）是一个简单，但是非常有用的用来交换大量的、<strong>排好序</strong>的数据片段的数据结构。其使用场景为：</p><ul><li>需要高效地存储大量地 K-V 数据；</li><li>数据是顺序写入的；</li><li>要求高效地顺序读写；</li><li>没有随机读取或者对随机读取性能要求不高；</li></ul><p>BigTable 论文中对 SSTable 这样介绍：</p><blockquote><p>SSTable 提供一个可持久化，有序的、不可变的从键到值的映射关系，其中键和值都是任意字节长度的字符串。SSTable 提供了以下操作：</p><p>按照某个键来查询关联值，可以指定键的范围，来遍历其中所有的键值对。每个 SSTable 内部由一系列块(（block）组成（通常每块大小为64KB，是可配置的）。使用存储在 SSTable 结尾的块索引（block index）来定位块；当 SSTable 打开时，索引会被加载到内存里。一次磁盘寻道（disk seek）就可以完成查询（lookup）操作：首先通过二分查找在存储在内存的索引中找到对应的块，然后从磁盘上读取这块内容。SSTable 也可以完整地映射到内存里，这样在执行查询和扫描（scan）的时候就不用操作磁盘了.</p></blockquote><p>简单来讲，SSTable 是一个键是有序的，存储字符串形式键值对的文件。每个 SSTable 包含一系列的数据块（Data Block，以下简称 Block），在 SSTable 的末尾是索引块，用于定位 Block。其结构简单来看，如下图所示：</p><p><img src="http://img1.tbcdn.cn/L1/461/1/4c483c166e3b04f211db66ab3b7a62c07fab3f2b" alt="sstable 粗略结构"></p><p>从上图可以看到，因为 SSTable 文件中所有的键值对 &lt;key,value&gt; 是存放到一起的，所以 SSTable 在序列化成文件之后，是<strong>不可变</strong>的，因为此时的 SSTable，就类似于一个数组一样，如果插入或者删除，需要移动一大片数据，开销很大。</p><p>然而实际上，BigTable 中的 SSTable 结构比上面那张图复杂的多，它长这样：</p><p><img src="https://s1.ax1x.com/2022/10/12/xaiQAA.png" alt="sstable 详细结构"></p><p>SSTable 中的数据按 key 排序后存放在连续的数据块（Block） 中，Block 之间也有序。在众多 Block 之后，为索引块，其中存着每一个 Block 的索引，由每个 Block 最后一行的 key 组成，由用于数据查询中定位 Block。接着，存放布隆过滤器和表格的 Schema 信息。最后，存放固定大小的 Trailer 以及 Trailer的 Offset。</p><ul><li>Data Block：存放连续的数据块。</li><li>Block Index：存放连续的块索引。描述一个 Block，存储着对应 Block 的最大 Key 值，以及 Block 在文件中的偏移量和大小。</li><li>Bloom Filter：布隆过滤器（Bloom Filter），用于判断读取的数据是否在当前 SSTable 上。</li><li>Table Schema: 当前 SSTable 的表格Schema信息。</li><li>Fixed Trailer：当前 SSTable 的Block Index的块索引大小。</li><li>Trailer Offset：当前 SSTable 的Block Index的块索引在文件存储下的偏移量。</li></ul><p>在 SSTable 中查找 k-v 时，首先从子表的索引信息中读取 SSTable Trailer 的偏移位置，接着获取 Trailer 信息。根据 Trailer 中记录的信息，可以获取块索引的大小和偏移，从而将整个块索引加载到内存中。之后，根据块索引记录的每个 Block 的最后一行的 key，可以通过二分查找定位到查找的 Block，然后将 Block 加载到内存中。加载完 Block 之后，在 Block 内部的行索引（raw index）中进行二分查找，找到相关行的偏移，然后查找到具体某一行Row X，即是我们要找的数据。</p><p>本质上看，SSTable 是一个两级索引结构：<code>块索引</code>以及<code>行索引</code>。</p><p>具体的 SSTable 是怎么实现的，需要去看 Rocksdb 的源码，等理清源码实现之后，我再写一篇博客来记录。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/bu-long-guo-lu-qi/"/>
      <url>/bu-long-guo-lu-qi/</url>
      
        <content type="html"><![CDATA[<p>BloomFilter 实际上是一个很长的二进制向量和一系列随机映射函数，主要用于判断一个元素是否在一个集合中。</p><p>通常我们要判断一个元素是否在某个集合，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、哈希表等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长。这时，BloomFilter 就诞生了，其具有极低的空间复杂度与时间复杂度。</p><p>在初始状态时，对于长度为 m 的位数组，它的所有位都被置为0，如下图所示：</p><p><img src="https://s1.ax1x.com/2022/10/12/xapAsJ.png" alt="布隆过滤器初始状态"></p><p>当有变量被加入集合时，通过 K 个映射函数将这个变量映射成位图中的 K 个点，把它们置为 1。这里假设有两个变量，共 3 个 Hash 函数。</p><p><img src="https://s1.ax1x.com/2022/10/12/xapdW8.png" alt="映射"></p><p>查询某个变量的时候我们只要看看这些点是不是都是 1 就可以大概率知道集合中有没有它了。</p><ul><li>如果这些点有任何一个 0，则被查询变量一定不在；</li><li>如果都是 1，则被查询变量<strong>很可能</strong>存在；</li></ul><p>第一点很显然，因为存在的变量映射之后一定全 1，所以布隆过滤器不存在假阴性。第二点是因为 Hash 函数存在碰撞的可能，比如 item3 和 item1 的三个 Hash 函数结果都一样，所以布隆过滤器存在假阳性。</p><p>布隆过滤器拥有 O(k) 的时间复杂度，其中 k 为 Hash 函数的个数，通常 k 并不大，所以基本为 O(1)。空间方面，m 位的布隆过滤器最多可以容纳 2^m 个元素，有很大的空间优势。正确度方面，多 Hash 函数大幅度减少了传统哈希表的碰撞率，只不过当元素越来越多时，碰撞率就会越来越大。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSM-Tree(一) 初识</title>
      <link href="/lsm-tree-yi-chu-shi/"/>
      <url>/lsm-tree-yi-chu-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本篇博客为综述《LSM-based Storage Techniques: A Survey》的学习笔记（一），该综述介绍了 LSM-Tree 的前世今生、思想本质、性能权衡、面临问题、优化方案等等，也是我正式接触 LSTM-Tree 的入门导师。综述对 leveling、tiering、partition 等核心观念进行了较为详细的介绍，对 LSM-Tree 的本质理解还是很有帮助的。不过，毕竟只是一篇综述，想要看清 LSM-Tree 光靠这一篇肯定是不够的，所以还参考了其他的博客。</p><p>好了，我们开始。</p></blockquote><p>都知道，现在的存储体系大多分为 SQL 和 NoSQL，后者即 K-V 存储，LSM-Tree 就是为它服务的一种底层数据结构。现行的大部分 K-V 存储，比如 Rocksdb、Badger 等底层用的都是 LSM-Tree，虽然进行了一定的优化与变式，但本质还是 LSM。所以，LSM-Tree 是什么？为什么要用到 LSM-Tree，要搞清楚这个问题，就需要先明白在 LSM-Tree 出现之前，K-V 存储是什么样的。</p><h2 id="LSM-Tree-诞生之前"><a href="#LSM-Tree-诞生之前" class="headerlink" title="LSM-Tree 诞生之前"></a>LSM-Tree 诞生之前</h2><p>一般来讲，K-V 存储在更新时有两种方案供选择，一种叫<code>就地更新（in-place）</code>，一种叫<code>地外更新（out-of-place）</code>。所谓就地更新，就是直接将原来的记录改了，换成新的记录，比如把 &lt;k1,v1&gt; 改成 &lt;k2,v2&gt;，这样一来就没有 &lt;k1,v1&gt; 这个记录了，查询 k1 的值会直接返回 v1，具有很高的<strong>读效率</strong>。同时，由于更新直接利用原来的空间，不会开辟新的空间，所有具有很高的<strong>空间利用率</strong>。但是，代价就是<strong>写放大</strong>，说人话就是写变慢了。在该策略中，每一次写都会造成随机的 I/O，即要先找到那个 key，然后再做更新，就会导致写速率变慢。</p><p>于此相反，地外更新不会直接更改原来的 &lt;k1,v1&gt;，而是将 &lt;k2,v2&gt; 另外存储在一个新的地方，然后打上 version 表示这个记录才是 k1 最新的值。这样一来，写 k1 时，就无需采用随机 I/O 事先找到 k1，而是直接利用顺序 I/O 将新记录附加上去就行了，相比于就地更新，这种策略具有更好的<strong>读效率</strong>。同时，由于没有覆盖旧记录，所以是<strong>利于回滚</strong>的。但代价就是，具有<strong>读放大</strong>与<strong>空间放大</strong>，这两点很显然，因为同一个 key 对应的记录更多了。</p><img src="https://s1.ax1x.com/2022/10/12/xUxLY8.png" alt="image-20221012111855628" style="zoom: 50%;" /><p>地外更新随后成为主流，它为记录的存储提供了一种新的思路：<code>顺序日志</code>。比如早期的 Postgres 项目，会把所有的写操作附件到一个顺序日志中去，只有当原记录过时后才由垃圾回收机制清理，而不是当场覆盖原记录。</p><p>但是很明显，如果日志的结构仅仅是顺序的，那必然不是最优的，因为记录之间潜在的联系没有被利用，大家都像栈元素一样一个一个 push 进日志，肯定是不行的。所以就引出了新的问题，如何进行合理的<code>日志结构化</code>？这就是 LSM 中的 LS 所指的含义，Log-Structured。</p><p>那 Merge 指什么呢？实际上，对于某一个 key，除了最新的那条记录外，其他的记录都是冗余无用的，但是仍然占用了存储空间，所以需要不定期的去进行 Merge 来清除掉冗余的记录，而这就是 LSM-Tree 的核心内容。</p><h2 id="早期-LSM-Tree"><a href="#早期-LSM-Tree" class="headerlink" title="早期 LSM-Tree"></a>早期 LSM-Tree</h2><p>为了解决上面说的问题，LSM-Tree 诞生。就像其名字一样，LSM-Tree 设计的初衷，就是对日志进行一定的<code>合并（merge）</code>，来进行冗余记录的清除，并利用合适的日志结构与合并策略来提高写性能。</p><p>最开始的 LSM-Tree，由一系列的组件构成，我们把它们记作 C0、C1 … Ck。每一个组件内部都是一个 B+ 树，（当然，到后期就不是了，不过这里先不管）。C0 驻留在内存中，为传入的写操作提供服务，而其余的所有 C 均驻留在磁盘中，进行真正的数据存储。所有的组件之间都是递进的，当且仅当 Ci 存满的时候，会触发合并进程，将 Ci 中的一系列叶页面（leaf page）合并到 Ci+1 中，然后 Ci 继续等待来自 Ci-1 的合并，以此类推。这种策略叫作<code>滚动合并</code>。</p><img src="https://s1.ax1x.com/2022/10/12/xUxzOs.png" alt="image-20221012113842778" style="zoom:67%;" /><p>值得注意的是，只有当所有组件之间的大小比 Ti = |Ci + 1|/|Ci| 相同时，写入性能才得到优化。我不知道为什么，在 LSM-Tree 的原始论文中有推导，不过我没看，私以为记个结论就行。这一个结论，直接影响到后续有关 LSM-Tree 的实现与优化。</p><h2 id="LSM-Tree-基本结构"><a href="#LSM-Tree-基本结构" class="headerlink" title="LSM-Tree 基本结构"></a>LSM-Tree 基本结构</h2><p>如今的 LSM-Tree 实现仍然应用地外更新来减少随机 I/O。所有写操作都附加到内存组件中。插入或更新操作只是添加一个新条目，而删除操作则添加一个反事项条目，表明某个键已被删除。当组件满时，多个组件会合并为一个<strong>新的</strong>组件，而无需修改现有组件，这是前面提到的滚动合并是不一样的。</p><p>那么磁盘组件是如何组织并且合并的呢？LSM-Tree 提供了两种合并策略：<code>leveling</code> 和 <code>tiering</code> 。这两种策略都将磁盘组件组织为逻辑级别，级别之间的关系由一个 size ratio 控制，该参数名为 <code>T</code>。</p><h3 id="leveling-amp-tiering"><a href="#leveling-amp-tiering" class="headerlink" title="leveling &amp; tiering"></a>leveling &amp; tiering</h3><p>leveling 策略中，每一层<strong>只有一个</strong>磁盘组件 ，每一个 SSTable 的空间容量满足比率 T，且保持不变。当位于级别 L 的组件被填满时，它就会和位于级别 L+1 的组件合并，注意，是覆盖性合并，即直接更改原 L+1 级的组件。用图来表示，如下：</p><img src="https://s1.ax1x.com/2022/10/12/xUzpmn.png" alt="image-20221012162412679" style="zoom:67%;" /><p>与此相反，tiering 策略中每一层都有 <strong>T 个</strong>组件，意味着每层的组件数目都相同。同时，一层中的各个组件大小相同。当级别 L 被填满时（该级别出现了 T 个组件），该层的 T 个组件会合并为一个新的组件，进入级别 L+1。这也就解释了为什么每一层都只能有 T 个组件，因为只有这样才能保证层与层之间的空间容量比为 T。该策略用图来表示，如下：</p><img src="https://s1.ax1x.com/2022/10/12/xUzVl4.png" alt="image-20221012163255625" style="zoom:67%;" /><p>通常，leveling 策略会优化读性能，因为每一层只有一个组件，搜索的组件数就会少。而 tiering 策略的则优化写性能，因为它降低了合并频率。</p><p>下面给出两种策略的各种操作复杂度，有些项的具体推导我暂时还没懂，个人觉得综述里写的推导有点泛，某些我还没看明白。都看懂了我再回来更新。</p><p><img src="https://s1.ax1x.com/2022/10/12/xUzZ6J.png" alt="image-20221012163754659"></p><p>其中，T 如上文所述，L 表示层级的数量，B 表示页面大小（一页中存有多少个条目），P 表示一个磁盘组件中有多少个页面（虽然最后的结论中没有P）。Long/Short Range Query 指范围查询的长短，由范围中的唯一键数目决定。记查询范围中唯一键的数目为 s，如果 S/B &gt; 2L，那么就称为 Long，反之为 short。此外，在单点查询中为什么 Zero-Result 和 Non-Zero-Result 差别会这么大，这是应为运用了<code>布隆过滤器</code>，这是用来快速判断某个 key 是否存在的工具，但是具有假阳性的概率。在另一篇博客中我会介绍它：<a href="https://yesiyuan.cn/bu-long-guo-lu-qi/">布隆过滤器</a>。</p><p>定性总结一下：</p><ul><li>leveling：读优化、空间优化、写放大；</li><li>tiering：写优化、读放大、空间放大；</li></ul><p>但实际上，我们现在用的并不是这两种策略，而是采用了<code>分区（partition）</code>的优化。</p><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>在阐述 LSM-Tree 的分区策略之前，现简要提一嘴现在各个组件的常用数据结构，直接以 Rocksdb 为例。LSM-Tree有三个重要组成部分：<code>MemTable</code>、<code>Immutable MemTable</code>、<code>SSTable</code>。</p><ul><li><p><strong>MemTable</strong>：</p><p>MemTable 是在<strong>内存</strong>中的数据结构，直接服务传入的写操作，并暂存最近更新的数据，即上述提及的组件<code>C0</code>。它会按照 key 有序地组织这些数据，但具体如何组织，不同的存储引擎用的方式不一样。在 Rocksdb 中，采用 <code>跳表（skip-list）</code> 来保证内存中的 key 有序。</p><p>因为数据暂存在内存中，没有持久化，因此通常使用 <code>WAL(Write-ahead logging)</code> 的方式来保证数据的可靠性。</p><p>ps.）跳表，是个超级牛逼的查找数据结构，可以理解为一个能够实现二分查找的链表。我本来打算写一篇博客记录的，但搜到了一篇非常详细的跳表解析博客，增删查都写的很清晰，尤其是增加操作中的随机索引建立过程，写的很明白，所以这里就直接引用了：<a href="https://www.jianshu.com/p/9d8296562806">skip-list 详细分析</a></p></li><li><p><strong>Immutable MemTable</strong>：</p><p>当 MemTable 达到一定大小后，会<strong>转变</strong>成 Immutable MemTable。这个东西是将 MemTable 转变为 SSTable 的一种中间状态。在转存过程中，新来的写操作由新的 MemTable 处理，并不会阻塞数据更新。</p></li><li><p><strong>SSTable</strong>：</p><p>在 Rocksdb 中，每一个磁盘组件被分为若干个 SSTable。简要说一下，SSTable 包含数据块列表和索引块，数据块存储按 key 排序的键值对，索引块存储所有数据块的 key 范围 。对 SSTable 的学习与分析，我也写在了另一篇博客中：<a href="https://yesiyuan.cn/sstable-jie-shao/">SSTable 数据结构分析</a>。</p></li></ul><p>再来看一下，LSM-Tree 的基本结构如下图所示：</p><p><img src="https://s1.ax1x.com/2022/10/12/xUzu01.png" alt="image-20221012170737483"></p><p>注意到，在红框中，已经不是磁盘组件了，而是被分为了多个 SSTable。分区也分为两种，分别针对 leveling 与 tiering，但是在开始介绍两种分区策略之前，请先记住分区的核心思想：</p><blockquote><p>只合并带有重叠键的 SSTable</p></blockquote><h4 id="partitioned-leveling"><a href="#partitioned-leveling" class="headerlink" title="partitioned leveling"></a>partitioned leveling</h4><p>在 partitioned leveling 策略中，每一层依然只有一个磁盘组件，层与层之间的大小比率依然是 T，但是每个磁盘组件都被分为若干个<strong>互不重叠</strong>且大小相近的 SSTable，这就意味着每个 key 在一层中只会出现一次，不存在冗余。该策略的合并步骤为：</p><ol><li>L1 的总大小超过自身空间限制。</li><li>从 L1 中至少选择一个 SSTable，然后把它跟 L2 中有重叠的部分进行合并。</li><li>合并后生成的新 SSTable 先不着急直接至于 L2 中。因为要保证每一个 SSTable 的大小相近，所以合并后需要先分化成多个小点的 SSTable，然后再置于 L2 中。</li><li>如果 L2 合并后的大小超过了自身限制，那么重复上述过程，向 L3 合并。</li></ol><p>用一张图来表示，如下：</p><img src="https://s1.ax1x.com/2022/10/12/xUzltK.png" alt="image-20221012171508914" style="zoom: 50%;" /><p>需要注意的是，L0 的磁盘组件没有分区，因为它们是直接从内存中刷新的。这种设计还可以帮助系统吸收写突发，因为它可以容忍 L0 上的多个未分区组件。</p><h4 id="partitioned-tiering"><a href="#partitioned-tiering" class="headerlink" title="partitioned tiering"></a>partitioned tiering</h4><p>不同于 p-leveling，p-tiering 策略允许层级中包含多个键范围重叠的 SSTable，但是这些 SSTable 必须要通过一定的方式组织起来。在该策略中，有两种组织方式可供选择，分别为<code>垂直分组（vertical grouping）</code>与<code>水平分组（horizontal grouping）</code>。</p><h5 id="vertical-grouping"><a href="#vertical-grouping" class="headerlink" title="vertical grouping"></a>vertical grouping</h5><p>在垂直分组中，每一层级中具有重叠范围的 SSTable 会被分为一组，使得组与组之间不会产生重叠，这样看来，垂直分组像是 p-leveling 的一种变式。其合并流程为：</p><ol><li>L1 的总大小超过自身空间限制。</li><li>从 L1 中至少选择一组，然后将该组内的所有 SSTable 合并。</li><li>合并后，根据 L2 的分组情况，将合并后的内容分为了多个不重叠的 SSTable。</li><li>每一个 SSTable 分别插入 L2 中对应范围的组。</li><li>如果 L2 合并后的大小超过了自身限制，那么重复上述过程，向 L3 合并。</li></ol><p>用一张图来表示，如下：</p><img src="https://s1.ax1x.com/2022/10/12/xUzG1e.png" alt="image-20221012172637184" style="zoom: 50%;" /><h5 id="horizontal-grouping"><a href="#horizontal-grouping" class="headerlink" title="horizontal grouping"></a>horizontal grouping</h5><p>在水平分组中，每一个磁盘组件都自成一组，组与组之间允许有重叠，但是组内的 SSTable 不会有重叠。其合并流程为：</p><ol><li>L1 的总大小超过自身空间限制。</li><li>在 L1 的所有组中选择具有重叠键的 SSTable，将它们合并。</li><li>将合并后的内容分为了多个不重叠的 SSTable，然后放入 L2 中的某一个组中。</li><li>如果 L2 合并后的大小超过了自身限制，那么重复上述过程，向 L3 合并。</li></ol><p>用一张图来表示，如下：</p><img src="https://s1.ax1x.com/2022/10/12/xUzwAP.png" alt="image-20221012173113303" style="zoom: 50%;" /><h4 id="为什么要分区"><a href="#为什么要分区" class="headerlink" title="为什么要分区"></a>为什么要分区</h4><p>无论是哪种分区策略，都有如下两大优点：</p><ul><li>分区将一个大型组件拆分成多个较小的 SSTable，就意味着将原来的大型合并操作拆分为多个较小的合并操作，从而限制了每个合并操作的处理时间以及创建新组件所需的临时磁盘空间。</li><li>分区可以通过只合并具有重叠键的 SSTable 来优化顺序创建 key 的工作负载。对于按顺序创建的 key，基本上不执行合并，因为没有具有重叠键的 SSTable。</li></ul><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><p>可以看到，LSM-Tree 是一种可调性比较高的结构，但却没有一种合并策略能够同时满足读优化与写优化。上面提到的 leveling 和 tiering，前者牺牲了写换取了读，后者牺牲了读换取了写。实际上，现在所做的很多优化工作，都是在 leveling 和 tiering 中进行变式与结合，也面临着读/写/空间的权衡问题。</p><p>综述里一共提到了 7 种优化思路，分别为：</p><ul><li>减少写放大</li><li>优化合并操作</li><li>更大的内存空间</li><li>更好的硬件支持</li><li>针对特殊的工作负载进行优化</li><li>自调和</li><li>二级索引</li></ul><p>在下一篇博客（学习笔记（二））中，我会按照归类将综述中提到的各种优化办法都整理一遍。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSM-Tree </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyKV-2022 项目总结</title>
      <link href="/tinykv-2022-xiang-mu-zong-jie/"/>
      <url>/tinykv-2022-xiang-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大三下暑假才开始的实习，也是我的第一次分布式 lab，之前没做过6.824，所以完成的过程中很折磨，bug 飞来飞去。最后用了6个星期多才完成了项目，并且还是建立在很多基于样例编程的基础上，即使这样也没有完成全部测试点，project3b 还是太难了。</p><p>项目最后需要编写一个文档，里面写了我对四个project的理解以及一些重要函数的实现流程。实际上，如果不做另行优化的话，大部分的函数流程都是固定的，因此只要清楚了思想，至少在宏观上可以减少一些走弯路的风险，接下来就是疯狂对着bug调细节了。文档写的稍微有点书面，而且字不少，直接cp过来有点不合适哈哈哈，所以还是放链接吧：</p><p><a href="https://github.com/sakura-ysy/TinyKV-2022-doc">项目实现文档</a></p><p>实现的思路和流程基本都写进去了，还有个人认为非常关键的 raft 角色转换逻辑，在 project2 的文档中我尝试画图来更直观地去梳理一下，效果还可以。细节写进文档中了，这里我想谈谈一些杂感和心得分享。</p><h2 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h2><p>感受就一个字：痛。</p><p>首先是<strong>花时间</strong>，Code 之前要研读很多东西，比如 raft 论文，不读个两遍我个人是不建议上手敲代码的，还比如代码框架，再比如官方的文档，外加上我还读了一些别人的心得分享。接着就会发现，读完这些后，还是不太好下手，因为整个 raft 都要我们自己来实现，需要从整体的角度去构建。所以会花很多的时间去一点点完善 raft 的所有步骤，不过好在大部分函数/方法官网已经给函数名了，至少知道了方向。实现完了之后就是调 bug，这是最耗费时间的，而且会出现解决了后面的 bug，前面又出了新的 bug 这种情况，这就属于按照测试点 debug 而忽略了实现逻辑上的问题，很难受。解决这些 bug 要花很多的时间，尤其是 project3b 的一些 bug，还随机出现，只能不断地打日志、猜想/验证来去找到 bug 的源头，这会花很多时间，比如有一个我就用了整整3天，那3天项目一点进度都没有，全拿来解决那个 bug 去了。</p><p>前两个 project 都好说。project1 通过研读代码框架直接就可以确定实现逻辑，project2就是仔细仔细读 raft 论文，而且只要是线性测试的，那都不是问题，2b/c的非线性测试也没遇见那种扣破头也解决不了 bug。除去前期对项目整体的熟悉之外，project2 一天半做完了，看网上的分享都是说两三个小时就做完了，我觉得对我来说不现实，毕竟拿到手还要花时间读代码框架，整理 API 啥的，这一下就不止几个小时了，如果说两三个小时是纯 Code 时间，那才差不多能接受。</p><p>然后就是<strong>绝望</strong>。这在 project3b 中尤为明显，在做 Split 的时候，就是会出现很多奇奇怪怪的 bug，而且随机出现，很难复现。有时候，只要这个 bug 出现了我就很高兴，对，没有解决，仅仅是出现，因为这样我就可以通过日志尝试追踪了。在解决3b的一些 bug 时，很多时候我是靠猜的，然后去验证，然后发现猜错了，由此往复。有一个 bug，我调了3天，前两天真的很绝望，没有靠追踪日志来溯源成功，就硬猜，然后一直猜错，都想放弃了。不过好在最后发现了是在 raft 层中的 tick 出了问题，和心跳有关，第三天晚上解决了，不然我快绝望死了。</p><p>最重要的，提升<strong>工程能力</strong>。这点很重要，因为项目不同于小 lab 或者一些算法刷题那样，它需要完完整整的实现一个系统，这就要求我们从整体到细节都要考虑到，不能只拘泥于某一项功能的实现，会很好地锻炼整体性、模块化的开发思想。在组会的时候，基本每周都有大佬建议先不要硬磕测试点，把整个项目结构搞明白了先，这比测试点重要。</p><h2 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h2><p><strong>Project1</strong></p><ul><li>先看看 badger，了解一下 Txn 和 DB；</li><li>读相应的代码框架，在 engine_util 这个包里，整理每个 API 的功能与使用方法；</li></ul><p><strong>Project2</strong></p><ul><li>好好读 raft 论文，其实很多细节在论文中是提到了的；</li><li>参考 etcd，project2 的设计很多都是和 etcd 大同小异的，看 etcd 源码可以有很大的启发；</li><li>写 Project2A 和 2B 的时候可以先不考虑 2C 的内容，因为少了快照，前两个完成起来会相对简单很多，等写到Project2C 再去前面补充就行，并不会影响到代码框架；</li></ul><p><strong>Project3</strong></p><ul><li>心态，心态，还是心态！</li><li>打日志，一定要打日志，多线程的测试，还带随机数，不打日志有些 bug 根本追踪不出来；</li></ul><p><strong>Project4</strong></p><ul><li>这部分刚看会有些困惑，但是实现起来就比较简单，Project123 都能完成了，这肯定没问题；</li></ul><p><strong>其他</strong></p><ul><li>github 上有个 TinyKV 白皮书，如果没思路了可以参考一下，虽然有一些他写错了或者写的不完善；</li><li>调 bug 时遇到的问题和解决办法都记录下来，不仅仅是为了写文档，更能让我们明白项目中忽略的细节；</li><li>多交流，多分享自己遇见的 bug 或者见解，有时候我们碰见的问题，会被别人一点即通；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/maemual/raft-zh_cn">Raft 论文（中/英）</a><ul><li>看中文翻译版的就行，个人认为已经翻译的很好了；</li></ul></li><li><a href="https://github.com/Smith-Cruise/TinyKV-White-Paper">Smith-Cruise 的 TinyKV 白皮书</a><ul><li>如果没有思路的话，可以参考一下，但是有些地方写的并不完善；</li></ul></li><li><a href="https://github.com/etcd-io/etcd">etcd</a><ul><li>会对 project2 有很大的帮助</li></ul></li><li><a href="https://www.luozhiyun.com/archives/609">Percolator 论文（中/英）</a><ul><li>project4 会用到</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jail breaking</title>
      <link href="/jail-breaking/"/>
      <url>/jail-breaking/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一部分为转载，转自<a href="https://tbhaxor.com/breaking-out-of-chroot-jail-shell-environment/">jail-breaking</a></p></blockquote><p>Till now you have been struggling for getting the root user on the system via different techniques. What if I told you are already a root user but still can’t access some files and don’t even have <strong>/root</strong> directory or other directories like <strong>/sys</strong> or <strong>/proc</strong></p><p>Well, don’t get deceived by such root environments. These types of environments are called chroot jails. Today I will put some light on breaking out of chrooting jail environment using the second-chroot method</p><h2 id="What-is-chroot-anyway"><a href="#What-is-chroot-anyway" class="headerlink" title="What is chroot anyway?"></a>What is chroot anyway?</h2><p>Have you ever encountered a situation where the system is powered off while updating the kernel version and when you switch on again, the kernel panic happens? To fix this what actually you do is</p><ol><li>Boot live Linux OS</li><li>Mount the root partition</li><li>Chroot to the new partition and fix the issue</li><li>Reboot the system and remove Live OS USB  </li></ol><p>Chroot is a syscall and command-line utility that <strong>changes the root directory</strong> for the current running process and its children to <strong>create file system level isolation</strong>, don’t confuse it with the current working directory.</p><p>The top of file hierarchy in Linux OS is root (<strong><code>/</code></strong>), you can not go above beyond this. So even if you perform <strong><code>cd ..</code></strong> on the root directory, it will land you in the same directory only. For instance, here I performed *<strong>cd ..*</strong> 100 times on root directory</p><p>Enough talk, let’s see chroot in action</p><p>Here, I am creating the <em>chroot</em> directory, copying files necessary for the chroot environment to spawn a shell and continue execution.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># id -ur ; whoami </span><span class="token number">0</span>root<span class="token comment"># mkdir chroot</span><span class="token comment"># cp -a bin/ usr/ lib/ root/ chroot/</span><span class="token comment"># ls </span>bin     <span class="token function">chroot</span>  dev     etc     home    lib     media  <span class="token punctuation">..</span>. truncated<span class="token comment"># chroot chroot/ sh</span><span class="token comment"># id -ur ; whoami </span><span class="token number">0</span>whoami: unknown uid <span class="token number">0</span><span class="token comment"># ls </span>bin   lib   root  usr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Did you notice, <strong>whoami</strong> command failed with a message “<em>unknown uid 0</em>“, this is because the utility command is looking for <em>/etc/passwd</em> file to compare <em>uid = 0</em> with the name of the user. I did not intentionally copy that directory to show that there is no way for a regular program to break out of the chroot environment and read the real file system.</p><p>However, the environment variables are passed from the host to the chrooted environment.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># export NAME=tbhaxor</span><span class="token comment"># chroot chroot/ </span><span class="token comment"># echo $NAME</span>tbhaxor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>All the commands will inherit the root directory from chroot and environment variables from the host. If you add or modify any environment variables here, it will not affect the host shell</p><p>If you are looking for the real-world use cases of the chroot environment, they are already listed here on its Wikipedia page – <a href="https://en.wikipedia.org/wiki/Chroot#Uses">https://en.wikipedia.org/wiki/Chroot#Uses</a></p><h2 id="Understanding-Process-CWD-vs-ROOT"><a href="#Understanding-Process-CWD-vs-ROOT" class="headerlink" title="Understanding Process CWD vs ROOT"></a>Understanding Process CWD vs ROOT</h2><p>Linux <strong>/proc</strong> filesystem manages two paths for the currently running process.</p><ul><li>cwd – current working directory of the process</li><li>root – root directory of the process</li></ul><p>A root directory is a symlink to the Linux file system where actually the program is running. Usually, it is set to <strong><code>/</code></strong> but for the chrooted environment it is set to the path of the directory passed as the first argument to chroot command. It can not be changed by process directly, but <strong><a href="https://man7.org/linux/man-pages/man2/chroot.2.html">chroot() </a></strong><a href="https://man7.org/linux/man-pages/man2/chroot.2.html">syscall</a> does this.</p><p>The current working directory is the symlink to the directory where the process is currently running from its root directory. This can be easily changed by calling <em>cd</em> shell utility or <a href="https://man7.org/linux/man-pages/man2/chdir.2.html"><strong>chdir()</strong> syscall.</a></p><p>Allow me to show this in a chrooted environment practically. To demonstrate I will keep the <code>**cat**</code> process open on the chrooted environment will look at the <code>/proc</code> file system from the host file system.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ps -eaf</span>PID   <span class="token environment constant">USER</span>     TIME  COMMAND    <span class="token number">1</span> root      <span class="token number">0</span>:00 /bin/sh   <span class="token number">14</span> root      <span class="token number">0</span>:00 <span class="token function">bash</span>   <span class="token number">22</span> root      <span class="token number">0</span>:00 <span class="token function">bash</span>   <span class="token number">58</span> root      <span class="token number">0</span>:00 /bin/sh -i   <span class="token number">60</span> root      <span class="token number">0</span>:00 <span class="token function">cat</span>   <span class="token number">62</span> root      <span class="token number">0</span>:00 <span class="token function">ps</span> -eaf<span class="token comment"># ls -l /proc/60/cwd</span>lrwxrwxrwx    <span class="token number">1</span> root     root             <span class="token number">0</span> Aug <span class="token number">22</span> <span class="token number">22</span>:12 /proc/60/cwd -<span class="token operator">></span> /chroot<span class="token comment"># ls -l /proc/60/root</span>lrwxrwxrwx    <span class="token number">1</span> root     root             <span class="token number">0</span> Aug <span class="token number">22</span> <span class="token number">22</span>:12 /proc/60/root -<span class="token operator">></span> /chroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Now after changing the directory to “<em>/usr/bin</em>“ in the chrooted environment and again run the cat program.</p><p>As you can see, cwd is changed but is appended to the root directory. Apparently, in the host file system, it will start from <strong><code>/</code></strong>, not any other folder like <code>**/chroot**</code> in this case.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN(二): 加密隧道</title>
      <link href="/vpn-er-jia-mi-sui-dao/"/>
      <url>/vpn-er-jia-mi-sui-dao/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VPN(一): UDP隧道</title>
      <link href="/vpn-yi-udp-sui-dao/"/>
      <url>/vpn-yi-udp-sui-dao/</url>
      
        <content type="html"><![CDATA[<p>虚拟专用网络（VPN）用于创建计算机通信的专用通信域，或为专用网络到不安全网络（如Internet）的安全扩展。VPN是一种被广泛使用的安全技术。在<code>IPSec</code>或<code>TLS/SSL</code>上构建VPN是<code>完全不同</code>的两种方法。在本博客以及后续的VPN实验博客中，只关注基于<code>TLS/SSL</code>的VPN。所谓 TLS/SSL，即 传输层安全性/安全套接字层。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在实际环境中，节点只能访问到和其同处一个网络中的其他节点，无法访问到处于它之外的内网中的节点，如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/06/47af7486547be6f3.png"></p><p>我们使用 docker 网络 ”intranet“ 将 HostV 与 VPN 服务器网关的内网口连接，模拟内部局域网。此时，HostU是无法直接访问HostV的。而本实验的目的，就是在HostU和VM之间建立VPN隧道，使其能够通过 Internet 直接访问到HostV。</p><h2 id="TUN-TAP-技术"><a href="#TUN-TAP-技术" class="headerlink" title="TUN/TAP 技术"></a>TUN/TAP 技术</h2><p>TLS/SSL VPN中使用了<code>TUN/TAP</code>技术，其在现代操作系统中已被广泛使用。TUN和TAP是<code>虚拟网络内核驱动程序</code>，它们可以实现完全由<code>软件</code>支持的网络设备。TAP模拟以太网设备，处理链路帧，TUN模拟网络层，处理IP数据报。我们可以用 TAP/TUN 创建<code>虚拟网络接口</code>。</p><p>用户空间程序访问 TUN/TAP 虚拟网络接口，操作系统通过 TUN/TAP 网络接口将数据包传送到用户空间程序。另一方面，程序通过 TUN/TAP 网络接口发送的数据包被注入操作系统的网络栈。在操作系统看来，数据包是<em>通过虚拟网络接口的外部源进来的</em>。</p><p>当程序从TUN/TAP接口读取数据时，计算机发送到此接口的IP数据包将被传送给程序。另一方面，程序发送到接口的IP数据包将被传送到计算机中，就好像这些数据包通过这个虚拟网络接口从外部来的一样。程序可以使用标准的read()和write()系统调用来接口或发送数据包到虚拟接口。</p><p>VPN客户端会运行 <a href="">vpnclient</a>，VPN服务端会运行 <a href="">vpnserver</a>，两个程序分别是VPN隧道的两端，它们使用 TCP 或 UDP 协议，这篇博客用的UDP。VPN客户端和服务端程序通过<code>TUN接口</code>连接到主机系统，做以下两件事：</p><ul><li>从主机系统获取IP数据包，因此数据包可以<code>通过隧道</code>发送；</li><li>从隧道获取IP数据包，然后将其<code>转发</code>到主机系统，主机系统将数据包转发到其最终目的地。</li></ul><p>以我的理解，TUN接口就是对IP进行了重造，使原本无法转发的数据包能被转发，具体的流程如下图所示：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/06/958baa24656974b3.png"></p><p>知道了基本流程后，开始做实验。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验环境为：</p><ul><li>VMware® Workstation 15 Pro</li><li>SeedUbuntu 16.04</li><li>Docker 1.10.3</li></ul><h3 id="1-配置网络拓扑"><a href="#1-配置网络拓扑" class="headerlink" title="1. 配置网络拓扑"></a>1. 配置网络拓扑</h3><p>我们将在计算机（客户端）和网关之间创建 VPN 隧道，允许计算机通过网<br>关安全地访问专用网络。我们使用虚拟机本身作为 VPN 服务器网关（VM），并<br>创建两个容器分别作为 VPN 客户端（HostU）和专用网络中的主机（HostV）。<br>网络设置如下图：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/06/47af7486547be6f3.png"></p><p>在实际环境中，VPN 客户端（HostU）和 VPN 服务器网关的外网口通过<br>Internet 连接。简单起见，我们在本实验中将这两台机器直接连接到同一 docker<br>网络“extranet”，模拟 Internet。第三台机器 HostV 是内部局域网的计算机。Internet 中的主机 HostU 上的用户希望通过 VPN 隧道与内部局域网的主机 HostV 通信。为模拟此设置，我们使用 docker 网络“intranet”将 HostV 与 VPN 服务器网关的内网口连接，模拟内部局域网。在这种设置中，HostV 不能直接从 Internet 访问，即不能直接从 HostU 访问。为实现上述的网络环境配置，我们需要执行以下操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在VM上创建 docker 网络 extranet</span>seed@VM:~$ <span class="token function">sudo</span> <span class="token function">docker</span> network create --subnet<span class="token operator">=</span><span class="token number">10.0</span>.2.0/24 --gateway<span class="token operator">=</span><span class="token number">10.0</span>.2.8 --opt <span class="token string">"com.docker.network.bridge.name"</span><span class="token operator">=</span><span class="token string">"docker1"</span> extranet<span class="token comment"># 在VM上创建 docker 网络 intranet</span>seed@VM:~$ <span class="token function">sudo</span> <span class="token function">docker</span> network create --subnet<span class="token operator">=</span><span class="token number">192.168</span>.60.0/24 --gateway<span class="token operator">=</span><span class="token number">192.168</span>.60.1 --opt <span class="token string">"com.docker.network.bridge.name"</span><span class="token operator">=</span><span class="token string">"docker2"</span> intranet<span class="token comment"># 创建并运行容器HostU</span>seed@VM:~$ <span class="token function">sudo</span> <span class="token function">docker</span> run -it --name<span class="token operator">=</span>HostU --hostname<span class="token operator">=</span>HostU --net<span class="token operator">=</span>extranet --ip<span class="token operator">=</span><span class="token number">10.0</span>.2.7 --privileged <span class="token string">"seedubuntu"</span> /bin/bash<span class="token comment"># 创建并运行容器HostV</span>seed@VM:~$ <span class="token function">sudo</span> <span class="token function">docker</span> run -it --name<span class="token operator">=</span>HostV --hostname<span class="token operator">=</span>HostV --net<span class="token operator">=</span>intranet --ip<span class="token operator">=</span><span class="token number">192.168</span>.60.101 --privileged <span class="token string">"seedubuntu"</span> /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，完成上述工作后，HostU 和 HostV 是可以相互 ping 通的，为了模拟二者不可见的情况，需要将它们的默认路由都删掉：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除默认路由</span>root@HostU:/<span class="token comment"># route delete default</span>root@HostV:/<span class="token comment"># route delete default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://i.bmp.ovh/imgs/2022/05/09/42d6da2cbf3c7bba.png"></p><h3 id="2-运行-VPN-服务器"><a href="#2-运行-VPN-服务器" class="headerlink" title="2. 运行 VPN 服务器"></a>2. 运行 VPN 服务器</h3><p>我们首先在服务器 VM 上运行 VPN 服务器程序 vpnserver。程序运行后，系<br>统中将出现一个虚拟 TUN 网络接口（我们可以使用 <code>ifconfig -a</code> 命令看到它）<br>在大多数情况下，接口的名称将是 <code>tun0</code>，但它们可以是 tunX，其中 X 是一个数<br>字。</p><p><img src="https://i.bmp.ovh/imgs/2022/05/06/17397136e6d3cc21.png"></p><p>此新接口尚未配置，因此我们需要通过为其提供 IP 地址来配置它。我们使用 192.168.53.1 作为此接口的 IP 地址。运行以下命令。第一个命令将启动服务器程序，第二个命令将一个 IP 地址分配给 tun0 接口，然后激活它。由于 ./vpnserver 时守护进程，每次有数据包时都会打印信息，所以开两个终端分别执行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># VM 启动 vpnserver</span>seed@VM:~/vpn$ <span class="token function">sudo</span> ./vpnserver<span class="token comment"># 在 VM 上配置 tun0 虚拟 IP 地址并激活接口</span>seed@VM:~$ <span class="token function">sudo</span> <span class="token function">ifconfig</span> tun0 <span class="token number">192.168</span>.53.1/24 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除非特别配置，否则计算机将仅充当主机，而不充当网关。VPN Server 需要在内网和隧道之间转发报文，因此需要作为<code>网关</code>。我们需要为计算机启用 <code>IP 转发</code>，使其行为类似于网关。由于 VM 上的 <code>iptables</code> 规则可能阻断转发报文，还需要清除 iptables 规则。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># VM 启动 IP转发</span>seed@VM:~/vpn$ <span class="token function">sudo</span> sysctl net.ipv4.ip_forward<span class="token operator">=</span><span class="token number">1</span><span class="token comment"># VM 清除 iptables 规则</span>seed@VM:~/vpn$ <span class="token function">sudo</span> iptables -F<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-运行-VPN-客户端"><a href="#3-运行-VPN-客户端" class="headerlink" title="3. 运行 VPN 客户端"></a>3. 运行 VPN 客户端</h3><p>在 HostU 上运行下面两个命令，第一个命令将启动 VPN 客户端以<code>连接</code>到10.0.2.8 上运行的 VPN 服务器程序，第二个容器在容器 HostU 中配置 tun0 虚拟 IP 地址并激活接口。依然在两个终端分别执行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动 VPN 客户端</span>root@HostU:/vpn<span class="token comment"># ./vpnclient 10.0.2.8</span><span class="token comment"># 配置 tun0 虚拟 IP 地址并激活接口</span>root@HostU:/<span class="token comment"># ifconfig tun0 192.168.53.5/24 up</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后 HostU 中也会出现 tun0 接口：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/09/6474f066a75951a6.png"></p><h3 id="4-在-HostU-设置路由"><a href="#4-在-HostU-设置路由" class="headerlink" title="4. 在 HostU 设置路由"></a>4. <strong>在 HostU 设置路由</strong></h3><p>完成上述两个步骤后，隧道将会建立。在我们使用隧道之前，我们需要在 HostU 和 VPN 服务器上设置路由，以指示通过隧道的预期流量。在 HostU 上，我们需要将所有进入专用网络（192.168.60.0/24）的数据包<code>定向</code>到 tun0 接口，从该接口可以通过 VPN 隧道<code>转发</code>数据包。如果没有此设置，我们将无法访问专用<br>网络。</p><p>使用 route 命令添加路由条目，下述命令会将 192.168.60.0/24 数据包定向到接口tun0：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 增加路由条目</span>root@HostU:/vpn<span class="token comment"># route add -net 192.168.60.0/24 tun0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://i.bmp.ovh/imgs/2022/05/09/973ecd2afceda52e.png"></p><p>至此，HostU 和 VM 之间就建立了 VPN 隧道，HostU 发向 192.168.60.X 的报文都会通过 tun0 转发给 VM 。VM 在将 tun0 解析出的报文转发至 docker2 。</p><p>此时，HostU 的报文已经可以到达 HostV 了，可以尝尝试 ping 一下 HostV，然后用 wireshark 截包，会发现 docker1，tun0，docker2 三个网卡均有报文。</p><p><img src="https://i.bmp.ovh/imgs/2022/05/09/034b05edd68bbdab.png"></p><p>其中，tun0 和 docker2 截获的都是从 192.168.53.5 发往 192.168.60.101 的 ICMP ，因此可以确认，经过tun0 的封装，源 IP 变为了 192.168.53.5 。</p><p><img src="https://i.bmp.ovh/imgs/2022/05/09/95bb1624c74e749a.png"></p><p>值得注意的是，只捕获到了 HostU 发往 HostV 的报文，没有任何 HostV 发往 HostU 的回应。这是因为，前面已经删了 HostV 的默认路由（除了内网之外的所有目的 IP 向网关转发），所以不会对发往 192.168.53.5 的报文进行处理，所以 ping 不同。</p><h3 id="5-在-HostV-上设置路由"><a href="#5-在-HostV-上设置路由" class="headerlink" title="5. 在 HostV 上设置路由"></a>5. <strong>在 HostV 上设置路由</strong></h3><p>得知了源 IP 为 192.168.53.5 之后，可以对这个网段的目的报进行 route 配置，使发往 192.168.53.0/24 网段的报文都均转向网关 192.168.60.1 即可。运行下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@HostV:/<span class="token comment"># route add -net 192.168.53.0/24 gw 192.168.60.1 eth0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.bmp.ovh/imgs/2022/05/09/9b3769658152e72c.png"></p><p>这样 HostV 就可以把响应发给 VM 了。那 VM 需不需要另做配置呢？实际上，只需要一个，就是把发送192.168.53.0/24 网段的报文转给 tun0 接口，但这个路由配置在 tun0 刚创建时已经<code>自动</code>配置好了，所以不需要我们另外做什么配置。</p><p><img src="https://i.bmp.ovh/imgs/2022/05/09/81837eb9eedb077c.png"></p><p>至此，不仅配好了 HostU 和 VM 之间的 VPN 隧道，还配好了 HostU 发往隧道的路由配置与 HostV 回应的路由配置，两者就可以相互通信啦。</p><p>重新 ping 一下看看：</p><p><img src="/VPN-%E4%B8%80-UDP%E9%9A%A7%E9%81%93/image-20220509214058761.png" alt="image-20220509214058761"></p><p>可以看到，ping通了，VPN 隧道里也做转发。</p><p>telnet 一下看看（记得 HostV 要开启 telnet 服务）：</p><p><img src="/VPN-%E4%B8%80-UDP%E9%9A%A7%E9%81%93/image-20220509214547296.png" alt="image-20220509214547296"></p><p>很明显，telnet也成功了，VPN 隧道里有相关的转发。</p><p>现在试着在 VM 里把  VPN 关了。因为 vpnserver 是守护进程，所以需要 kill 掉后台的进程。关了之后，虽然 telnet 连接没断，但是不管输入什么都不会回显了，数据传不到 HostV 了。</p><p><img src="/VPN-%E4%B8%80-UDP%E9%9A%A7%E9%81%93/image-20220509224317747.png" alt="image-20220509224317747"></p><hr><p>好啦，基于 UDP 的 VPN 隧道实验就完了。不过没有进行加密、证书等，显然不是严格意义上的 VPN，下一篇会记录安全 VPN 的实验过程。</p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS缓存中毒攻击</title>
      <link href="/dns-huan-cun-zhong-du-gong-ji/"/>
      <url>/dns-huan-cun-zhong-du-gong-ji/</url>
      
        <content type="html"><![CDATA[<p>众所周知，DNS服务器分为<code>根</code>、<code>顶级域</code>、<code>权威</code>域三个部分，查询时，会从上往下进行查询，从根服务器查顶级域服务器的IP，再从顶级域查权威域的IP，最后从权威域服务器中查最终的IP，返回给<code>本地DNS服务器中</code>。用户机查询域名IP，会首先去本地DNS服务器，如果服务器中有，直接返回结果，否则，重复上述过程。</p><p>而常见的三种DNS攻击，就是针对用户机和本地DNS服务器的。分别为：攻击用户机主机、伪造响应欺骗用户、DNS缓存中毒攻击。三种攻击大致思想如下：</p><p><img src="/DNS%E7%BC%93%E5%AD%98%E4%B8%AD%E6%AF%92%E6%94%BB%E5%87%BB/image-20220415211701047.png" alt="image-20220415211701047"></p><p>本篇将进行常规的本地DNS缓冲中毒的实验。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>实验大环境使用<code>Ubuntu-Seed</code>虚拟机，使用<code>docker</code>容器模拟出DNS服务器和用户机。首先创建对应的容器，注意，<code>--privileged</code>一定不能加，因为这会和<code>bind9</code>向冲突。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建Local DNS Server</span>$ <span class="token function">sudo</span> <span class="token function">docker</span> run -it --name<span class="token operator">=</span>dns --hostname<span class="token operator">=</span>dns seedubuntu /bin/bash<span class="token comment"># 创建User</span>$ <span class="token function">sudo</span> <span class="token function">docker</span> run -it --name<span class="token operator">=</span>user --hostname<span class="token operator">=</span>user seedubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>攻击机直接用虚拟机即可，三者的IP如下：</p><ul><li>Attacker：192.168.186.137</li><li>Local DNS Server：172.17.0.2</li><li>User：172.17.0.3</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先配置服务器。对于本地 DNS 服务器，我们需要运行 DNS 服务器程序。最广泛使用的 DNS服务器软件称为 <code>BIND</code>（Berkeley Internet Name Domain）。<code>bind9</code> 从<code>/etc/bind/named.conf</code> 文件中获取其配置。这个文件是主要的配置文件，它通常包含几个”include”条目，即实际配置 存 储 在 那 些 include 文 件 中 。 其 中 一 个 include 文 件 称 为<code>/etc/bind/named.conf.options</code>。这是我们通常设置配置选项的文件。</p><p>首先设置<code>转储文件</code>，所谓转储，就是把服务器上的所有DNS缓冲转存进去，相当于备份。在<code>/etc/bind/named.conf.options</code>中设置<code>dump-file</code>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">options <span class="token punctuation">&#123;</span>dump<span class="token punctuation">-</span>file "/var/cache/bind/dump.db";<span class="token punctuation">&#125;</span>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当需要转储或清空时，用下列命令即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 转储</span>$ <span class="token function">sudo</span> rndc dumpdb -cache<span class="token comment"># 清空</span>$ <span class="token function">sudo</span> rndc flush<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接着需要关闭<code>DNSSEC</code>。引入DNSSEC 是为了防止对 DNS服务器的 spoofing攻击，所以要关闭。仍然在上面那个文件中进行：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">options <span class="token punctuation">&#123;</span><span class="token comment"># dnssec-validation auto;</span>dnssec<span class="token punctuation">-</span>enable no;<span class="token punctuation">&#125;</span>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动DNS服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">service</span> bind9 restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如有错误，查看错误日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> named -d <span class="token number">3</span> -f -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配完服务器后，开始配用户机。在<code>/etc/resolv.conf</code>中配置，将上述服务器作为它唯一的DNS服务器：</p><p><img src="/DNS%E7%BC%93%E5%AD%98%E4%B8%AD%E6%AF%92%E6%94%BB%E5%87%BB/2.png" alt="2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用AUFS</title>
      <link href="/docker-shi-yong-aufs/"/>
      <url>/docker-shi-yong-aufs/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向代理与内网穿透</title>
      <link href="/fan-xiang-dai-li-yu-nei-wang-chuan-tou/"/>
      <url>/fan-xiang-dai-li-yu-nei-wang-chuan-tou/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnionFS与AUFS</title>
      <link href="/unionfs-yu-aufs/"/>
      <url>/unionfs-yu-aufs/</url>
      
        <content type="html"><![CDATA[<p>AUFS（全称：advanced multi-layered unification filesystem，高级多层统一文件系统），用于为 Linux 文件系统实现<strong>联合挂载</strong>。提到联合挂载，就要先解一下 Union File System。</p><h2 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h2><p>Union File System，简称 UnionFS，是一种为 Linux、FreeBSD 和 NetBSD 操作系统设计的文件系统，它能够多个其他文件系统联合到一个地方来挂载。</p><p>类比一下，就像不同目录合并 mount 到同一个目录中。 它和核心原理有两个：</p><ul><li><strong>分支管理</strong>：它使用 <code>branch </code>把不同文件系统的文件和目录”透明地”覆盖，形成一个单一一致的文件系统。这些 branch 或者是 read-only 的，或者是 read-write 的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。</li><li><strong>写时复制</strong>：copy-on-write，简写为 <code>CoW</code>，也叫隐式共享，是一种提高资源使用效率的资源管理技术。它的思想是：如果一个资源是重复的，在没有对资源做出修改前，并不需要立即复制出一个新的资源实例，这个资源被不同的所有者共享使用。当任何一个所有者要对该资源做出修改时，复制出一个新的资源实例给该所有者进行修改，修改后的资源成为其所有者的私有资源。通过这种资源共享的方式，可以显著地减少复制相同资源带来的消耗，但是这样做也会在进行资源的修改时增加一部分开销。通俗来讲，读时看原来的，第一次写时才复制一个出来。</li></ul><h2 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h2><p>AUFS 又叫 Another UnionFS，后来叫 Alternative UnionFS，后来可能觉得不够霸气，叫成 <code>Advance UnionFS</code>。是个叫  Junjiro Okajima（岡島順治郎）在 2006 年开发的，AUFS 完全重写了早期的 UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS 在使用上全兼容 UnionFS，而且比之前的 UnionFS 在稳定性和性能上都要好很多，后来的 UnionFS 2.x 开始抄 AUFS 中的功能。AUFS的一些实现已经被纳入 UnionFS 2.x 版本。</p><h2 id="模拟实验"><a href="#模拟实验" class="headerlink" title="模拟实验"></a>模拟实验</h2><p>在Linux中，可以通过 mount 命令手动来创建 AUFS，体会下其写时复制的妙处，这里用Ubuntu（CentOS默认不支持AUFS，需要的话得去装支持AUFS的内核）。</p><p>首先创建实验目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~$ <span class="token function">mkdir</span> aufs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在该目录下创建mnt子目录作为FS的挂载点</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~$ <span class="token function">mkdir</span> aufs/mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在aufs目录下创建container-layer文件夹，用来模拟容器的读写层</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~$ <span class="token function">mkdir</span> aufs/container-layer<span class="token comment"># 同时创建文件 container-layer.txt</span>sakura@Sakura-Virture:~$ <span class="token builtin class-name">echo</span> <span class="token string">"I am container layer"</span> <span class="token operator">></span> aufs/container-layer/container-layer.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 aufs 目录下创建三个文件 image-layer1、image-layer2、image-layer3，用来模拟容器的镜像层</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~$ <span class="token function">mkdir</span> aufs/<span class="token punctuation">&#123;</span>image-layer1,image-layer2,image-layer3<span class="token punctuation">&#125;</span>sakura@Sakura-Virture:~$ <span class="token builtin class-name">echo</span> <span class="token string">"I am image layer 1"</span> <span class="token operator">></span> aufs/image-layer1/image-layer1.txtsakura@Sakura-Virture:~$ <span class="token builtin class-name">echo</span> <span class="token string">"I am image layer 2"</span> <span class="token operator">></span> aufs/image-layer2/image-layer2.txtsakura@Sakura-Virture:~$ <span class="token builtin class-name">echo</span> <span class="token string">"I am image layer 3"</span> <span class="token operator">></span> aufs/image-layer3/image-layer3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>做完上述准备工作后，目录结构如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~$ tree aufsaufs├── container-layer│   └── container-layer.txt├── image-layer1│   └── image-layer1.txt├── image-layer2│   └── image-layer2.txt├── image-layer3│   └── image-layer3.txt└── mnt    ├── container-layer.txt    ├── image-layer1.txt    ├── image-layer2.txt    └── image-layer3.txt<span class="token number">5</span> directories, <span class="token number">8</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，开始真正创建AUFS。</p><p>通过 mount 把 container-layer、image-layer1、image-layer2、image-layer3 以 AUFS 的方式挂载到刚才创建的 mnt 目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~$ <span class="token builtin class-name">cd</span> aufssakura@Sakura-Virture:~/aufs$ <span class="token function">sudo</span> <span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span>./container-layer:./image-layer1:./image-layer2:./image-layer3 none ./mnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>挂载完后，四个目录中的文件已经同步给了mnt，查看mnt的文件结构，如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs$ tree mntmnt├── container-layer.txt├── image-layer1.txt├── image-layer2.txt└── image-layer3.txt<span class="token number">0</span> directories, <span class="token number">4</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，原来的四个目录内容是没有任何变化的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs$ <span class="token builtin class-name">cd</span> image-layer2sakura@Sakura-Virture:~/aufs/image-layer2$ <span class="token function">ls</span>image-layer2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，AUFS在创建时，要挂载的目录是由默认的权限配置的。dirs 指定的左边起第一个目录是 read-write 权限，后续目录都是 read-only 权限。可以通过如下方式查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs$ <span class="token function">ls</span> /sys/fs/aufs/config  si_b133c0cc13e24c7b  si_b133c0cddb1e9c7bsakura@Sakura-Virture:~/aufs$ <span class="token function">cat</span> /sys/fs/aufs/si_b133c0cddb1e9c7b/*/home/sakura/aufs/container-layer<span class="token operator">=</span>rw/home/sakura/aufs/image-layer1<span class="token operator">=</span>ro/home/sakura/aufs/image-layer2<span class="token operator">=</span>ro/home/sakura/aufs/image-layer3<span class="token operator">=</span>ro<span class="token number">64</span><span class="token number">65</span><span class="token number">66</span><span class="token number">67</span>/home/sakura/aufs/container-layer/.aufs.xino<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 其中的 si_b133c0cddb1e9c7b目录是系统为 mnt 这个挂载点创建的。</p><p>然后，尝试去写mnt下的某一个文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs$ <span class="token builtin class-name">echo</span> <span class="token string">"I changed mnt/image-layer3.txt"</span> <span class="token operator">>></span> mnt/image-layer3.txtsakura@Sakura-Virture:~/aufs$ <span class="token function">cat</span> mnt/image-layer3.txtI am image layer <span class="token number">3</span>I changed mnt/image-layer3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述操作对mnt中的<code>image-layer3.txt</code>执行了一次写操作（第一次）。查看一下container-layer中的文件结构：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs/container-layer$ tree<span class="token builtin class-name">.</span>├── container-layer.txt└── image-layer3.txt<span class="token number">0</span> directories, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现，其中多出了一个新的文件，打开看看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs/container-layer$ <span class="token function">cat</span> image-layer3.txt I am image layer <span class="token number">3</span>I changed mnt/image-layer3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，该文件不仅仅有在mnt中写入的信息，还保留了在源目录image-layer3中文件image-layer3.txt的信息。那么，image-layer3中有没有发生变化呢？并没有</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs$ <span class="token function">cat</span> image-layer3/image-layer3.txt I am image layer <span class="token number">3</span>sakura@Sakura-Virture:~/aufs$ <span class="token function">ls</span> image-layer1image-layer1.txtsakura@Sakura-Virture:~/aufs$ <span class="token function">ls</span> image-layer2image-layer2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很神奇，不仅仅image-layer3没有变换，imager-layer12也没有发生变化，只有container-layer发生了变化。</p><p>这就是AUF<strong>写时复制</strong>的效果。系统首先在 mnt 目录下查找名为 image-layer3.txt 的文件，将其拷贝到 read-write 层的 container-layer 目录中，接着对 container-layer 目录中的 image-layer3.txt 的文件进行写操作。这个过程也就是 AUFS 的实际工作原理。</p><p>实验结束，清理环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sakura@Sakura-Virture:~/aufs$ <span class="token function">sudo</span> <span class="token function">umount</span> mntsakura@Sakura-Virture:~/aufs$ <span class="token function">sudo</span> <span class="token function">umount</span> mntsakura@Sakura-Virture:~/aufs$ tree<span class="token builtin class-name">.</span>├── container-layer│   ├── container-layer.txt│   └── image-layer3.txt├── image-layer1│   └── image-layer1.txt├── image-layer2│   └── image-layer2.txt├── image-layer3│   └── image-layer3.txt└── mnt<span class="token number">5</span> directories, <span class="token number">5</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>虽然当前 docker 默认的存储驱动已经演进到了 overlay2，但是学习 AUFS 依然可以帮助我们深入理解 docker 中的文件系统。在Docker构建镜像时，就采用了写时复制。</p><p>具体是怎么采用的，以后再说。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之Cgroups</title>
      <link href="/linux-zhi-cgroups/"/>
      <url>/linux-zhi-cgroups/</url>
      
        <content type="html"><![CDATA[<p>在Linux中，使用Namespace技术帮助进程隔离出自己单独的空间，但怎么对这个空间进行限制？比如限制进程申请的资源大小等等，这就要用到Linux的<code>Cgroups</code>技术。</p><p>Linux Cgroups (Control Groups ）提供了对一<code>组</code>进程及将来子进程的资源限制、控制和统计的能力，这些资源包括 CPU、内存、存储、网络等 通过 Cgroups ，可以方便地限制某个进程的资源占用，并且可以实时地监控进程的监控和统计信息。</p><h2 id="3个组件"><a href="#3个组件" class="headerlink" title="3个组件"></a>3个组件</h2><p>Cgroups只是个技术名称，它由三个组件组成，分别为<code>cgroup</code>、<code>subsystem</code>、<code>hierarchy</code>。</p><ul><li><p><strong>cgroup</strong> 是对进程分组管理的一种机制，一个cgroup包含一<code>组</code>进程，并可以在这个cgroup上增加Linux subsystem的各种参数配置，将一组进程和一组subsystem的系统参数关联起来。</p></li><li><p><strong>subsystem</strong> 是一组资源空间模块，就像上面说的，用于资源限制，一般包含如下几项：</p><ul><li>blkio 设置对块设备（比如硬盘）输入输出的访问控制。</li><li>cpu 设置 cgroup 中进程的 CPU 被调度的策略。</li><li>cpuacct 可以统计 cgroup 中进程的 CPU 占用。</li><li>cpuset 在多核机器上设置 cgroup 中进程可以使用的 CPU 和内存（此处内存仅使用于<br>NUMA 架构）。</li><li>devices 控制 cgroup 中进程对设备的访问。</li><li>freezer 用于挂起（ suspend ）和恢复（ resume) cgroup 中的进程。</li><li>memory 用于控制 cgroup 中进程的内存占用。</li><li>net_els 用于将 cgroup 中进程产生的网络包分类，以便 Linux tc (traffic con oller ）可<br>以根据分类区分出来自某个 cgroup 的包并做限流或监控。</li><li>net_prio 设置 cgroup 中进程产生的网络流量的优先级。</li><li>ns 这个 subsystem 比较特殊，它的作用是使 cgroup 中的进程在新的 Namespace fork<br>新进程 CNEWNS ）时，创建出 个新的 cgroup ，这个 cgroup 包含新的 Namespace<br>的进程。</li></ul><p>每个subsystem会关联到定义了相应限制的cgroup上，并对这个cgroup中的进程做相应的限制和控制。这些subsystem是逐步合并到内核中的。可以使用<code>lssubsys</code>查看当前内核支持的subsystem：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ lssubsyscpusetcpu,cpuacctmemorydevicesfreezernet_cls,net_prioblkioperf_eventhugetlbpids<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>hierarchy</strong> 的功能是把一组cgroup串成一个<code>树状</code>的结构，一个这样的树便是一个hierarchy。通过这种树状结构，Cgroups可以做到<code>继承</code>。比如，系统对一组定时的任务进程通过 cgroupl 限制了 CPU 的使用率，然后其中有一个定时 dump 日志的进程还需要限制磁盘 IO ，为了避免限制了磁盘 IO 之后影响到其他进程，就可以创建 cgroup2 ，使其继承于 cgroupl 井限制磁盘的 IO ，这样 cgroup2 便继承了 cgroupl 中对 CPU 使用率的限制，并且增加了磁盘 IO 的限制而不影响到 cgroupl 中的其他进程。也就是说，hierarchy是一组cgroup组成的树。</p></li></ul><h2 id="组件之间的关系"><a href="#组件之间的关系" class="headerlink" title="组件之间的关系"></a>组件之间的关系</h2><p>不难看出，Cgroups是通过上面三个组件的相互协作实现的，他们的关系如下：</p><ul><li>在创建了新的hierarchy之后，系统中所有的进程都会加入这个hierarchy的根cgroup中，这个cgroup是hierarchy默认创建的。对，没听错，所有的进程都会加进去，之后创建的进程也会，哪怕仅仅是用户随便创了个hierarchy玩。</li><li>一个subsystem只能附加到一个hierarchy上面，用于限制其下进程的资源使用。</li><li>一个hierarchy可以附加多个subsystem。</li><li>一个进程可以作为多个cgroup的成员（不然创建hierarchy时就无法把所有进程加进去）。但是，这些cgroup必须在不同的hierarchy中。</li><li>一个进程fork出子进程时，子进程是和父进程在同一个cgroup中的，也可以根据需要将其移动到其他cgroup中。</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>首先，创建并挂载一个hierarchy，这里需要用mount操作，如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建一个hierarchy挂载点</span><span class="token punctuation">[</span>root@master sakura<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> cgroup-test<span class="token comment"># 挂载该hierarchy</span><span class="token punctuation">[</span>root@master sakura<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">mount</span> -t cgroup -o none,name<span class="token operator">=</span>cgroup-test cgroup-test ./cgroup-test<span class="token comment"># 该目录就成了hierarchy的根cgroup</span><span class="token punctuation">[</span>root@master sakura<span class="token punctuation">]</span>$ <span class="token function">ls</span> ./cgroup-test/cgroup.clone_children  cgroup.event_control  cgroup.procs  cgroup.sane_behavior  notify_on_release  release_agent  tasks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当指定挂载的filesystem类型为cgroup后，目录下多个很多文件。这些文件就是cgroup根节点的配置项，上面的文件含义分别如下：</p><ul><li>cgroup.clone_children：cpuset subsystem 会读取这个配置文件，如果这个值是1（默认为0），子cgroup才会继承父cgroup的cpuset的配置。</li><li>cgroup.procs：是树中当前节点 cgroup 中的进程组 ID ，现在的位置是在根节点，这个文件中会有现在系统中所有进程组的 ID。</li><li>notify_on_release，release agent：这俩会一起使用。 notify on release 标识当这个 cgroup后一个进程退出的时候是否执行了 release_agent，release_ agent 则是 个路径，通常用作进程退出之后自动清理掉不再使用的 cgroup。</li><li>tasks：标识该cgroup下面的进程ID，如果把一个进程ID写到tasks文件中，便会将相应的进程加入到这个cgroup中。</li></ul><p>之前说了，创建hierarchy后会把系统所有进程到加入到根cgroup中，所以cgroup.procs一个记录了所以进程组的ID，tasks中记录了所有进程的ID：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ <span class="token function">cat</span> tasks<span class="token number">1</span><span class="token comment"># ...当前所有进程ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，在上述根cgroup中创建两个子cgroup，就是两个目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> cgroup1<span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> cgroup2<span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ tree<span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── cgroup1│   ├── cgroup.clone_children│   ├── cgroup.event_control│   ├── cgroup.procs│   ├── notify_on_release│   └── tasks├── cgroup2│   ├── cgroup.clone_children│   ├── cgroup.event_control│   ├── cgroup.procs│   ├── notify_on_release│   └── tasks├── cgroup.clone_children├── cgroup.event_control├── cgroup.procs├── cgroup.sane_behavior├── notify_on_release├── release_agent└── tasks<span class="token number">2</span> directories, <span class="token number">17</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在一个cgroup的目录下创建文件时，内核会把文件夹标记为这个cgroup的子cgroup，它们会继承父cgroup的属性。</p><p>一个进程在hierarchy中，只能在一个cgroup节点上存在，系统的所有进程都会默认在根cgroup上存在，可以将进程移动到其他cgroup上，只需要将进程ID写到对应的cgroup的tasks文件中即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>sakura@master cgroup-test<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> cgroup1<span class="token punctuation">[</span>sakura@master cgroup1<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token punctuation">..</span>/tasks <span class="token operator">|</span> <span class="token function">grep</span> <span class="token variable">$$</span><span class="token number">101308</span><span class="token punctuation">[</span>sakura@master cgroup1<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo <span class="token variable">$$</span> >> tasks"</span><span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> sakura 的密码：<span class="token punctuation">[</span>sakura@master cgroup1<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token punctuation">..</span>/tasks <span class="token operator">|</span> <span class="token function">grep</span> <span class="token variable">$$</span><span class="token punctuation">[</span>sakura@master cgroup1<span class="token punctuation">]</span>$ <span class="token function">cat</span> ./tasks <span class="token operator">|</span> <span class="token function">grep</span> <span class="token variable">$$</span><span class="token number">101308</span><span class="token punctuation">[</span>sakura@master cgroup1<span class="token punctuation">]</span>$ <span class="token function">cat</span> /proc/<span class="token variable">$$</span>/cgroup<span class="token number">23</span>:name<span class="token operator">=</span>cgroup-test:/cgroup1<span class="token number">11</span>:freezer:/<span class="token number">10</span>:pids:/user.slice<span class="token number">9</span>:cpuset:/<span class="token number">8</span>:memory:/user.slice<span class="token number">7</span>:cpuacct,cpu:/user.slice<span class="token number">6</span>:hugetlb:/<span class="token number">5</span>:devices:/user.slice<span class="token number">4</span>:blkio:/user.slice<span class="token number">3</span>:perf_event:/<span class="token number">2</span>:net_prio,net_cls:/<span class="token number">1</span>:name<span class="token operator">=</span>systemd:/user.slice/user-1000.slice/session-1.scope<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当进程ID被写入hierarchy中另一个cgroup的tasks中时，它会自动的从原cgroup的tasks中移除。通过最后一条命令可知，一个进程可以属于多个cgroup，但是cgroup必须位于不同的hierarchy。</p><p>但是到此为止，这个hierarchy并没有关联到任何的subsystem，所以没办法通过其中的cgroup来限制进程的资源占用。</p><p>实际上，系统已经为每个subsystem创建好了一个默认的hierarchy，位于<code>/sys/fs/cgroup/</code>下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ <span class="token function">ls</span> /sys/fs/cgroupblkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  systemdcpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者用另外一种方法查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master cgroup-test<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> cgrouptmpfs on /sys/fs/cgroup <span class="token builtin class-name">type</span> tmpfs <span class="token punctuation">(</span>ro,nosuid,nodev,noexec,mode<span class="token operator">=</span><span class="token number">755</span><span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/systemd <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,xattr,release_agent<span class="token operator">=</span>/usr/lib/systemd/systemd-cgroups-agent,name<span class="token operator">=</span>systemd<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,net_prio,net_cls<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/perf_event <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,perf_event<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/blkio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,blkio<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/devices <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,devices<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/hugetlb <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,hugetlb<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpuacct,cpu<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/memory <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,memory<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/cpuset <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/pids <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,pids<span class="token punctuation">)</span>cgroup on /sys/fs/cgroup/freezer <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,freezer<span class="token punctuation">)</span>cgroup-test on /home/sakura/cgroup-test <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,relatime,name<span class="token operator">=</span>cgroup-test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以memory举例，<code>/sys/fs/cgroup/memory</code>目录便是他的hierarchy的根cgroup。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master memory<span class="token punctuation">]</span><span class="token comment"># ls</span>cgroup.clone_children       memory.kmem.max_usage_in_bytes      memory.memsw.limit_in_bytes      memory.usage_in_bytescgroup.event_control        memory.kmem.slabinfo                memory.memsw.max_usage_in_bytes  memory.use_hierarchycgroup.procs                memory.kmem.tcp.failcnt             memory.memsw.usage_in_bytes      notify_on_releasecgroup.sane_behavior        memory.kmem.tcp.limit_in_bytes      memory.move_charge_at_immigrate  release_agentkubepods.slice              memory.kmem.tcp.max_usage_in_bytes  memory.numa_stat                 system.slicemachine.slice               memory.kmem.tcp.usage_in_bytes      memory.oom_control               tasksmemory.failcnt              memory.kmem.usage_in_bytes          memory.pressure_level            <span class="token builtin class-name">test</span>memory.force_empty          memory.limit_in_bytes               memory.soft_limit_in_bytes       user.slicememory.kmem.failcnt         memory.max_usage_in_bytes           memory.statmemory.kmem.limit_in_bytes  memory.memsw.failcnt                memory.swappiness<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同于不做限制的hierarchy，附加了subsystem的hierarchy下会多出很多相关的配置文件，不同的subsystem有所不同。</p><p>接下来，在其中创建一个子cgroup，名为test：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master memory<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> <span class="token builtin class-name">test</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">ls</span>cgroup.clone_children           memory.kmem.slabinfo                memory.memsw.failcnt             memory.soft_limit_in_bytescgroup.event_control            memory.kmem.tcp.failcnt             memory.memsw.limit_in_bytes      memory.statcgroup.procs                    memory.kmem.tcp.limit_in_bytes      memory.memsw.max_usage_in_bytes  memory.swappinessmemory.failcnt                  memory.kmem.tcp.max_usage_in_bytes  memory.memsw.usage_in_bytes      memory.usage_in_bytesmemory.force_empty              memory.kmem.tcp.usage_in_bytes      memory.move_charge_at_immigrate  memory.use_hierarchymemory.kmem.failcnt             memory.kmem.usage_in_bytes          memory.numa_stat                 notify_on_releasememory.kmem.limit_in_bytes      memory.limit_in_bytes               memory.oom_control               tasksmemory.kmem.max_usage_in_bytes  memory.max_usage_in_bytes           memory.pressure_level<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完毕后，然后在<code> memory.limit_in_bytes</code>中限制该cgroup中的进程最大只能占用100M的内存，然后在该cgroup下启动一个占用200M的进程，查看情况。注意，当前的bash进程并不属于该cgroup，而stree进程是bash的子进程，所以要先把bash进程移入该cgroup，stree自然就进去了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 内存使用限制在100M</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo "</span>100m<span class="token string">" > memory.limit_in_bytes"</span><span class="token comment"># 将当前bash进程加入该cgroup</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo <span class="token variable">$$</span> > tasks"</span><span class="token comment"># 压力测试, 申请占用200M</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ stress --vm-bytes 200m --vm-keep -m <span class="token number">1</span>stress: info: <span class="token punctuation">[</span><span class="token number">31547</span><span class="token punctuation">]</span> dispatching hogs: <span class="token number">0</span> cpu, <span class="token number">0</span> io, <span class="token number">1</span> vm, <span class="token number">0</span> hddstress: FAIL: <span class="token punctuation">[</span><span class="token number">31547</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">415</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>-- worker <span class="token number">31548</span> got signal <span class="token number">9</span>stress: WARN: <span class="token punctuation">[</span><span class="token number">31547</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">417</span><span class="token punctuation">)</span> now reaping child worker processesstress: FAIL: <span class="token punctuation">[</span><span class="token number">31547</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">451</span><span class="token punctuation">)</span> failed run completed <span class="token keyword">in</span> 0s<span class="token comment"># 重新测试，申请内存少于100M</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ stress --vm-bytes <span class="token number">99</span>.99m --vm-keep -m <span class="token number">1</span>stress: info: <span class="token punctuation">[</span><span class="token number">31840</span><span class="token punctuation">]</span> dispatching hogs: <span class="token number">0</span> cpu, <span class="token number">0</span> io, <span class="token number">1</span> vm, <span class="token number">0</span> hdd<span class="token comment">#.. 成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当通过memory这一subsystem将cgroup下的进程占用内存限制在100M以内后，所有需要100M内存以上的进程都无法在该cgroup下运行，达到资源限制的目的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s源码(二): Pod创建过程中Container的卷挂载</title>
      <link href="/k8s-yuan-ma-er-pod-chuang-jian-guo-cheng-zhong-container-de-juan-gua-zai/"/>
      <url>/k8s-yuan-ma-er-pod-chuang-jian-guo-cheng-zhong-container-de-juan-gua-zai/</url>
      
        <content type="html"><![CDATA[<p>​    直入正题，本文意在整理出Pod创建过程中和Volume挂载有关的源码及其调用过程。这部分的源码解读我并没有找到什么参考资料，所以会不全，也可能有错。</p><h2 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h2><p>直接从<code>syncPod</code>开始看，如上一篇博客（Pod创建流程）中所写，该方法会在创建Pod前进行一些准备工作，比如创建基础目录什么的。方法的最后，它会调用<code>WaitForAttachAndMount</code>等待Pod请求的Volume进行attach和mount，之后，调用<code>SyncPod</code>真正开始创建Pod，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// syncPod is the transaction script for the sync of a single pod.</span><span class="token comment">//</span><span class="token comment">// Arguments:</span><span class="token comment">//</span><span class="token comment">// o - the SyncPodOptions for this invocation</span><span class="token comment">//</span><span class="token comment">// The workflow is:</span><span class="token comment">// * If the pod is being created, record pod worker start latency</span><span class="token comment">// * Call generateAPIPodStatus to prepare an v1.PodStatus for the pod</span><span class="token comment">// * If the pod is being seen as running for the first time, record pod</span><span class="token comment">//   start latency</span><span class="token comment">// * Update the status of the pod in the status manager</span><span class="token comment">// * Kill the pod if it should not be running</span><span class="token comment">// * Create a mirror pod if the pod is a static pod, and does not</span><span class="token comment">//   already have a mirror pod</span><span class="token comment">// * Create the data directories for the pod if they do not exist</span><span class="token comment">// * Wait for volumes to attach/mount</span><span class="token comment">// * Fetch the pull secrets for the pod</span><span class="token comment">// * Call the container runtime's SyncPod callback</span><span class="token comment">// * Update the traffic shaping for the pod's ingress and egress limits</span><span class="token comment">//</span><span class="token comment">// If any step of this workflow errors, the error is returned, and is repeated</span><span class="token comment">// on the next syncPod call.</span><span class="token comment">//</span><span class="token comment">// This operation writes all events that are dispatched in order to provide</span><span class="token comment">// the most accurate information possible about an error situation to aid debugging.</span><span class="token comment">// Callers should not throw an event if this operation returns an error.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncPod</span><span class="token punctuation">(</span>o syncPodOptions<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token comment">// Volume manager will not mount volumes for terminated pods</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Wait for volumes to attach/mount</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>volumeManager<span class="token punctuation">.</span><span class="token function">WaitForAttachAndMount</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedMountVolume<span class="token punctuation">,</span> <span class="token string">"Unable to mount volumes for pod %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to mount volumes for pod %q: %v; skipping pod"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span><span class="token comment">// Call the container runtime's SyncPod callback</span>result <span class="token operator">:=</span> kl<span class="token punctuation">.</span>containerRuntime<span class="token punctuation">.</span><span class="token function">SyncPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> apiPodStatus<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> kl<span class="token punctuation">.</span>backOff<span class="token punctuation">)</span>kl<span class="token punctuation">.</span>reasonCache<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Do not record an event here, as we keep all event logging for sync pod failures</span><span class="token comment">// local to container runtime so we get better errors</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为要最终Volume挂咋过程，所以进入<code>WaitForAttachAndMount</code>中看看，该方法位于<code>pkg/kubelet/volumemanager/volume_manager.go</code>中。</p><h3 id="WaitForAttachAndMount"><a href="#WaitForAttachAndMount" class="headerlink" title="WaitForAttachAndMount"></a>WaitForAttachAndMount</h3><p>源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>vm <span class="token operator">*</span>volumeManager<span class="token punctuation">)</span> <span class="token function">WaitForAttachAndMount</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 得到Pod预期要挂载的volume列表</span>expectedVolumes <span class="token operator">:=</span> <span class="token function">getExpectedVolumes</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>expectedVolumes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// No volumes to verify</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Waiting for volumes to attach and mount for pod %q"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 得到Pod的唯一标识</span>uniquePodName <span class="token operator">:=</span> volumehelper<span class="token punctuation">.</span><span class="token function">GetUniquePodName</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token comment">// Some pods expect to have Setup called over and over again to update.</span><span class="token comment">// Remount plugins for which this is true. (Atomically updating volumes,</span><span class="token comment">// like Downward API, depend on this to update the contents of the volume).</span>vm<span class="token punctuation">.</span>desiredStateOfWorldPopulator<span class="token punctuation">.</span><span class="token function">ReprocessPod</span><span class="token punctuation">(</span>uniquePodName<span class="token punctuation">)</span>vm<span class="token punctuation">.</span>actualStateOfWorld<span class="token punctuation">.</span><span class="token function">MarkRemountRequired</span><span class="token punctuation">(</span>uniquePodName<span class="token punctuation">)</span>    <span class="token comment">// 阻塞并循环检测，直到Pod预期的卷全部挂载</span>err <span class="token operator">:=</span> wait<span class="token punctuation">.</span><span class="token function">Poll</span><span class="token punctuation">(</span>podAttachAndMountRetryInterval<span class="token punctuation">,</span>podAttachAndMountTimeout<span class="token punctuation">,</span>vm<span class="token punctuation">.</span><span class="token function">verifyVolumesMountedFunc</span><span class="token punctuation">(</span>uniquePodName<span class="token punctuation">,</span> expectedVolumes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Timeout expired</span>unmountedVolumes <span class="token operator">:=</span>vm<span class="token punctuation">.</span><span class="token function">getUnmountedVolumes</span><span class="token punctuation">(</span>uniquePodName<span class="token punctuation">,</span> expectedVolumes<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>unmountedVolumes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"timeout expired waiting for volumes to attach/mount for pod %q/%q. list of unattached/unmounted volumes=%v"</span><span class="token punctuation">,</span>pod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span>pod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>unmountedVolumes<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"All volumes are attached and mounted for pod %q"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法从大体上来看目的很明确，就是一直等到Pod请求挂载的Volume全部挂载完毕，整个等待过程分为四步：</p><ol><li>调用<code>getExpectedVolumes</code>来获得Pod预期挂载的所有卷的卷名，返回一个string切片。</li><li>调用<code>desiredStateOfWorldPopulator.ReprocessPod</code>，将该Pod从ProcessedPod列表中删除，迫使它被重新处理。</li><li>调用<code>actualStateOfWorld.MarkRemountRequired</code>，对已经挂载到该Pod上且需要重新挂载的Volume进行标记。</li><li>使用<code>wait.Poll</code>阻塞进程并持续检测，没测检测都调用<code>verifyVolumesMountedFunc</code>来查看是否该Pod预期挂载的所有Volume都已挂载完毕。</li></ol><p>首先是<code>getExpectedVolumes</code>，这个方法体很简单，就是通过遍历<code>pod.Spec.Volumes</code>字段获取全部预期挂载的Volume名而已，这里不细说了。</p><p>至于<code>ReprocessPod</code>和<code>MarkRemountRequired</code>，这两个方法我并不是很明白，这个涉及到dsw和asw了，我只能试着理解个大概。</p><p>首先看<code>ReprocessPod</code>，这个方法位于<code>pkg/kubelet/volumemanager/populator/desired_state_of_world_populator.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>dswp <span class="token operator">*</span>desiredStateOfWorldPopulator<span class="token punctuation">)</span> <span class="token function">ReprocessPod</span><span class="token punctuation">(</span>podName volumetypes<span class="token punctuation">.</span>UniquePodName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dswp<span class="token punctuation">.</span><span class="token function">deleteProcessedPod</span><span class="token punctuation">(</span>podName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// markPodProcessed removes the specified pod from processedPods</span><span class="token keyword">func</span> <span class="token punctuation">(</span>dswp <span class="token operator">*</span>desiredStateOfWorldPopulator<span class="token punctuation">)</span> <span class="token function">deleteProcessedPod</span><span class="token punctuation">(</span>podName volumetypes<span class="token punctuation">.</span>UniquePodName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dswp<span class="token punctuation">.</span>pods<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> dswp<span class="token punctuation">.</span>pods<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">delete</span><span class="token punctuation">(</span>dswp<span class="token punctuation">.</span>pods<span class="token punctuation">.</span>processedPods<span class="token punctuation">,</span> podName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这个代码实现其实很简单，仅仅是将该Pod从<code>processedPods</code>Map中删除。且这个Map结构也很简单，是个&lt;string, bool&gt;型，我不知道把Pod从中删除后会发生什么，还有待学习。</p><p>然后就是<code>MarkRemountRequired</code>，这个方法就比较复杂了，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>asw <span class="token operator">*</span>actualStateOfWorld<span class="token punctuation">)</span> <span class="token function">MarkRemountRequired</span><span class="token punctuation">(</span>podName volumetypes<span class="token punctuation">.</span>UniquePodName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>asw<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> asw<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// attachedVolumes is a map containing the set of volumes the kubelet volume manager believes to be successfully attached to this node</span><span class="token keyword">for</span> volumeName<span class="token punctuation">,</span> volumeObj <span class="token operator">:=</span> <span class="token keyword">range</span> asw<span class="token punctuation">.</span>attachedVolumes <span class="token punctuation">&#123;</span><span class="token keyword">for</span> mountedPodName<span class="token punctuation">,</span> podObj <span class="token operator">:=</span> <span class="token keyword">range</span> volumeObj<span class="token punctuation">.</span>mountedPods <span class="token punctuation">&#123;</span><span class="token keyword">if</span> mountedPodName <span class="token operator">!=</span> podName <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>volumePlugin<span class="token punctuation">,</span> err <span class="token operator">:=</span>asw<span class="token punctuation">.</span>volumePluginMgr<span class="token punctuation">.</span><span class="token function">FindPluginBySpec</span><span class="token punctuation">(</span>volumeObj<span class="token punctuation">.</span>spec<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> volumePlugin <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Log and continue processing</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"MarkRemountRequired failed to FindPluginBySpec for pod %q (podUid %q) volume: %q (volSpecName: %q)"</span><span class="token punctuation">,</span>podObj<span class="token punctuation">.</span>podName<span class="token punctuation">,</span>podObj<span class="token punctuation">.</span>podUID<span class="token punctuation">,</span>volumeObj<span class="token punctuation">.</span>volumeName<span class="token punctuation">,</span>volumeObj<span class="token punctuation">.</span>spec<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> volumePlugin<span class="token punctuation">.</span><span class="token function">RequiresRemount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>podObj<span class="token punctuation">.</span>remountRequired <span class="token operator">=</span> <span class="token boolean">true</span>asw<span class="token punctuation">.</span>attachedVolumes<span class="token punctuation">[</span>volumeName<span class="token punctuation">]</span><span class="token punctuation">.</span>mountedPods<span class="token punctuation">[</span>podName<span class="token punctuation">]</span> <span class="token operator">=</span> podObj<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然看上去比较复杂，但逻辑很简单。首先，从<code>asw.attachedVolumes</code>中获取到已经attach到这个node的Volume列表，然后遍历整个列表。对于列表中的所有Volume，遍历挂载这Volume的所有Pod，如果是当前Pod，则继续操作，反之下一个。</p><p>遍历到该Pod挂载的Volume后，通过<code>FindPluginBySpec</code>找到可以支持整个Volume的插件。然后通过插件来判断这个Volume是否需要重挂载，如果需要的话，就加一个标记，把对应字段设为true，仅此而已。我也不知道设为true之后会发生什么。</p><p>接着，开始持续调用<code>verifyVolumesMountedFunc</code>来判断是否所有预测Volume都已挂载，来看看它的判断流程：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// verifyVolumesMountedFunc returns a method that returns true when all expected</span><span class="token comment">// volumes are mounted.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>vm <span class="token operator">*</span>volumeManager<span class="token punctuation">)</span> <span class="token function">verifyVolumesMountedFunc</span><span class="token punctuation">(</span>podName types<span class="token punctuation">.</span>UniquePodName<span class="token punctuation">,</span> expectedVolumes <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> wait<span class="token punctuation">.</span>ConditionFunc <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>done <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">getUnmountedVolumes</span><span class="token punctuation">(</span>podName<span class="token punctuation">,</span> expectedVolumes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// getUnmountedVolumes fetches the current list of mounted volumes from</span><span class="token comment">// the actual state of the world, and uses it to process the list of</span><span class="token comment">// expectedVolumes. It returns a list of unmounted volumes.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>vm <span class="token operator">*</span>volumeManager<span class="token punctuation">)</span> <span class="token function">getUnmountedVolumes</span><span class="token punctuation">(</span>podName types<span class="token punctuation">.</span>UniquePodName<span class="token punctuation">,</span> expectedVolumes <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>mountedVolumes <span class="token operator">:=</span> sets<span class="token punctuation">.</span><span class="token function">NewString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> mountedVolume <span class="token operator">:=</span> <span class="token keyword">range</span> vm<span class="token punctuation">.</span>actualStateOfWorld<span class="token punctuation">.</span><span class="token function">GetMountedVolumesForPod</span><span class="token punctuation">(</span>podName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mountedVolumes<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>mountedVolume<span class="token punctuation">.</span>OuterVolumeSpecName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">filterUnmountedVolumes</span><span class="token punctuation">(</span>mountedVolumes<span class="token punctuation">,</span> expectedVolumes<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法会调用<code>getUnmountedVolumes</code>来得到该Pod预期挂载但还未挂载的Volume数，如果为0才返回true。先看看<code>GetMountedVolumesForPod</code>，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>asw <span class="token operator">*</span>actualStateOfWorld<span class="token punctuation">)</span> <span class="token function">GetMountedVolumesForPod</span><span class="token punctuation">(</span>podName volumetypes<span class="token punctuation">.</span>UniquePodName<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>MountedVolume <span class="token punctuation">&#123;</span>asw<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> asw<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mountedVolume <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>MountedVolume<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/* len */</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>asw<span class="token punctuation">.</span>attachedVolumes<span class="token punctuation">)</span> <span class="token comment">/* cap */</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> volumeObj <span class="token operator">:=</span> <span class="token keyword">range</span> asw<span class="token punctuation">.</span>attachedVolumes <span class="token punctuation">&#123;</span><span class="token keyword">for</span> mountedPodName<span class="token punctuation">,</span> podObj <span class="token operator">:=</span> <span class="token keyword">range</span> volumeObj<span class="token punctuation">.</span>mountedPods <span class="token punctuation">&#123;</span><span class="token keyword">if</span> mountedPodName <span class="token operator">==</span> podName <span class="token punctuation">&#123;</span>mountedVolume <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>mountedVolume<span class="token punctuation">,</span><span class="token function">getMountedVolume</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>podObj<span class="token punctuation">,</span> <span class="token operator">&amp;</span>volumeObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> mountedVolume<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码比较明晰。首先，它加的是一个读锁，说明并不会改变asw。后面的两层for循环逻辑和之前那个一模一样，先通过<code>asw.attachedVolumes</code>得到已经attach到node的所有Volume，在通过podName匹配挂载到该Pod的Volume。只不过，它需要调用<code>getMountedVolume</code>组装成一个新的结构<code>MountedVolume</code>，然后包成切片返回，没什么好说的。</p><p>在来看看<code>filterUnmountedVolumes</code>是如何过滤的，其源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// filterUnmountedVolumes adds each element of expectedVolumes that is not in</span><span class="token comment">// mountedVolumes to a list of unmountedVolumes and returns it.</span><span class="token keyword">func</span> <span class="token function">filterUnmountedVolumes</span><span class="token punctuation">(</span>mountedVolumes sets<span class="token punctuation">.</span>String<span class="token punctuation">,</span> expectedVolumes <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>unmountedVolumes <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> expectedVolume <span class="token operator">:=</span> <span class="token keyword">range</span> expectedVolumes <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>mountedVolumes<span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span>expectedVolume<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>unmountedVolumes <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>unmountedVolumes<span class="token punctuation">,</span> expectedVolume<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> unmountedVolumes<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，逻辑也很简单，还是遍历。遍历expectedVolumes，如果mountedVolumes中不存在这个Volume，就说明该挂载但是还未挂载。</p><p>至此，<code>WaitForAttachAndMount</code>也就结束了。在上面的代码中，都只是进行一些检测与判断，并没有进行实际的挂载。也就是说，真正的Volume挂载到Pod的操作，并不在这里完成，换句话说，到这里时宿主机的Volume已经完成了挂载。而实际的挂载过程，应该在<code>volumnManager</code>中进行的，但是这不部分我还没读懂，欠努力。</p><p>Volume和Pod如何挂载的我还没弄清，还要学习。接下来，只着眼于Pod中的Container是如何挂载到上述Volume的。</p><h2 id="SyncPod"><a href="#SyncPod" class="headerlink" title="SyncPod"></a>SyncPod</h2><p>回到<code>syncPod</code>，执行完上述的等待后，调用<code>getPullSecretsForPod</code>将Pod的secrets拉下来，但在这里不重要。重要的是最后要调用的<code>SyncPod</code>，看看它的源码，位于<code>pkg/kubelet/kuberuntime/kuberuntime_manager.go</code>中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">SyncPod</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> <span class="token boolean">_</span> v1<span class="token punctuation">.</span>PodStatus<span class="token punctuation">,</span> podStatus <span class="token operator">*</span>kubecontainer<span class="token punctuation">.</span>PodStatus<span class="token punctuation">,</span> pullSecrets <span class="token punctuation">[</span><span class="token punctuation">]</span>v1<span class="token punctuation">.</span>Secret<span class="token punctuation">,</span> backOff <span class="token operator">*</span>flowcontrol<span class="token punctuation">.</span>Backoff<span class="token punctuation">)</span> <span class="token punctuation">(</span>result kubecontainer<span class="token punctuation">.</span>PodSyncResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Step 1: Compute sandbox and container changes.</span><span class="token comment">// 检擦Pod Spec是否发生改变，如果是，将这些改变记录下来</span>podContainerChanges <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">computePodActions</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"computePodActions got %+v for pod %q"</span><span class="token punctuation">,</span> podContainerChanges<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> ref<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>legacyscheme<span class="token punctuation">.</span>Scheme<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Couldn't make a ref to pod %q: '%v'"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>SandboxID <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeNormal<span class="token punctuation">,</span> events<span class="token punctuation">.</span>SandboxChanged<span class="token punctuation">,</span> <span class="token string">"Pod sandbox changed, it will be killed and re-created."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncPod received new pod %q, will create a sandbox for it"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 2: Kill the pod if the sandbox has changed.</span><span class="token comment">// kill掉 sandbox 已经改变的 pod</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>KillPod <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Stopping PodSandbox for %q because all other containers are dead."</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Stopping PodSandbox for %q, will start new one"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>killResult <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">killPodWithSyncResult</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kubecontainer<span class="token punctuation">.</span><span class="token function">ConvertPodStatusToRunningPod</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>runtimeName<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddPodSyncResult</span><span class="token punctuation">(</span>killResult<span class="token punctuation">)</span><span class="token keyword">if</span> killResult<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"killPodWithSyncResult failed: %v"</span><span class="token punctuation">,</span> killResult<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">purgeInitContainers</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// Step 3: kill any running containers in this pod which are not to keep.</span><span class="token comment">// kill掉ContainersToKill列表中的container</span><span class="token keyword">for</span> containerID<span class="token punctuation">,</span> containerInfo <span class="token operator">:=</span> <span class="token keyword">range</span> podContainerChanges<span class="token punctuation">.</span>ContainersToKill <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Killing unwanted container %q(id=%q) for pod %q"</span><span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>killContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>KillContainer<span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>killContainerResult<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">killContainer</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>message<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>killContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ErrKillContainer<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"killContainer %q(id=%q) for pod %q failed: %v"</span><span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Keep terminated init containers fairly aggressively controlled</span><span class="token comment">// This is an optmization because container removals are typically handled</span><span class="token comment">// by container garbage collector.</span><span class="token comment">// 删除一些Init Container，减少容器垃圾收集器上的负载</span>m<span class="token punctuation">.</span><span class="token function">pruneInitContainersBeforeStart</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token comment">// We pass the value of the podIP down to generatePodSandboxConfig and</span><span class="token comment">// generateContainerConfig, which in turn passes it to various other</span><span class="token comment">// functions, in order to facilitate functionality that requires this</span><span class="token comment">// value (hosts file and downward API) and avoid races determining</span><span class="token comment">// the pod IP in cases where a container requires restart but the</span><span class="token comment">// podIP isn't in the status manager yet.</span><span class="token comment">//</span><span class="token comment">// We default to the IP in the passed-in pod status, and overwrite it if the</span><span class="token comment">// sandbox needs to be (re)started.</span>podIP <span class="token operator">:=</span> <span class="token string">""</span><span class="token keyword">if</span> podStatus <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>podIP <span class="token operator">=</span> podStatus<span class="token punctuation">.</span>IP<span class="token punctuation">&#125;</span><span class="token comment">// Step 4: Create a sandbox for the pod if necessary.</span><span class="token comment">// 为pod创建sandbox，如果需要的话</span>podSandboxID <span class="token operator">:=</span> podContainerChanges<span class="token punctuation">.</span>SandboxID<span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span><span class="token keyword">var</span> msg <span class="token builtin">string</span><span class="token keyword">var</span> err <span class="token builtin">error</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating sandbox for pod %q"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>createSandboxResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>CreatePodSandbox<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>createSandboxResult<span class="token punctuation">)</span>podSandboxID<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">createPodSandbox</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podContainerChanges<span class="token punctuation">.</span>Attempt<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>createSandboxResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ErrCreatePodSandbox<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"createPodSandbox for pod %q failed: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> ref<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>legacyscheme<span class="token punctuation">.</span>Scheme<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Couldn't make a ref to pod %q: '%v'"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedCreatePodSandBox<span class="token punctuation">,</span> <span class="token string">"Failed create pod sandbox."</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Created PodSandbox %q for pod %q"</span><span class="token punctuation">,</span> podSandboxID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>podSandboxStatus<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>runtimeService<span class="token punctuation">.</span><span class="token function">PodSandboxStatus</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> ref<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>legacyscheme<span class="token punctuation">.</span>Scheme<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Couldn't make a ref to pod %q: '%v'"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedStatusPodSandBox<span class="token punctuation">,</span> <span class="token string">"Unable to get pod sandbox status: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to get pod sandbox status: %v; Skipping pod %q"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// If we ever allow updating a pod from non-host-network to</span><span class="token comment">// host-network, we may use a stale IP.</span><span class="token keyword">if</span> <span class="token operator">!</span>kubecontainer<span class="token punctuation">.</span><span class="token function">IsHostNetworkPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Overwrite the podIP passed in the pod status, since we just started the pod sandbox.</span>podIP <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">determinePodSandboxIP</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> podSandboxStatus<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Determined the ip %q for pod %q after sandbox changed"</span><span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Get podSandboxConfig for containers to start.</span>configPodSandboxResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ConfigPodSandbox<span class="token punctuation">,</span> podSandboxID<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>configPodSandboxResult<span class="token punctuation">)</span><span class="token comment">//生成Sandbox的config配置，如pod的DNS、hostName、端口映射</span>podSandboxConfig<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">generatePodSandboxConfig</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podContainerChanges<span class="token punctuation">.</span>Attempt<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>message <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"GeneratePodSandboxConfig for pod %q failed: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>configPodSandboxResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ErrConfigPodSandbox<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 5: start the init container.</span><span class="token comment">// 启动初始化容器</span><span class="token keyword">if</span> container <span class="token operator">:=</span> podContainerChanges<span class="token punctuation">.</span>NextInitContainerToStart<span class="token punctuation">;</span> container <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Start the next init container.</span>startContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>StartContainer<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>startContainerResult<span class="token punctuation">)</span>isInBackOff<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">doBackOff</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> backOff<span class="token punctuation">)</span><span class="token keyword">if</span> isInBackOff <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Backing Off restarting init container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating init container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 启动</span><span class="token keyword">if</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"init container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// Successfully started the container; clear the entry in the failure</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Completed init container %q for pod %q"</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 6: start containers in podContainerChanges.ContainersToStart.</span><span class="token comment">// 启动主容器</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> idx <span class="token operator">:=</span> <span class="token keyword">range</span> podContainerChanges<span class="token punctuation">.</span>ContainersToStart <span class="token punctuation">&#123;</span>container <span class="token operator">:=</span> <span class="token operator">&amp;</span>pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>Containers<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>startContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>StartContainer<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>startContainerResult<span class="token punctuation">)</span>isInBackOff<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">doBackOff</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> backOff<span class="token punctuation">)</span><span class="token keyword">if</span> isInBackOff <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Backing Off restarting container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 启动</span><span class="token keyword">if</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token comment">// known errors that are logged in other places are logged at higher levels here to avoid</span><span class="token comment">// repetitive log spam</span><span class="token keyword">switch</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> err <span class="token operator">==</span> images<span class="token punctuation">.</span>ErrImagePullBackOff<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法之前也说过，首先会调用<code>computePodActions</code>计算一下有哪些Pod Spec中的变化，实际上就是一些是否需要执行动作。将这些变换记录在<code>podContainerChanges</code>中，是一个<code>podActions</code>结构：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// podActions keeps information what to do for a pod.</span><span class="token keyword">type</span> podActions <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>KillPod <span class="token builtin">bool</span>CreateSandbox <span class="token builtin">bool</span>SandboxID <span class="token builtin">string</span>Attempt <span class="token builtin">uint32</span>NextInitContainerToStart <span class="token operator">*</span>v1<span class="token punctuation">.</span>ContainerContainersToStart <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>ContainersToKill <span class="token keyword">map</span><span class="token punctuation">[</span>kubecontainer<span class="token punctuation">.</span>ContainerID<span class="token punctuation">]</span>containerToKillInfo<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用完后就可以看见，下面再疯狂的<code>if-else</code>，因为要根据<code>podActions</code>来选取对应的动作。因为我们要创建Pod，所以只专注于<code>ContainersToStart</code>部分：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Step 6: start containers in podContainerChanges.ContainersToStart.</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> idx <span class="token operator">:=</span> <span class="token keyword">range</span> podContainerChanges<span class="token punctuation">.</span>ContainersToStart <span class="token punctuation">&#123;</span>container <span class="token operator">:=</span> <span class="token operator">&amp;</span>pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>Containers<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>startContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>StartContainer<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>startContainerResult<span class="token punctuation">)</span>isInBackOff<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">doBackOff</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> backOff<span class="token punctuation">)</span><span class="token keyword">if</span> isInBackOff <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Backing Off restarting container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token comment">// known errors that are logged in other places are logged at higher levels here to avoid</span><span class="token comment">// repetitive log spam</span><span class="token keyword">switch</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> err <span class="token operator">==</span> images<span class="token punctuation">.</span>ErrImagePullBackOff<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，其中最最核心的方法就是<code>startContainer</code>，这个方法会首先对容器生成一些配置，然后在启动该容器，我们要研究的Volume挂载过程就在里面。</p><h2 id="startContainer"><a href="#startContainer" class="headerlink" title="startContainer"></a>startContainer</h2><p>进入这个方法看一下，它位于<code>pkg/kubelet/kuberuntime/kuberuntime_container.go</code>中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// startContainer starts a container and returns a message indicates why it is failed on error.</span><span class="token comment">// It starts the container through the following steps:</span><span class="token comment">// * pull the image</span><span class="token comment">// * create the container</span><span class="token comment">// * start the container</span><span class="token comment">// * run the post start lifecycle hooks (if applicable)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID <span class="token builtin">string</span><span class="token punctuation">,</span> podSandboxConfig <span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>PodSandboxConfig<span class="token punctuation">,</span> container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">,</span> pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> podStatus <span class="token operator">*</span>kubecontainer<span class="token punctuation">.</span>PodStatus<span class="token punctuation">,</span> pullSecrets <span class="token punctuation">[</span><span class="token punctuation">]</span>v1<span class="token punctuation">.</span>Secret<span class="token punctuation">,</span> podIP <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Step 1: pull the image.</span>imageRef<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>imagePuller<span class="token punctuation">.</span><span class="token function">EnsureImageExists</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreateContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// Step 2: create the container.</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">GenerateContainerRef</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Can't make a ref to pod %q, container %v: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Generating ref for container %s: %#v"</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token comment">// For a new container, the RestartCount should be 0</span>restartCount <span class="token operator">:=</span> <span class="token number">0</span>containerStatus <span class="token operator">:=</span> podStatus<span class="token punctuation">.</span><span class="token function">FindContainerStatusByName</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token keyword">if</span> containerStatus <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>restartCount <span class="token operator">=</span> containerStatus<span class="token punctuation">.</span>RestartCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>containerConfig<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">generateContainerConfig</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> restartCount<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> imageRef<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreateContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> ErrCreateContainerConfig<span class="token punctuation">&#125;</span>containerID<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>runtimeService<span class="token punctuation">.</span><span class="token function">CreateContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> containerConfig<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreateContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> ErrCreateContainer<span class="token punctuation">&#125;</span>err <span class="token operator">=</span> m<span class="token punctuation">.</span>internalLifecycle<span class="token punctuation">.</span><span class="token function">PreStartContainer</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToStartContainer<span class="token punctuation">,</span> <span class="token string">"Internal PreStartContainer hook failed: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token string">"Internal PreStartContainer hook failed"</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeNormal<span class="token punctuation">,</span> events<span class="token punctuation">.</span>CreatedContainer<span class="token punctuation">,</span> <span class="token string">"Created container"</span><span class="token punctuation">)</span><span class="token keyword">if</span> ref <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span>containerRefManager<span class="token punctuation">.</span><span class="token function">SetRef</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ContainerID<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> m<span class="token punctuation">.</span>runtimeName<span class="token punctuation">,</span>ID<span class="token punctuation">:</span>   containerID<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 3: start the container.</span>err <span class="token operator">=</span> m<span class="token punctuation">.</span>runtimeService<span class="token punctuation">.</span><span class="token function">StartContainer</span><span class="token punctuation">(</span>containerID<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToStartContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> kubecontainer<span class="token punctuation">.</span>ErrRunContainer<span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeNormal<span class="token punctuation">,</span> events<span class="token punctuation">.</span>StartedContainer<span class="token punctuation">,</span> <span class="token string">"Started container"</span><span class="token punctuation">)</span><span class="token comment">// Symlink container logs to the legacy container log location for cluster logging</span><span class="token comment">// support.</span><span class="token comment">// TODO(random-liu): Remove this after cluster logging supports CRI container log path.</span>containerMeta <span class="token operator">:=</span> containerConfig<span class="token punctuation">.</span><span class="token function">GetMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span>sandboxMeta <span class="token operator">:=</span> podSandboxConfig<span class="token punctuation">.</span><span class="token function">GetMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span>legacySymlink <span class="token operator">:=</span> <span class="token function">legacyLogSymlink</span><span class="token punctuation">(</span>containerID<span class="token punctuation">,</span> containerMeta<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> sandboxMeta<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>sandboxMeta<span class="token punctuation">.</span>Namespace<span class="token punctuation">)</span>containerLog <span class="token operator">:=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>podSandboxConfig<span class="token punctuation">.</span>LogDirectory<span class="token punctuation">,</span> containerConfig<span class="token punctuation">.</span>LogPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>osInterface<span class="token punctuation">.</span><span class="token function">Symlink</span><span class="token punctuation">(</span>containerLog<span class="token punctuation">,</span> legacySymlink<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to create legacy symbolic link %q to container %q log %q: %v"</span><span class="token punctuation">,</span>legacySymlink<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> containerLog<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 4: execute the post start hook.</span><span class="token keyword">if</span> container<span class="token punctuation">.</span>Lifecycle <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> container<span class="token punctuation">.</span>Lifecycle<span class="token punctuation">.</span>PostStart <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kubeContainerID <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span>ContainerID<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> m<span class="token punctuation">.</span>runtimeName<span class="token punctuation">,</span>ID<span class="token punctuation">:</span>   containerID<span class="token punctuation">,</span><span class="token punctuation">&#125;</span>msg<span class="token punctuation">,</span> handlerErr <span class="token operator">:=</span> m<span class="token punctuation">.</span>runner<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>kubeContainerID<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Lifecycle<span class="token punctuation">.</span>PostStart<span class="token punctuation">)</span><span class="token keyword">if</span> handlerErr <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> kubeContainerID<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedPostStartHook<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">killContainer</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kubeContainerID<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token string">"FailedPostStartHook"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to kill container %q(id=%q) in pod %q: %v, %v"</span><span class="token punctuation">,</span>container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> kubeContainerID<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> ErrPostStartHook<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> msg<span class="token punctuation">,</span> ErrPostStartHook<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法大致分为三个部分：</p><ol><li>拉取容器镜像；</li><li>创建容器；</li><li>启动这个容器。</li></ol><p>其中，最核心的就是第二步创建容器。这里只看核心步骤它会先调用<code>generateContainerConfig</code>生成容器的配置，然后将该配置传给<code>CreateContainer</code>来创建容器。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/129ed1ea963b2faa.png"></p><p>来一个个看。</p><h3 id="generateContainerConfig"><a href="#generateContainerConfig" class="headerlink" title="generateContainerConfig"></a>generateContainerConfig</h3><p>方法位于<code>pkg/kubelet/kuberuntime/kuberuntime_container.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// generateContainerConfig generates container config for kubelet runtime v1.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">generateContainerConfig</span><span class="token punctuation">(</span>container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">,</span> pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> restartCount <span class="token builtin">int</span><span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> imageRef <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>ContainerConfig<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>opts<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>runtimeHelper<span class="token punctuation">.</span><span class="token function">GenerateRunContainerOptions</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>uid<span class="token punctuation">,</span> username<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">getImageUser</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>Image<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// Verify RunAsNonRoot. Non-root verification only supports numeric user.</span><span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">verifyRunAsNonRoot</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>command<span class="token punctuation">,</span> args <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">ExpandContainerCommandAndArgs</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>Envs<span class="token punctuation">)</span>containerLogsPath <span class="token operator">:=</span> <span class="token function">buildContainerLogsPath</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> restartCount<span class="token punctuation">)</span>restartCountUint32 <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>restartCount<span class="token punctuation">)</span>config <span class="token operator">:=</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>ContainerConfig<span class="token punctuation">&#123;</span>Metadata<span class="token punctuation">:</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>ContainerMetadata<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span>    container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>Attempt<span class="token punctuation">:</span> restartCountUint32<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Image<span class="token punctuation">:</span>       <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>ImageSpec<span class="token punctuation">&#123;</span>Image<span class="token punctuation">:</span> imageRef<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Command<span class="token punctuation">:</span>     command<span class="token punctuation">,</span>Args<span class="token punctuation">:</span>        args<span class="token punctuation">,</span>WorkingDir<span class="token punctuation">:</span>  container<span class="token punctuation">.</span>WorkingDir<span class="token punctuation">,</span>Labels<span class="token punctuation">:</span>      <span class="token function">newContainerLabels</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token punctuation">,</span>Annotations<span class="token punctuation">:</span> <span class="token function">newContainerAnnotations</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> restartCount<span class="token punctuation">)</span><span class="token punctuation">,</span>Devices<span class="token punctuation">:</span>     <span class="token function">makeDevices</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">,</span>Mounts<span class="token punctuation">:</span>      m<span class="token punctuation">.</span><span class="token function">makeMounts</span><span class="token punctuation">(</span>opts<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">,</span>LogPath<span class="token punctuation">:</span>     containerLogsPath<span class="token punctuation">,</span>Stdin<span class="token punctuation">:</span>       container<span class="token punctuation">.</span>Stdin<span class="token punctuation">,</span>StdinOnce<span class="token punctuation">:</span>   container<span class="token punctuation">.</span>StdinOnce<span class="token punctuation">,</span>Tty<span class="token punctuation">:</span>         container<span class="token punctuation">.</span>TTY<span class="token punctuation">,</span>Linux<span class="token punctuation">:</span>       m<span class="token punctuation">.</span><span class="token function">generateLinuxContainerConfig</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// set environment variables</span>envs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>KeyValue<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>Envs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> idx <span class="token operator">:=</span> <span class="token keyword">range</span> opts<span class="token punctuation">.</span>Envs <span class="token punctuation">&#123;</span>e <span class="token operator">:=</span> opts<span class="token punctuation">.</span>Envs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>envs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>KeyValue<span class="token punctuation">&#123;</span>Key<span class="token punctuation">:</span>   e<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>Value<span class="token punctuation">:</span> e<span class="token punctuation">.</span>Value<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>config<span class="token punctuation">.</span>Envs <span class="token operator">=</span> envs<span class="token keyword">return</span> config<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法会先调用<code>GenerateRunContainerOptions</code>生成一个opts，是一个<code>RunContainerOptions</code>结构，该结构字段如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RunContainerOptions <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Envs                    <span class="token punctuation">[</span><span class="token punctuation">]</span>EnvVar    Mounts                  <span class="token punctuation">[</span><span class="token punctuation">]</span>Mount    Devices                 <span class="token punctuation">[</span><span class="token punctuation">]</span>DeviceInfo    PortMappings            <span class="token punctuation">[</span><span class="token punctuation">]</span>PortMapping    PodContainerDir         <span class="token builtin">string</span>    CgroupParent            <span class="token builtin">string</span>    ReadOnly                <span class="token builtin">bool</span>    Hostname                <span class="token builtin">string</span>    EnableHostUserNamespace <span class="token builtin">bool</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中就有我们要的更挂载相关的字段<code>Mounts</code>。生成完opts之后，会调用<code>getImageUser</code>得到用户。接着，调用<code>ExpandContainerCommandAndArgs</code>来得到容器命令和参数，调用<code>buildContainerLogsPath</code>生成日志文件路径。最后，通过这些参数创建一个<code>ContainerConfig</code>类型的结构变量，就是容器配置。</p><p>我们要关注该结构中的<code>Mounts</code>字段，该字段决定了容器创建时的Volume挂载。通过<code>m.makeMounts(opts, container)</code>生成挂载映射表，赋值给它。</p><p>先来看看opts是怎么生成了，然后在回头看这个<code>m.makeMounts</code>。</p><h4 id="GenerateRunContainerOptions"><a href="#GenerateRunContainerOptions" class="headerlink" title="GenerateRunContainerOptions"></a>GenerateRunContainerOptions</h4><p>方法位于<code>pkg/kubelet/kubelet_pods.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// GenerateRunContainerOptions generates the RunContainerOptions, which can be used by</span><span class="token comment">// the container runtime to set parameters for launching a container.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">GenerateRunContainerOptions</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">,</span> podIP <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>kubecontainer<span class="token punctuation">.</span>RunContainerOptions<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 创建一个空的opts（RunContainerOptions）</span>opts<span class="token punctuation">,</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>containerManager<span class="token punctuation">.</span><span class="token function">GetResources</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// 得到Pod的cgroup parent</span>cgroupParent <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">GetPodCgroupParent</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span>opts<span class="token punctuation">.</span>CgroupParent <span class="token operator">=</span> cgroupParent<span class="token comment">// 为Pod创建hostname和hostDomainName</span>hostname<span class="token punctuation">,</span> hostDomainName<span class="token punctuation">,</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">GeneratePodHostNameAndDomain</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>opts<span class="token punctuation">.</span>Hostname <span class="token operator">=</span> hostname<span class="token comment">// podName为唯一标识符</span>podName <span class="token operator">:=</span> volumehelper<span class="token punctuation">.</span><span class="token function">GetUniquePodName</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token comment">// 获取pod挂载的Volume</span>volumes <span class="token operator">:=</span> kl<span class="token punctuation">.</span>volumeManager<span class="token punctuation">.</span><span class="token function">GetMountedVolumesForPod</span><span class="token punctuation">(</span>podName<span class="token punctuation">)</span><span class="token comment">// 构建容器的端口映射表</span>opts<span class="token punctuation">.</span>PortMappings <span class="token operator">=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">MakePortMappings</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token comment">// TODO(random-liu): Move following convert functions into pkg/kubelet/container</span>devices<span class="token punctuation">,</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">makeGPUDevices</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>opts<span class="token punctuation">.</span>Devices <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>Devices<span class="token punctuation">,</span> devices<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// TODO: remove feature gate check after no longer needed</span><span class="token keyword">if</span> utilfeature<span class="token punctuation">.</span>DefaultFeatureGate<span class="token punctuation">.</span><span class="token function">Enabled</span><span class="token punctuation">(</span>features<span class="token punctuation">.</span>BlockVolume<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>blkutil <span class="token operator">:=</span> volumeutil<span class="token punctuation">.</span><span class="token function">NewBlockVolumePathHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>blkVolumes<span class="token punctuation">,</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">makeBlockVolumes</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> volumes<span class="token punctuation">,</span> blkutil<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>opts<span class="token punctuation">.</span>Devices <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>Devices<span class="token punctuation">,</span> blkVolumes<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 生成挂载映射表1</span>mounts<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">makeMounts</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kl<span class="token punctuation">.</span><span class="token function">getPodDir</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> hostDomainName<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> volumes<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>opts<span class="token punctuation">.</span>Mounts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>Mounts<span class="token punctuation">,</span> mounts<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 生成环境变量表</span>envs<span class="token punctuation">,</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">makeEnvironmentVariables</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>opts<span class="token punctuation">.</span>Envs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>Envs<span class="token punctuation">,</span> envs<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// Disabling adding TerminationMessagePath on Windows as these files would be mounted as docker volume and</span><span class="token comment">// Docker for Windows has a bug where only directories can be mounted</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>TerminationMessagePath<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> runtime<span class="token punctuation">.</span>GOOS <span class="token operator">!=</span> <span class="token string">"windows"</span> <span class="token punctuation">&#123;</span><span class="token comment">// 创建容器路径</span>p <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">getPodContainerDir</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Error on creating %q: %v"</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>opts<span class="token punctuation">.</span>PodContainerDir <span class="token operator">=</span> p<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// only do this check if the experimental behavior is enabled, otherwise allow it to default to false</span><span class="token comment">// 如果有需求, 允许Pod内的容器共享宿主机的namespace</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>experimentalHostUserNamespaceDefaulting <span class="token punctuation">&#123;</span>opts<span class="token punctuation">.</span>EnableHostUserNamespace <span class="token operator">=</span> kl<span class="token punctuation">.</span><span class="token function">enableHostUserNamespace</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> opts<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该方法会逐步生成需要指定的各种Options字段，流程如下：</p><ol><li>调用<code>GetResources</code>创建一个空的opts（RunContainerOptions结构变量），进入这个方法会发现它仅仅返回一个空的结构指针；</li><li>调用<code>GetPodCgroupParent</code>来获取Pod的cgroup parent；</li><li>调用<code>GeneratePodHostNameAndDomain</code>来为Pod创建hostname，hostDomainName；</li><li>调用<code>GetUniquePodName</code>得到该Pod的唯一标识符；</li><li>调用<code>GetMountedVolumesForPod</code>来获取Pod挂载的Volume。注意，这个方法是位于volumeManager中的，但是它内部是通过调用之前那个<code>asw.GetMountedVolumesForPod</code>来获取相关信息的，这里不再展开；</li><li>调用<code>MakePortMappings</code>来构建容器的端口映射表；</li><li>进行一些设备相关的配置；</li><li>调用kubelet包中的<code>makeMounts</code>来初步生成容器的的挂载映射表；</li><li>调用<code>makeEnvironmentVariables</code>来生成环境变量表；</li><li>创建容器在Pod所处目录下的路径，这一步就是简单的路径拼接和目录创建；</li><li>如果需要的话，允许Pod内的容器共享宿主机的namespace；</li></ol><p>其中，跟容器内卷挂载配置相关的操作就是第8步，这里深入<code>makeMounts</code>看看挂载表是如何生成的。</p><h5 id="makeMounts（kublet包）"><a href="#makeMounts（kublet包）" class="headerlink" title="makeMounts（kublet包）"></a>makeMounts（kublet包）</h5><p>该方法位于<code>pkg/kubelet/kubelet_pods.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 决定容器的挂载点</span><span class="token comment">// makeMounts determines the mount points for the given container.</span><span class="token keyword">func</span> <span class="token function">makeMounts</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> podDir <span class="token builtin">string</span><span class="token punctuation">,</span> container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">,</span> hostName<span class="token punctuation">,</span> hostDomain<span class="token punctuation">,</span> podIP <span class="token builtin">string</span><span class="token punctuation">,</span> podVolumes kubecontainer<span class="token punctuation">.</span>VolumeMap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>kubecontainer<span class="token punctuation">.</span>Mount<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Kubernetes only mounts on /etc/hosts if:</span><span class="token comment">// - container is not an infrastructure (pause) container</span><span class="token comment">// - container is not already mounting on /etc/hosts</span><span class="token comment">// - OS is not Windows</span><span class="token comment">// Kubernetes will not mount /etc/hosts if:</span><span class="token comment">// - when the Pod sandbox is being created, its IP is still unknown. Hence, PodIP will not have been set.</span>mountEtcHostsFile <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>podIP<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> runtime<span class="token punctuation">.</span>GOOS <span class="token operator">!=</span> <span class="token string">"windows"</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"container: %v/%v/%v podIP: %q creating hosts mount: %v"</span><span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> mountEtcHostsFile<span class="token punctuation">)</span><span class="token comment">// 创建一个空的挂载映射表</span>mounts <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>kubecontainer<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> mount <span class="token operator">:=</span> <span class="token keyword">range</span> container<span class="token punctuation">.</span>VolumeMounts <span class="token punctuation">&#123;</span><span class="token comment">// do not mount /etc/hosts if container is already mounting on the path</span>mountEtcHostsFile <span class="token operator">=</span> mountEtcHostsFile <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mount<span class="token punctuation">.</span>MountPath <span class="token operator">!=</span> etcHostsPath<span class="token punctuation">)</span>vol<span class="token punctuation">,</span> ok <span class="token operator">:=</span> podVolumes<span class="token punctuation">[</span>mount<span class="token punctuation">.</span>Name<span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token operator">||</span> vol<span class="token punctuation">.</span>Mounter <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Mount cannot be satisfied for container %q, because the volume is missing or the volume mounter is nil: %+v"</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> mount<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"cannot find volume %q to mount into container %q"</span><span class="token punctuation">,</span> mount<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>relabelVolume <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token comment">// If the volume supports SELinux and it has not been</span><span class="token comment">// relabeled already and it is not a read-only volume,</span><span class="token comment">// relabel it and mark it as labeled</span><span class="token keyword">if</span> vol<span class="token punctuation">.</span>Mounter<span class="token punctuation">.</span><span class="token function">GetAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Managed <span class="token operator">&amp;&amp;</span> vol<span class="token punctuation">.</span>Mounter<span class="token punctuation">.</span><span class="token function">GetAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>SupportsSELinux <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vol<span class="token punctuation">.</span>SELinuxLabeled <span class="token punctuation">&#123;</span>vol<span class="token punctuation">.</span>SELinuxLabeled <span class="token operator">=</span> <span class="token boolean">true</span>relabelVolume <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span>hostPath<span class="token punctuation">,</span> err <span class="token operator">:=</span> volume<span class="token punctuation">.</span><span class="token function">GetPath</span><span class="token punctuation">(</span>vol<span class="token punctuation">.</span>Mounter<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token keyword">if</span> mount<span class="token punctuation">.</span>SubPath <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> filepath<span class="token punctuation">.</span><span class="token function">IsAbs</span><span class="token punctuation">(</span>mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"error SubPath `%s` must not be an absolute path"</span><span class="token punctuation">,</span> mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>err <span class="token operator">=</span> volumevalidation<span class="token punctuation">.</span><span class="token function">ValidatePathNoBacksteps</span><span class="token punctuation">(</span>mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unable to provision SubPath `%s`: %v"</span><span class="token punctuation">,</span> mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fileinfo<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Lstat</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>perm <span class="token operator">:=</span> fileinfo<span class="token punctuation">.</span><span class="token function">Mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>hostPath <span class="token operator">=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span><span class="token keyword">if</span> subPathExists<span class="token punctuation">,</span> err <span class="token operator">:=</span> utilfile<span class="token punctuation">.</span><span class="token function">FileOrSymlinkExists</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Could not determine if subPath %s exists; will not attempt to change its permissions"</span><span class="token punctuation">,</span> hostPath<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token operator">!</span>subPathExists <span class="token punctuation">&#123;</span><span class="token comment">// Create the sub path now because if it's auto-created later when referenced, it may have an</span><span class="token comment">// incorrect ownership and mode. For example, the sub path directory must have at least g+rwx</span><span class="token comment">// when the pod specifies an fsGroup, and if the directory is not created here, Docker will</span><span class="token comment">// later auto-create it with the incorrect mode 0750</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"failed to mkdir:%s"</span><span class="token punctuation">,</span> hostPath<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// chmod the sub path because umask may have prevented us from making the sub path with the same</span><span class="token comment">// permissions as the mounter path</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Chmod</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Docker Volume Mounts fail on Windows if it is not of the form C:/</span>containerPath <span class="token operator">:=</span> mount<span class="token punctuation">.</span>MountPath<span class="token keyword">if</span> runtime<span class="token punctuation">.</span>GOOS <span class="token operator">==</span> <span class="token string">"windows"</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">||</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> <span class="token string">"\\"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>hostPath <span class="token operator">=</span> <span class="token string">"c:"</span> <span class="token operator">+</span> hostPath<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>filepath<span class="token punctuation">.</span><span class="token function">IsAbs</span><span class="token punctuation">(</span>containerPath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>containerPath <span class="token operator">=</span> <span class="token function">makeAbsolutePath</span><span class="token punctuation">(</span>runtime<span class="token punctuation">.</span>GOOS<span class="token punctuation">,</span> containerPath<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>propagation<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">translateMountPropagation</span><span class="token punctuation">(</span>mount<span class="token punctuation">.</span>MountPropagation<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Pod %q container %q mount %q has propagation %q"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> mount<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> propagation<span class="token punctuation">)</span>mounts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>mounts<span class="token punctuation">,</span> kubecontainer<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span>           mount<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>ContainerPath<span class="token punctuation">:</span>  containerPath<span class="token punctuation">,</span>HostPath<span class="token punctuation">:</span>       hostPath<span class="token punctuation">,</span>ReadOnly<span class="token punctuation">:</span>       mount<span class="token punctuation">.</span>ReadOnly<span class="token punctuation">,</span>SELinuxRelabel<span class="token punctuation">:</span> relabelVolume<span class="token punctuation">,</span>Propagation<span class="token punctuation">:</span>    propagation<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> mountEtcHostsFile <span class="token punctuation">&#123;</span>hostAliases <span class="token operator">:=</span> pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>HostAliaseshostsMount<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">makeHostsMount</span><span class="token punctuation">(</span>podDir<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> hostName<span class="token punctuation">,</span> hostDomain<span class="token punctuation">,</span> hostAliases<span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>HostNetwork<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>mounts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>mounts<span class="token punctuation">,</span> <span class="token operator">*</span>hostsMount<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> mounts<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分析该源码之前，先看下<code>VolumMount</code>这个结构体，即Pod.Spec.Container.VolumeMount，是Pod中容器的卷挂载请求信息，如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// VolumeMount describes a mounting of a Volume within a container.</span><span class="token keyword">type</span> VolumeMount <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// This must match the Name of a Volume.</span>Name <span class="token builtin">string</span> <span class="token string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span><span class="token comment">// Mounted read-only if true, read-write otherwise (false or unspecified).</span><span class="token comment">// Defaults to false.</span><span class="token comment">// +optional</span>ReadOnly <span class="token builtin">bool</span> <span class="token string">`json:"readOnly,omitempty" protobuf:"varint,2,opt,name=readOnly"`</span><span class="token comment">// Path within the container at which the volume should be mounted.  Must</span><span class="token comment">// not contain ':'.</span>MountPath <span class="token builtin">string</span> <span class="token string">`json:"mountPath" protobuf:"bytes,3,opt,name=mountPath"`</span><span class="token comment">// Path within the volume from which the container's volume should be mounted.</span><span class="token comment">// Defaults to "" (volume's root).</span><span class="token comment">// +optional</span>SubPath <span class="token builtin">string</span> <span class="token string">`json:"subPath,omitempty" protobuf:"bytes,4,opt,name=subPath"`</span><span class="token comment">// mountPropagation determines how mounts are propagated from the host</span><span class="token comment">// to container and the other way around.</span><span class="token comment">// When not set, MountPropagationHostToContainer is used.</span><span class="token comment">// This field is alpha in 1.8 and can be reworked or removed in a future</span><span class="token comment">// release.</span><span class="token comment">// +optional</span>MountPropagation <span class="token operator">*</span>MountPropagationMode <span class="token string">`json:"mountPropagation,omitempty" protobuf:"bytes,5,opt,name=mountPropagation,casttype=MountPropagationMode"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>Name</code>字段为容器要挂载的Volume的卷名，<code>ReadOnly</code>字段指是否只读。<code>MountPath</code>是容器内的挂载点，就像注释上说的，<code>within the container</code>。<code>SubPath</code>是相对于Volume的根路径，是宿主机上的一个子路径，在默认情况下为空，代表容器直接挂载到Volume的根目录下。</p><p>回到方法，可以看出其主要流程如下：</p><ol><li>创建一个空的挂载映射表<code>mounts</code>；</li><li>对容器请求的每一个挂载映射（即上述VolumeMount），执行下述操作：</li><li>从<code>podVolumes</code>中得到要挂载的Volume的具体信息；</li><li>调用<code>GetPath</code>得到该Volume的根路径，即<code>hostPath</code>；</li><li>对<code>hostPathg</code>和<code>subPath</code>进行一些必要的检验，然后拼接起来成为新的挂载路径。具体的检验操作和拼接操作以及相关的漏洞参见之前的一篇博客：<a href="https://yesiyuan.cn/tao-yi-cve-2017-1002101/">CVE-2017</a>；</li><li>获得外部挂载路径后，开始获取容器内要挂载的路径。通过一些简单的路径操作，得到容器内待挂载的绝对路径<code>containerPath</code>；</li><li>根据<code>VolumeName</code>、拼接了subPath的<code>hostPath</code>、容器内路径<code>containerPath</code>、是否只读选项<code>readOnly</code>以及另外两个没有提到的属性，构建一个完整的挂载映射关系，并把它追加到<code>mounts</code>中。</li></ol><p>处理完所有VolumeMount之后，该容器的挂载映射表就生成完毕，方法正常返回。通过上面的分析看出，该方法核心就是生成内外路径的映射关系和一些属性，将其作为配置信息传出去，并没有真正深入OS内核执行挂载。</p><h4 id="makeMount（kuberuntime包）"><a href="#makeMount（kuberuntime包）" class="headerlink" title="makeMount（kuberuntime包）"></a>makeMount（kuberuntime包）</h4><p>生成完opts后，即可更具其构建最终的配置<code>config</code>，即：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">config <span class="token operator">:=</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>ContainerConfig<span class="token punctuation">&#123;</span>Metadata<span class="token punctuation">:</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>ContainerMetadata<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span>    container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>Attempt<span class="token punctuation">:</span> restartCountUint32<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Image<span class="token punctuation">:</span>       <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>ImageSpec<span class="token punctuation">&#123;</span>Image<span class="token punctuation">:</span> imageRef<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Command<span class="token punctuation">:</span>     command<span class="token punctuation">,</span>Args<span class="token punctuation">:</span>        args<span class="token punctuation">,</span>WorkingDir<span class="token punctuation">:</span>  container<span class="token punctuation">.</span>WorkingDir<span class="token punctuation">,</span>Labels<span class="token punctuation">:</span>      <span class="token function">newContainerLabels</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token punctuation">,</span>Annotations<span class="token punctuation">:</span> <span class="token function">newContainerAnnotations</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> restartCount<span class="token punctuation">)</span><span class="token punctuation">,</span>Devices<span class="token punctuation">:</span>     <span class="token function">makeDevices</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">,</span>Mounts<span class="token punctuation">:</span>      m<span class="token punctuation">.</span><span class="token function">makeMounts</span><span class="token punctuation">(</span>opts<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">,</span>LogPath<span class="token punctuation">:</span>     containerLogsPath<span class="token punctuation">,</span>Stdin<span class="token punctuation">:</span>       container<span class="token punctuation">.</span>Stdin<span class="token punctuation">,</span>StdinOnce<span class="token punctuation">:</span>   container<span class="token punctuation">.</span>StdinOnce<span class="token punctuation">,</span>Tty<span class="token punctuation">:</span>         container<span class="token punctuation">.</span>TTY<span class="token punctuation">,</span>Linux<span class="token punctuation">:</span>       m<span class="token punctuation">.</span><span class="token function">generateLinuxContainerConfig</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，config.Mounts并不是单单引用了上面讲的opts.Mounts，而是又做了一遍操作。也就是说，之前的那个挂载映射表只是个初步的，这里还要改一下。</p><p>看一下这个<code>makeMounts</code>，位于<code>pkg/kubelet/kuberuntime/kuberuntime_container.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// makeMounts generates container volume mounts for kubelet runtime v1.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">makeMounts</span><span class="token punctuation">(</span>opts <span class="token operator">*</span>kubecontainer<span class="token punctuation">.</span>RunContainerOptions<span class="token punctuation">,</span> container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>Mount <span class="token punctuation">&#123;</span>volumeMounts <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> idx <span class="token operator">:=</span> <span class="token keyword">range</span> opts<span class="token punctuation">.</span>Mounts <span class="token punctuation">&#123;</span>v <span class="token operator">:=</span> opts<span class="token punctuation">.</span>Mounts<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>selinuxRelabel <span class="token operator">:=</span> v<span class="token punctuation">.</span>SELinuxRelabel <span class="token operator">&amp;&amp;</span> selinux<span class="token punctuation">.</span><span class="token function">SELinuxEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mount <span class="token operator">:=</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span>HostPath<span class="token punctuation">:</span>       v<span class="token punctuation">.</span>HostPath<span class="token punctuation">,</span>ContainerPath<span class="token punctuation">:</span>  v<span class="token punctuation">.</span>ContainerPath<span class="token punctuation">,</span>Readonly<span class="token punctuation">:</span>       v<span class="token punctuation">.</span>ReadOnly<span class="token punctuation">,</span>SelinuxRelabel<span class="token punctuation">:</span> selinuxRelabel<span class="token punctuation">,</span>Propagation<span class="token punctuation">:</span>    v<span class="token punctuation">.</span>Propagation<span class="token punctuation">,</span><span class="token punctuation">&#125;</span>volumeMounts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>volumeMounts<span class="token punctuation">,</span> mount<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// The reason we create and mount the log file in here (not in kubelet) is because</span><span class="token comment">// the file's location depends on the ID of the container, and we need to create and</span><span class="token comment">// mount the file before actually starting the container.</span><span class="token keyword">if</span> opts<span class="token punctuation">.</span>PodContainerDir <span class="token operator">!=</span> <span class="token string">""</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>TerminationMessagePath<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// Because the PodContainerDir contains pod uid and container name which is unique enough,</span><span class="token comment">// here we just add a random id to make the path unique for different instances</span><span class="token comment">// of the same container.</span>cid <span class="token operator">:=</span> <span class="token function">makeUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>containerLogPath <span class="token operator">:=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>PodContainerDir<span class="token punctuation">,</span> cid<span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>osInterface<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>containerLogPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"error on creating termination-log file %q: %v"</span><span class="token punctuation">,</span> containerLogPath<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Chmod is needed because ioutil.WriteFile() ends up calling</span><span class="token comment">// open(2) to create the file, so the final mode used is "mode &amp;</span><span class="token comment">// ~umask". But we want to make sure the specified mode is used</span><span class="token comment">// in the file no matter what the umask is.</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>osInterface<span class="token punctuation">.</span><span class="token function">Chmod</span><span class="token punctuation">(</span>containerLogPath<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unable to set termination-log file permissions %q: %v"</span><span class="token punctuation">,</span> containerLogPath<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>selinuxRelabel <span class="token operator">:=</span> selinux<span class="token punctuation">.</span><span class="token function">SELinuxEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>volumeMounts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>volumeMounts<span class="token punctuation">,</span> <span class="token operator">&amp;</span>runtimeapi<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span>HostPath<span class="token punctuation">:</span>       containerLogPath<span class="token punctuation">,</span>ContainerPath<span class="token punctuation">:</span>  container<span class="token punctuation">.</span>TerminationMessagePath<span class="token punctuation">,</span>SelinuxRelabel<span class="token punctuation">:</span> selinuxRelabel<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> volumeMounts<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法主就干两件事情：</p><ol><li>重构一下之前的挂载映射表，但说白了就是吧<code>Name</code>字段删了，仅此而已；</li><li>调用OS内核接口Create创建一个目录，即<code>PodContinerDir+cid</code>。创建完之后将这个目录和容器内的终结信息目录映射起来，生成一个新的挂载关系加入挂在表。这个挂载仅用来输出日志。</li></ol><p>重构完挂载表之后，正常将其返回即可。</p><p>至此为止，<code>generateContainerConfig</code>就算完成了，生成了创建容器需要的相关配置=&gt;<code>containerConfig</code>。然后，<code>startContainer</code>就会把生成的这个配置交给<code>CreateContaier</code>，开始创建容器。</p><p>这方法是Docker Serveice提供的方法，创建容器，并完成其中的卷挂载，我们跟进它，看看到底是怎么进行挂载的。</p><h3 id="CreateContainer（dockershim包）"><a href="#CreateContainer（dockershim包）" class="headerlink" title="CreateContainer（dockershim包）"></a>CreateContainer（dockershim包）</h3><p>该方法位于<code>pkg/kubelet/dockershim/docker_container.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// CreateContainer creates a new container in the given PodSandbox</span><span class="token comment">// Docker cannot store the log to an arbitrary location (yet), so we create an</span><span class="token comment">// symlink at LogPath, linking to the actual path of the log.</span><span class="token comment">// TODO: check if the default values returned by the runtime API are ok.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>ds <span class="token operator">*</span>dockerService<span class="token punctuation">)</span> <span class="token function">CreateContainer</span><span class="token punctuation">(</span>podSandboxID <span class="token builtin">string</span><span class="token punctuation">,</span> config <span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>ContainerConfig<span class="token punctuation">,</span> sandboxConfig <span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>PodSandboxConfig<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> config <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"container config is nil"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> sandboxConfig <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"sandbox config is nil for container %q"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>Metadata<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>labels <span class="token operator">:=</span> <span class="token function">makeLabels</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">GetLabels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span><span class="token function">GetAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// Apply a the container type label.</span>labels<span class="token punctuation">[</span>containerTypeLabelKey<span class="token punctuation">]</span> <span class="token operator">=</span> containerTypeLabelContainer<span class="token comment">// Write the container log path in the labels.</span>labels<span class="token punctuation">[</span>containerLogPathLabelKey<span class="token punctuation">]</span> <span class="token operator">=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>sandboxConfig<span class="token punctuation">.</span>LogDirectory<span class="token punctuation">,</span> config<span class="token punctuation">.</span>LogPath<span class="token punctuation">)</span><span class="token comment">// Write the sandbox ID in the labels.</span>labels<span class="token punctuation">[</span>sandboxIDLabelKey<span class="token punctuation">]</span> <span class="token operator">=</span> podSandboxIDapiVersion<span class="token punctuation">,</span> err <span class="token operator">:=</span> ds<span class="token punctuation">.</span><span class="token function">getDockerAPIVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unable to get the docker API version: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>securityOptSep <span class="token operator">:=</span> <span class="token function">getSecurityOptSeparator</span><span class="token punctuation">(</span>apiVersion<span class="token punctuation">)</span>image <span class="token operator">:=</span> <span class="token string">""</span><span class="token keyword">if</span> iSpec <span class="token operator">:=</span> config<span class="token punctuation">.</span><span class="token function">GetImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iSpec <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>image <span class="token operator">=</span> iSpec<span class="token punctuation">.</span>Image<span class="token punctuation">&#125;</span><span class="token comment">// 根据传进来了的config生成docker创建容器所需要的新配置=>createConfig</span>createConfig <span class="token operator">:=</span> dockertypes<span class="token punctuation">.</span>ContainerCreateConfig<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token function">makeContainerName</span><span class="token punctuation">(</span>sandboxConfig<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">,</span>Config<span class="token punctuation">:</span> <span class="token operator">&amp;</span>dockercontainer<span class="token punctuation">.</span>Config<span class="token punctuation">&#123;</span><span class="token comment">// TODO: set User.</span>Entrypoint<span class="token punctuation">:</span> dockerstrslice<span class="token punctuation">.</span><span class="token function">StrSlice</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>Command<span class="token punctuation">)</span><span class="token punctuation">,</span>Cmd<span class="token punctuation">:</span>        dockerstrslice<span class="token punctuation">.</span><span class="token function">StrSlice</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>Args<span class="token punctuation">)</span><span class="token punctuation">,</span>Env<span class="token punctuation">:</span>        <span class="token function">generateEnvList</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">GetEnvs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Image<span class="token punctuation">:</span>      image<span class="token punctuation">,</span>WorkingDir<span class="token punctuation">:</span> config<span class="token punctuation">.</span>WorkingDir<span class="token punctuation">,</span>Labels<span class="token punctuation">:</span>     labels<span class="token punctuation">,</span><span class="token comment">// Interactive containers:</span>OpenStdin<span class="token punctuation">:</span> config<span class="token punctuation">.</span>Stdin<span class="token punctuation">,</span>StdinOnce<span class="token punctuation">:</span> config<span class="token punctuation">.</span>StdinOnce<span class="token punctuation">,</span>Tty<span class="token punctuation">:</span>       config<span class="token punctuation">.</span>Tty<span class="token punctuation">,</span><span class="token comment">// Disable Docker's health check until we officially support it</span><span class="token comment">// (https://github.com/kubernetes/kubernetes/issues/25829).</span>Healthcheck<span class="token punctuation">:</span> <span class="token operator">&amp;</span>dockercontainer<span class="token punctuation">.</span>HealthConfig<span class="token punctuation">&#123;</span>Test<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"NONE"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>HostConfig<span class="token punctuation">:</span> <span class="token operator">&amp;</span>dockercontainer<span class="token punctuation">.</span>HostConfig<span class="token punctuation">&#123;</span><span class="token comment">// 将之前生成的挂载映射表转换成docker能读懂的格式 => string切片</span>Binds<span class="token punctuation">:</span> <span class="token function">generateMountBindings</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">GetMounts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>hc <span class="token operator">:=</span> createConfig<span class="token punctuation">.</span>HostConfigds<span class="token punctuation">.</span><span class="token function">updateCreateConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>createConfig<span class="token punctuation">,</span> config<span class="token punctuation">,</span> sandboxConfig<span class="token punctuation">,</span> podSandboxID<span class="token punctuation">,</span> securityOptSep<span class="token punctuation">,</span> apiVersion<span class="token punctuation">)</span><span class="token comment">// Set devices for container.</span>devices <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>dockercontainer<span class="token punctuation">.</span>DeviceMapping<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>Devices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> device <span class="token operator">:=</span> <span class="token keyword">range</span> config<span class="token punctuation">.</span>Devices <span class="token punctuation">&#123;</span>devices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dockercontainer<span class="token punctuation">.</span>DeviceMapping<span class="token punctuation">&#123;</span>PathOnHost<span class="token punctuation">:</span>        device<span class="token punctuation">.</span>HostPath<span class="token punctuation">,</span>PathInContainer<span class="token punctuation">:</span>   device<span class="token punctuation">.</span>ContainerPath<span class="token punctuation">,</span>CgroupPermissions<span class="token punctuation">:</span> device<span class="token punctuation">.</span>Permissions<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>hc<span class="token punctuation">.</span>Resources<span class="token punctuation">.</span>Devices <span class="token operator">=</span> devicessecurityOpts<span class="token punctuation">,</span> err <span class="token operator">:=</span> ds<span class="token punctuation">.</span><span class="token function">getSecurityOpts</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">GetLinux</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetSecurityContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetSeccompProfilePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> securityOptSep<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"failed to generate security options for container %q: %v"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>Metadata<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>hc<span class="token punctuation">.</span>SecurityOpt <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>hc<span class="token punctuation">.</span>SecurityOpt<span class="token punctuation">,</span> securityOpts<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 用docker client来创建容器</span>createResp<span class="token punctuation">,</span> err <span class="token operator">:=</span> ds<span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">CreateContainer</span><span class="token punctuation">(</span>createConfig<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>createResp<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">recoverFromCreationConflictIfNeeded</span><span class="token punctuation">(</span>ds<span class="token punctuation">.</span>client<span class="token punctuation">,</span> createConfig<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> createResp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> createResp<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法中的其他细节这里先不考虑，我们关注其中的核心三步：</p><ol><li>之前生成的config并不是docker规范的，因此这里要据其构建一个新的<code>createConfig</code>，这个配置是docker真正能读懂的；</li><li>其中，<code>createConfig.HostConfig.Binds</code>就是容器要挂载的卷列表。之前<code>makeMounts</code>生成的挂载映射表，其实docker根本读不懂，所以这里要调用<code>generateMountBindings</code>将挂载映射表转换成docker能读懂的格式，是一个string切片。</li><li>生成完配置之后，调用docker client的<code>CreateContainer</code>方法，来创建容器。</li></ol><p>先看一下<code>generateMountBindings</code>是怎么工作，最后规范的挂载表格式又是什么样的。</p><h4 id="generateMountBindings"><a href="#generateMountBindings" class="headerlink" title="generateMountBindings"></a>generateMountBindings</h4><p>方法位于<code>pkg/kubelet/dockershim/helpers.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// generateMountBindings converts the mount list to a list of strings that</span><span class="token comment">// can be understood by docker.</span><span class="token comment">// '&lt;HostPath>:&lt;ContainerPath>[:options]', where 'options'</span><span class="token comment">// is a comma-separated list of the following strings:</span><span class="token comment">// 'ro', if the path is read only</span><span class="token comment">// 'Z', if the volume requires SELinux relabeling</span><span class="token comment">// propagation mode such as 'rslave'</span><span class="token keyword">func</span> <span class="token function">generateMountBindings</span><span class="token punctuation">(</span>mounts <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>Mount<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>result <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>mounts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> m <span class="token operator">:=</span> <span class="token keyword">range</span> mounts <span class="token punctuation">&#123;</span>bind <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s:%s"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>HostPath<span class="token punctuation">,</span> m<span class="token punctuation">.</span>ContainerPath<span class="token punctuation">)</span><span class="token keyword">var</span> attrs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token keyword">if</span> m<span class="token punctuation">.</span>Readonly <span class="token punctuation">&#123;</span>attrs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> <span class="token string">"ro"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Only request relabeling if the pod provides an SELinux context. If the pod</span><span class="token comment">// does not provide an SELinux context relabeling will label the volume with</span><span class="token comment">// the container's randomly allocated MCS label. This would restrict access</span><span class="token comment">// to the volume to the container which mounts it first.</span><span class="token keyword">if</span> m<span class="token punctuation">.</span>SelinuxRelabel <span class="token punctuation">&#123;</span>attrs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> <span class="token string">"Z"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> m<span class="token punctuation">.</span>Propagation <span class="token punctuation">&#123;</span><span class="token keyword">case</span> runtimeapi<span class="token punctuation">.</span>MountPropagation_PROPAGATION_PRIVATE<span class="token punctuation">:</span><span class="token comment">// noop, private is default</span><span class="token keyword">case</span> runtimeapi<span class="token punctuation">.</span>MountPropagation_PROPAGATION_BIDIRECTIONAL<span class="token punctuation">:</span>attrs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> <span class="token string">"rshared"</span><span class="token punctuation">)</span><span class="token keyword">case</span> runtimeapi<span class="token punctuation">.</span>MountPropagation_PROPAGATION_HOST_TO_CONTAINER<span class="token punctuation">:</span>attrs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> <span class="token string">"rslave"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">Warningf</span><span class="token punctuation">(</span><span class="token string">"unknown propagation mode for hostPath %q"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>HostPath<span class="token punctuation">)</span><span class="token comment">// Falls back to "private"</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>bind <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s:%s"</span><span class="token punctuation">,</span> bind<span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>attrs<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> bind<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法的实现很简单，就是提取主机路径、容器内路径、挂载属性这三个元素。然后docker的规范挂载配置也很简单，就是<code>hostPath:containerPath:attrs</code> 而已。</p><p>接着，更进<code>client.CreateContainer</code>来看是如何进行挂载的。</p><h4 id="CreateContainer（libdocker包）"><a href="#CreateContainer（libdocker包）" class="headerlink" title="CreateContainer（libdocker包）"></a>CreateContainer（libdocker包）</h4><p>方法位于<code>pkg/kubelet/dockershim/libdocker/kube_docker_client.go</code>中，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>kubeDockerClient<span class="token punctuation">)</span> <span class="token function">CreateContainer</span><span class="token punctuation">(</span>opts dockertypes<span class="token punctuation">.</span>ContainerCreateConfig<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>dockercontainer<span class="token punctuation">.</span>ContainerCreateCreatedBody<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> d<span class="token punctuation">.</span><span class="token function">getTimeoutContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// we provide an explicit default shm size as to not depend on docker daemon.</span><span class="token comment">// TODO: evaluate exposing this as a knob in the API</span><span class="token keyword">if</span> opts<span class="token punctuation">.</span>HostConfig <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>ShmSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>opts<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>ShmSize <span class="token operator">=</span> defaultShmSize<span class="token punctuation">&#125;</span>createResp<span class="token punctuation">,</span> err <span class="token operator">:=</span> d<span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">ContainerCreate</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>Config<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>HostConfig<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>NetworkingConfig<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token keyword">if</span> ctxErr <span class="token operator">:=</span> <span class="token function">contextError</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span> ctxErr <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ctxErr<span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>createResp<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这个方法是调用<code>client.ContainerCreate</code>来实现的，因此直接跟进这个方法即可。</p><h5 id="ContainerCreate"><a href="#ContainerCreate" class="headerlink" title="ContainerCreate"></a>ContainerCreate</h5><p>方法位于<code>github.com/docker/docker/client/container_create.go</code>，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ContainerCreate creates a new container based in the given configuration.</span><span class="token comment">// It can be associated with a name, but it's not mandatory.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>cli <span class="token operator">*</span>Client<span class="token punctuation">)</span> <span class="token function">ContainerCreate</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> config <span class="token operator">*</span>container<span class="token punctuation">.</span>Config<span class="token punctuation">,</span> hostConfig <span class="token operator">*</span>container<span class="token punctuation">.</span>HostConfig<span class="token punctuation">,</span> networkingConfig <span class="token operator">*</span>network<span class="token punctuation">.</span>NetworkingConfig<span class="token punctuation">,</span> containerName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span>ContainerCreateCreatedBody<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> response container<span class="token punctuation">.</span>ContainerCreateCreatedBody<span class="token keyword">if</span> err <span class="token operator">:=</span> cli<span class="token punctuation">.</span><span class="token function">NewVersionError</span><span class="token punctuation">(</span><span class="token string">"1.25"</span><span class="token punctuation">,</span> <span class="token string">"stop timeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> config <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>StopTimeout <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> response<span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// When using API 1.24 and under, the client is responsible for removing the container</span><span class="token keyword">if</span> hostConfig <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> versions<span class="token punctuation">.</span><span class="token function">LessThan</span><span class="token punctuation">(</span>cli<span class="token punctuation">.</span><span class="token function">ClientVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"1.25"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>hostConfig<span class="token punctuation">.</span>AutoRemove <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>query <span class="token operator">:=</span> url<span class="token punctuation">.</span>Values<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> containerName <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>query<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> containerName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>body <span class="token operator">:=</span> configWrapper<span class="token punctuation">&#123;</span>Config<span class="token punctuation">:</span>           config<span class="token punctuation">,</span>HostConfig<span class="token punctuation">:</span>       hostConfig<span class="token punctuation">,</span>NetworkingConfig<span class="token punctuation">:</span> networkingConfig<span class="token punctuation">,</span><span class="token punctuation">&#125;</span>serverResp<span class="token punctuation">,</span> err <span class="token operator">:=</span> cli<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"/containers/create"</span><span class="token punctuation">,</span> query<span class="token punctuation">,</span> body<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> serverResp<span class="token punctuation">.</span>statusCode <span class="token operator">==</span> <span class="token number">404</span> <span class="token operator">&amp;&amp;</span> strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"No such image"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> response<span class="token punctuation">,</span> imageNotFoundError<span class="token punctuation">&#123;</span>config<span class="token punctuation">.</span>Image<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> response<span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>err <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>serverResp<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>response<span class="token punctuation">)</span><span class="token function">ensureReaderClosed</span><span class="token punctuation">(</span>serverResp<span class="token punctuation">)</span><span class="token keyword">return</span> response<span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法中有一个核心结构变量=&gt;<code>body</code>，是一个请求体的雏形，三个字段大概如下：</p><ul><li>Config：就是createConfig.config，其中包含了容器的大部分配置；</li><li>HostConfig：就是createConfig.HostConif，其中的Binds字段就是之前的挂载映射；</li><li>NetWorkConfig：就是createConfig.NetworkingConfig，容器网络配置。</li></ul><p>构建完后，用该请求体去调用docker API结构，通过docker网络的方式来创建容器。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// post sends an http request to the docker API using the method POST with a specific Go context.</span>serverResp<span class="token punctuation">,</span> err <span class="token operator">:=</span> cli<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"/containers/create"</span><span class="token punctuation">,</span> query<span class="token punctuation">,</span> body<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续跟进这个post方法，就是docker如何包装并发送这个请求了。这里面能说能整理的还有很多，所以准备放在一篇博客中单独介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，Pod创建过程，有关Container卷挂载的流程就相对清晰了。看上去调用了很多方法，实际上就是层层封装。概括一下的话，就是两大部分：</p><ul><li>生成容器创建的配置，其中就有卷的挂载映射；</li><li>将配置包装成请求体，调用docker API进行容器创建；</li></ul>]]></content>
      
      
      <categories>
          
          <category> k8s源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> kubelet </tag>
            
            <tag> volume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临时卷</title>
      <link href="/lin-shi-juan/"/>
      <url>/lin-shi-juan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>持久卷(一)</title>
      <link href="/chi-jiu-juan-yi/"/>
      <url>/chi-jiu-juan-yi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s之Pod生命周期</title>
      <link href="/k8s-zhi-pod-sheng-ming-zhou-qi/"/>
      <url>/k8s-zhi-pod-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<p>一个Pod完整的生命周期主要包含三个核心部分：<code>Init Container</code>、<code>Pod Hook</code>、<code>健康检查</code>。这里将分别介绍这三个核心部分。不过在开始之前，需要先了解下Pod的状态，因为Pod状态可以反应出当前Pod的具体信息，也是分析排错的一个必备方式。</p><h2 id="Pod状态"><a href="#Pod状态" class="headerlink" title="Pod状态"></a>Pod状态</h2><p>首先了解下Pod的状态值，可以通过<code>kubectl explain pod.status</code>命令来查看状态的介绍。Pod的状态定义在<code>PodStatus</code>结构中，其源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PodStatus represents information about the status of a pod. Status may trail the actual</span><span class="token comment">// state of a system.</span><span class="token keyword">type</span> PodStatus <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Current condition of the pod.</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase</span><span class="token comment">// +optional</span>Phase PodPhase <span class="token string">`json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=PodPhase"`</span><span class="token comment">// Current service state of pod.</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions</span><span class="token comment">// +optional</span><span class="token comment">// +patchMergeKey=type</span><span class="token comment">// +patchStrategy=merge</span>Conditions <span class="token punctuation">[</span><span class="token punctuation">]</span>PodCondition <span class="token string">`json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,2,rep,name=conditions"`</span><span class="token comment">// A human readable message indicating details about why the pod is in this condition.</span><span class="token comment">// +optional</span>Message <span class="token builtin">string</span> <span class="token string">`json:"message,omitempty" protobuf:"bytes,3,opt,name=message"`</span><span class="token comment">// A brief CamelCase message indicating details about why the pod is in this state.</span><span class="token comment">// e.g. 'Evicted'</span><span class="token comment">// +optional</span>Reason <span class="token builtin">string</span> <span class="token string">`json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason"`</span><span class="token comment">// IP address of the host to which the pod is assigned. Empty if not yet scheduled.</span><span class="token comment">// +optional</span>HostIP <span class="token builtin">string</span> <span class="token string">`json:"hostIP,omitempty" protobuf:"bytes,5,opt,name=hostIP"`</span><span class="token comment">// IP address allocated to the pod. Routable at least within the cluster.</span><span class="token comment">// Empty if not yet allocated.</span><span class="token comment">// +optional</span>PodIP <span class="token builtin">string</span> <span class="token string">`json:"podIP,omitempty" protobuf:"bytes,6,opt,name=podIP"`</span><span class="token comment">// RFC 3339 date and time at which the object was acknowledged by the Kubelet.</span><span class="token comment">// This is before the Kubelet pulled the container image(s) for the pod.</span><span class="token comment">// +optional</span>StartTime <span class="token operator">*</span>metav1<span class="token punctuation">.</span>Time <span class="token string">`json:"startTime,omitempty" protobuf:"bytes,7,opt,name=startTime"`</span><span class="token comment">// The list has one entry per init container in the manifest. The most recent successful</span><span class="token comment">// init container will have ready = true, the most recently started container will have</span><span class="token comment">// startTime set.</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status</span>InitContainerStatuses <span class="token punctuation">[</span><span class="token punctuation">]</span>ContainerStatus <span class="token string">`json:"initContainerStatuses,omitempty" protobuf:"bytes,10,rep,name=initContainerStatuses"`</span><span class="token comment">// The list has one entry per container in the manifest. Each entry is currently the output</span><span class="token comment">// of `docker inspect`.</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status</span><span class="token comment">// +optional</span>ContainerStatuses <span class="token punctuation">[</span><span class="token punctuation">]</span>ContainerStatus <span class="token string">`json:"containerStatuses,omitempty" protobuf:"bytes,8,rep,name=containerStatuses"`</span><span class="token comment">// The Quality of Service (QOS) classification assigned to the pod based on resource requirements</span><span class="token comment">// See PodQOSClass type for available QOS classes</span><span class="token comment">// More info: https://github.com/kubernetes/kubernetes/blob/master/docs/design/resource-qos.md</span><span class="token comment">// +optional</span>QOSClass PodQOSClass <span class="token string">`json:"qosClass,omitempty" protobuf:"bytes,9,rep,name=qosClass"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，每个字段的注释都和<code>explain</code>命令中显示的介绍一模一样。这里介绍两个字段，首先是<code>phase</code>字段，其类型为<code>Podphase</code>，实际就是个string。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PodPhase is a label for the condition of a pod at the current time.</span><span class="token keyword">type</span> PodPhase <span class="token builtin">string</span><span class="token comment">// These are the valid statuses of pods.</span><span class="token keyword">const</span> <span class="token punctuation">(</span>PodPending PodPhase <span class="token operator">=</span> <span class="token string">"Pending"</span>PodRunning PodPhase <span class="token operator">=</span> <span class="token string">"Running"</span>PodSucceeded PodPhase <span class="token operator">=</span> <span class="token string">"Succeeded"</span>PodFailed PodPhase <span class="token operator">=</span> <span class="token string">"Failed"</span>PodUnknown PodPhase <span class="token operator">=</span> <span class="token string">"Unknown"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>phase</code>的可能取值共有5个，分别代表5个大的状态：</p><ul><li>挂起（Pending）：Pod 信息已经提交给了集群，但是还没有被调度器调度到合适的节点或者已调度但是 Pod 里的镜像正在下载；</li><li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态；</li><li>成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启；</li><li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非<code>0</code>状态退出或者被系统终止；</li><li>未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败导致的。</li></ul><p>注意，Succeeded和Failed都是一种<code>Terminated</code>状态，即要么正常终止，要么因失败终止。</p><p>除此之外，<code>PodStatus</code> 对象中还有一个<code>Conditions</code>字段，是一个<code>PodCondition</code>结构的数组，该结构源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PodCondition contains details for the current condition of this pod.</span><span class="token keyword">type</span> PodCondition <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Type is the type of the condition.</span><span class="token comment">// Currently only Ready.</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions</span>Type PodConditionType <span class="token string">`json:"type" protobuf:"bytes,1,opt,name=type,casttype=PodConditionType"`</span><span class="token comment">// Status is the status of the condition.</span><span class="token comment">// Can be True, False, Unknown.</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions</span>Status ConditionStatus <span class="token string">`json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`</span><span class="token comment">// Last time we probed the condition.</span><span class="token comment">// +optional</span>LastProbeTime metav1<span class="token punctuation">.</span>Time <span class="token string">`json:"lastProbeTime,omitempty" protobuf:"bytes,3,opt,name=lastProbeTime"`</span><span class="token comment">// Last time the condition transitioned from one status to another.</span><span class="token comment">// +optional</span>LastTransitionTime metav1<span class="token punctuation">.</span>Time <span class="token string">`json:"lastTransitionTime,omitempty" protobuf:"bytes,4,opt,name=lastTransitionTime"`</span><span class="token comment">// Unique, one-word, CamelCase reason for the condition's last transition.</span><span class="token comment">// +optional</span>Reason <span class="token builtin">string</span> <span class="token string">`json:"reason,omitempty" protobuf:"bytes,5,opt,name=reason"`</span><span class="token comment">// Human-readable message indicating details about last transition.</span><span class="token comment">// +optional</span>Message <span class="token builtin">string</span> <span class="token string">`json:"message,omitempty" protobuf:"bytes,6,opt,name=message"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也可以痛过命令<code>kubectl explain pod.status.conditions</code>来查看介绍，得到的内容和源码中的注释一致。里面的属性翻译一下就是：</p><ul><li>lastProbeTime：最后一次探测 Pod Condition 的时间戳。</li><li>lastTransitionTime：上次 Condition 从一种状态转换到另一种状态的时间。</li><li>message：上次 Condition 状态转换的详细描述。</li><li>reason：Condition 最后一次转换的原因。</li><li>status：Condition 状态类型，可以为 “True”, “False”, and “Unknown”.</li><li>type：Condition 类型，包括以下方面：<ul><li>PodScheduled（Pod 已经被调度到其他 node 里）</li><li>Ready（Pod 能够提供服务请求，可以被添加到所有可匹配服务的负载平衡池中）</li><li>Initialized（所有的<code>init containers</code>已经启动成功）</li><li>Unschedulable（调度程序现在无法调度 Pod，例如由于缺乏资源或其他限制）</li><li>ContainersReady（Pod 里的所有容器都是 ready 状态</li></ul></li></ul><h2 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h2><p>除了Pod的状态之外，我们还需知道Pod的具体信息，比如它拥有的Volume、拥有的Container、希望被调度的node、各种策略等等，这些信息非常重要，存储在<code>PodSpec</code>结构之中，其源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PodSpec is a description of a pod.</span><span class="token keyword">type</span> PodSpec <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// List of volumes that can be mounted by containers belonging to the pod.</span>    <span class="token comment">// ...</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/storage/volumes</span>Volumes <span class="token punctuation">[</span><span class="token punctuation">]</span>Volume <span class="token string">`json:"volumes,omitempty" patchStrategy:"merge,retainKeys" patchMergeKey:"name" protobuf:"bytes,1,rep,name=volumes"`</span><span class="token comment">// List of initialization containers belonging to the pod.</span>    <span class="token comment">// ...</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/</span>InitContainers <span class="token punctuation">[</span><span class="token punctuation">]</span>Container <span class="token string">`json:"initContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,20,rep,name=initContainers"`</span><span class="token comment">// List of containers belonging to the pod.</span>    <span class="token comment">// ...</span>Containers <span class="token punctuation">[</span><span class="token punctuation">]</span>Container <span class="token string">`json:"containers" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,2,rep,name=containers"`</span><span class="token comment">// Restart policy for all containers within the pod.</span>    <span class="token comment">// ...</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy</span>RestartPolicy RestartPolicy <span class="token string">`json:"restartPolicy,omitempty" protobuf:"bytes,3,opt,name=restartPolicy,casttype=RestartPolicy"`</span><span class="token comment">// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.</span><span class="token comment">// ...</span>TerminationGracePeriodSeconds <span class="token operator">*</span><span class="token builtin">int64</span> <span class="token string">`json:"terminationGracePeriodSeconds,omitempty" protobuf:"varint,4,opt,name=terminationGracePeriodSeconds"`</span><span class="token comment">// Optional duration in seconds the pod may be active on the node relative to</span><span class="token comment">// ...</span>ActiveDeadlineSeconds <span class="token operator">*</span><span class="token builtin">int64</span> <span class="token string">`json:"activeDeadlineSeconds,omitempty" protobuf:"varint,5,opt,name=activeDeadlineSeconds"`</span><span class="token comment">// Set DNS policy for the pod. Defaults to "ClusterFirst".</span><span class="token comment">// ...</span>DNSPolicy DNSPolicy <span class="token string">`json:"dnsPolicy,omitempty" protobuf:"bytes,6,opt,name=dnsPolicy,casttype=DNSPolicy"`</span><span class="token comment">// NodeSelector is a selector which must be true for the pod to fit on a node.</span>    <span class="token comment">// ...</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</span>NodeSelector <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"nodeSelector,omitempty" protobuf:"bytes,7,rep,name=nodeSelector"`</span><span class="token comment">// ServiceAccountName is the name of the ServiceAccount to use to run this pod.</span><span class="token comment">// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/</span>ServiceAccountName <span class="token builtin">string</span> <span class="token string">`json:"serviceAccountName,omitempty" protobuf:"bytes,8,opt,name=serviceAccountName"`</span><span class="token comment">// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.</span><span class="token comment">// ...</span>DeprecatedServiceAccount <span class="token builtin">string</span> <span class="token string">`json:"serviceAccount,omitempty" protobuf:"bytes,9,opt,name=serviceAccount"`</span><span class="token comment">// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.</span>AutomountServiceAccountToken <span class="token operator">*</span><span class="token builtin">bool</span> <span class="token string">`json:"automountServiceAccountToken,omitempty" protobuf:"varint,21,opt,name=automountServiceAccountToken"`</span><span class="token comment">// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,</span><span class="token comment">// ...</span>NodeName <span class="token builtin">string</span> <span class="token string">`json:"nodeName,omitempty" protobuf:"bytes,10,opt,name=nodeName"`</span><span class="token comment">// Host networking requested for this pod. Use the host's network namespace.</span><span class="token comment">// ...</span>HostNetwork <span class="token builtin">bool</span> <span class="token string">`json:"hostNetwork,omitempty" protobuf:"varint,11,opt,name=hostNetwork"`</span><span class="token comment">// Use the host's pid namespace.</span><span class="token comment">// ...</span>HostPID <span class="token builtin">bool</span> <span class="token string">`json:"hostPID,omitempty" protobuf:"varint,12,opt,name=hostPID"`</span><span class="token comment">// Use the host's ipc namespace.</span><span class="token comment">// ...</span>HostIPC <span class="token builtin">bool</span> <span class="token string">`json:"hostIPC,omitempty" protobuf:"varint,13,opt,name=hostIPC"`</span><span class="token comment">// SecurityContext holds pod-level security attributes and common container settings.</span><span class="token comment">// ...</span>SecurityContext <span class="token operator">*</span>PodSecurityContext <span class="token string">`json:"securityContext,omitempty" protobuf:"bytes,14,opt,name=securityContext"`</span><span class="token comment">// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.</span><span class="token comment">// ...</span><span class="token comment">// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod</span>ImagePullSecrets <span class="token punctuation">[</span><span class="token punctuation">]</span>LocalObjectReference <span class="token string">`json:"imagePullSecrets,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,15,rep,name=imagePullSecrets"`</span><span class="token comment">// Specifies the hostname of the Pod</span><span class="token comment">// ...</span>Hostname <span class="token builtin">string</span> <span class="token string">`json:"hostname,omitempty" protobuf:"bytes,16,opt,name=hostname"`</span><span class="token comment">// If specified, the fully qualified Pod hostname will be "&lt;hostname>.&lt;subdomain>.&lt;pod namespace>.svc.&lt;cluster domain>".</span><span class="token comment">// If not specified, the pod will not have a domainname at all.</span>Subdomain <span class="token builtin">string</span> <span class="token string">`json:"subdomain,omitempty" protobuf:"bytes,17,opt,name=subdomain"`</span><span class="token comment">// If specified, the pod's scheduling constraints</span>Affinity <span class="token operator">*</span>Affinity <span class="token string">`json:"affinity,omitempty" protobuf:"bytes,18,opt,name=affinity"`</span><span class="token comment">// If specified, the pod will be dispatched by specified scheduler.</span><span class="token comment">// If not specified, the pod will be dispatched by default scheduler.</span>SchedulerName <span class="token builtin">string</span> <span class="token string">`json:"schedulerName,omitempty" protobuf:"bytes,19,opt,name=schedulerName"`</span><span class="token comment">// If specified, the pod's tolerations.</span>Tolerations <span class="token punctuation">[</span><span class="token punctuation">]</span>Toleration <span class="token string">`json:"tolerations,omitempty" protobuf:"bytes,22,opt,name=tolerations"`</span><span class="token comment">// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts</span><span class="token comment">// file if specified. This is only valid for non-hostNetwork pods.</span><span class="token comment">// ...</span>HostAliases <span class="token punctuation">[</span><span class="token punctuation">]</span>HostAlias <span class="token string">`json:"hostAliases,omitempty" patchStrategy:"merge" patchMergeKey:"ip" protobuf:"bytes,23,rep,name=hostAliases"`</span><span class="token comment">// If specified, indicates the pod's priority. "SYSTEM" is a special keyword</span><span class="token comment">// which indicates the highest priority. Any other name must be defined by</span><span class="token comment">// creating a PriorityClass object with that name.</span><span class="token comment">// If not specified, the pod priority will be default or zero if there is no</span><span class="token comment">// default.</span><span class="token comment">// +optional</span>PriorityClassName <span class="token builtin">string</span> <span class="token string">`json:"priorityClassName,omitempty" protobuf:"bytes,24,opt,name=priorityClassName"`</span><span class="token comment">// The priority value. Various system components use this field to find the</span><span class="token comment">// priority of the pod. When Priority Admission Controller is enabled, it</span><span class="token comment">// prevents users from setting this field. The admission controller populates</span><span class="token comment">// this field from PriorityClassName.</span><span class="token comment">// The higher the value, the higher the priority.</span><span class="token comment">// +optional</span>Priority <span class="token operator">*</span><span class="token builtin">int32</span> <span class="token string">`json:"priority,omitempty" protobuf:"bytes,25,opt,name=priority"`</span><span class="token comment">// Specifies the DNS parameters of a pod.</span><span class="token comment">// Parameters specified here will be merged to the generated DNS</span><span class="token comment">// configuration based on DNSPolicy.</span><span class="token comment">// This is an alpha feature introduced in v1.9 and CustomPodDNS feature gate must be enabled to use it.</span><span class="token comment">// +optional</span>DNSConfig <span class="token operator">*</span>PodDNSConfig <span class="token string">`json:"dnsConfig,omitempty" protobuf:"bytes,26,opt,name=dnsConfig"`</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注释太多了，这里删了很多，留了概要，如果想看详细介绍，用命令<code>kubectl explain pod.spec </code>来查看即可。这里只谈和重启策略有关的字段，即<code>restartPolicy</code>。通过该字段可以来设置Pod中所有容器的重启策略，其值可能为<code>Always</code>、<code>OnFailure</code>、<code>Never</code>，默认值为Always。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// RestartPolicy describes how the container should be restarted.</span><span class="token comment">// Only one of the following restart policies may be specified.</span><span class="token comment">// If none of the following policies is specified, the default one</span><span class="token comment">// is RestartPolicyAlways.</span><span class="token keyword">type</span> RestartPolicy <span class="token builtin">string</span><span class="token keyword">const</span> <span class="token punctuation">(</span>RestartPolicyAlways    RestartPolicy <span class="token operator">=</span> <span class="token string">"Always"</span>RestartPolicyOnFailure RestartPolicy <span class="token operator">=</span> <span class="token string">"OnFailure"</span>RestartPolicyNever     RestartPolicy <span class="token operator">=</span> <span class="token string">"Never"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>restartPolicy 仅指通过kubelet在同一节点上重新启动Container。通过kubelet重新启动的退出容器每次重启都会有时间延迟，该延迟以指数级增加，上限为5分钟。如果容器重启后成功运行了10分钟，那么延迟重置。</p><p>不同类型的控制器有不同的Pod restartPolicy：</p><ul><li><code>Job</code>：适用于一次性任务如批量计算，任务结束后 Pod 会被此类控制器清除。Job 的重启策略只能是<code>&quot;OnFailure&quot;</code>或者<code>&quot;Never&quot;</code>。</li><li><code>Replication Controller</code>, <code>ReplicaSet</code>, or <code>Deployment</code>：此类控制器希望 Pod 一直运行下去，它们的重启策略只能是<code>&quot;Always&quot;</code>。</li><li><code>DaemonSet</code>：每个节点上启动一个 Pod，很明显此类控制器的重启策略也应该是<code>&quot;Always&quot;</code>。</li></ul><h2 id="Init-Container"><a href="#Init-Container" class="headerlink" title="Init Container"></a>Init Container</h2><p>了解了 Pod 状态后，首先来了解下 Pod 中的 <code>Init Container</code>，也就是我们平时常说的<strong>初始化容器</strong>。<code>Init Container</code>就是用来做初始化工作的容器，可以是一个或者多个，所以<code>PodSec</code>中<code>InitContainers</code>是一个Container切片。如果有多个的话，这些容器会按定义的顺序依次执行。我们知道一个 Pod 里面的所有容器是共享<code>Volume</code>和<code>Network namespace</code> 的，所以<code>Init Container</code>里面产生的数据可以被主容器使用到。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/426a4cb7a313e320.png"></p><p>从上图可以看到，Init Container(s) 和 Infra 都不属于 main Container(s) 的，三者相互独立。实际上，启动玩Infra后，就开始启动初始化容器，只有所有的初始化容器执行完之后，主容器才会被启动。也就是说，在运行我们真正想要的Container之前，可以通过Init Container来预先做一些事。比如：</p><ul><li>等待其他模块 Ready：这个可以用来解决服务之间的依赖问题，比如我们有一个 Web 服务的Pod，该服务又依赖于另外一个Mysql服务的Pod，但是在我们启动这个 Web 服务的时候我们并不能保证依赖的这个Mysql服务就已经启动起来了，所以可能会出现一段时间内 Web 服务连接数据库异常。要解决这个问题的话我们就可以在 Web 服务的 Pod 中使用一个 <code>InitContainer</code>，在这个初始化容器中去检查Mysql服务是否已经准备好了，准备好了过后初始化容器就结束退出，然后我们主容器的 Web 服务才被启动起来，这个时候去连接数据库就不会有问题了。</li><li>做初始化配置：比如集群里检测所有已经存在的成员节点，为主容器准备好集群的配置信息，这样主容器起来后就能用这个配置信息加入集群。</li><li>其它场景：如将 Pod 注册到一个中央数据库、配置中心等。</li></ul><p>做个小实验，在 nginx Pod中使用Init Container，去初始化nginx的index页面，即下载一个html文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># init_test.yaml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> init<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> workdir    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> wget    <span class="token punctuation">-</span> <span class="token string">"-O"</span>    <span class="token punctuation">-</span> <span class="token string">"/work-dir/index.html"</span>    <span class="token punctuation">-</span> http<span class="token punctuation">:</span>//www.baidu.com    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> workdir      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/work-dir"</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> workdir      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的资源清单中，首先在Pod顶层声明了一个名为workdir的<code>Volume</code>，且其类型为<code>emptyDir</code>，不同于之前用过的hostPath，emptyDir是一个<code>临时</code>目录，数据会保存在kubelet的工作目录下，且生命周期等同于Pod的声明周期。</p><p>接着，定义了一个初始化容器，该容器会下载一个html文件到<code>/work-dir</code>目录下面，但是由于我们将该目录挂载到了全局的 Volume，所以宿主机相应目录也会同步。同样，主容器 nginx 也将目录 <code>/usr/share/nginx/html</code> 声明挂载到了全局的 Volume，所以在主容器的该目录下面也会同步初始化容器中创建的 <code>index.html</code> 文件。</p><p>直接创建上面的 Pod：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl apply -f init_test.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行完之后立刻用<code>describe</code>查看Pod详细状态，这截取一部分</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl describe pod init-demoName:         init-demoNamespace:    defaultPriority:     <span class="token number">0</span>Node:         node1/192.168.186.150Start Time:   Mon, 07 Mar <span class="token number">2022</span> <span class="token number">16</span>:57:25 +0800Labels:       <span class="token operator">&lt;</span>none<span class="token operator">></span>Annotations:  kubectl.kubernetes.io/last-applied-configuration:                <span class="token punctuation">&#123;</span><span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span><span class="token string">"v1"</span>,<span class="token string">"kind"</span><span class="token builtin class-name">:</span><span class="token string">"Pod"</span>,<span class="token string">"metadata"</span>:<span class="token punctuation">&#123;</span><span class="token string">"annotations"</span>:<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,<span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"init-demo"</span>,<span class="token string">"namespace"</span><span class="token builtin class-name">:</span><span class="token string">"default"</span><span class="token punctuation">&#125;</span>,<span class="token string">"spec"</span>:<span class="token punctuation">&#123;</span><span class="token string">"containers"</span>:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"image"</span><span class="token builtin class-name">:</span><span class="token string">"ngi...Status:       PendingIP:           IPs:          &lt;none>Init Containers:  install:    Container ID:      Image:         busybox    Image ID:          Port:          &lt;none>    Host Port:     &lt;none>    Command:      wget      -O      /work-dir/index.html      http://www.baidu.com    State:          Waiting      Reason:       PodInitializing....Containers:  nginx:    Container ID:       Image:          nginx    Image ID:           Port:           80/TCP    Host Port:      0/TCP    State:          Waiting      Reason:       PodInitializingReady:          False....Conditions:  Type              Status  Initialized       False   Ready             False   ContainersReady   False   PodScheduled      True ....Events:  Type    Reason     Age        From               Message  ----    ------     ----       ----               -------  Normal  Scheduled  &lt;unknown>  default-scheduler  Successfully assigned default/init-demo to node1  Normal  Pulling    3s         kubelet, node1     Pulling image "</span>busybox"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，此时Pod的状态还是<code>Pending</code>，并不是<code>Running</code>，先看Events，发现此时初始化容器的镜像真正拉取，即容器还未见建立。所以在Init Containers中可以看到该初始化容器的State为<code>Waiting</code>。因为初始化容器未完成，所以Conditions.Initialized也为<code>false</code>。最关键的，Containers（main Container）中的所有容器（虽然这里只有一个）都会是<code>Waiting</code>状态，还未建立，自然也没有容器ID等信息。</p><p>过段时间再次查看Pod状态，此时所有的主容器都成功运行，状态为<code>Running</code>，而初始化容器变为了<code>Completed</code>。还可以从其中看到初始化容器执行的命令，main Container的ID等等。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl describe pod init-demoName:         init-demoNamespace:    defaultPriority:     <span class="token number">0</span>Node:         node1/192.168.186.150Start Time:   Mon, 07 Mar <span class="token number">2022</span> <span class="token number">16</span>:57:25 +0800Labels:       <span class="token operator">&lt;</span>none<span class="token operator">></span>Annotations:  kubectl.kubernetes.io/last-applied-configuration:                <span class="token punctuation">&#123;</span><span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span><span class="token string">"v1"</span>,<span class="token string">"kind"</span><span class="token builtin class-name">:</span><span class="token string">"Pod"</span>,<span class="token string">"metadata"</span>:<span class="token punctuation">&#123;</span><span class="token string">"annotations"</span>:<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,<span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"init-demo"</span>,<span class="token string">"namespace"</span><span class="token builtin class-name">:</span><span class="token string">"default"</span><span class="token punctuation">&#125;</span>,<span class="token string">"spec"</span>:<span class="token punctuation">&#123;</span><span class="token string">"containers"</span>:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"image"</span><span class="token builtin class-name">:</span><span class="token string">"ngi...Status:       RunningIP:           10.244.2.3IPs:  IP:  10.244.2.3Init Containers:  install:    Container ID:  docker://72e3d8995cad94fc718ec7f2067ff5840a47c53b98bbe28bbd6ea34bc11d1aad    Image:         busybox    Image ID:      docker-pullable://busybox@sha256:5acba83a746c7608ed544dc1533b87c737a0b0fb730301639a0179f9344b1678    Port:          &lt;none>    Host Port:     &lt;none>    Command:      wget      -O      /work-dir/index.html      http://www.baidu.com    State:          Terminated      Reason:       Completed      Exit Code:    0      Started:      Mon, 07 Mar 2022 16:57:44 +0800      Finished:     Mon, 07 Mar 2022 16:57:44 +0800    Ready:          True...Containers:  nginx:    Container ID:   docker://5e7dc96a79128ac5941e38e6163bfe3696d046f07d3bec28fe24c6a184f65e08    Image:          nginx    Image ID:       docker-pullable://nginx@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31    Port:           80/TCP    Host Port:      0/TCP    State:          Running      Started:      Mon, 07 Mar 2022 16:57:46 +0800    Ready:          True...Conditions:  Type              Status  Initialized       True   Ready             True   ContainersReady   True   PodScheduled      True ...Events:  Type    Reason     Age        From               Message  ----    ------     ----       ----               -------  Normal  Scheduled  &lt;unknown>  default-scheduler  Successfully assigned default/init-demo to node1  Normal  Pulling    7m16s      kubelet, node1     Pulling image "</span>busybox<span class="token string">"  Normal  Pulled     6m58s      kubelet, node1     Successfully pulled image "</span>busybox<span class="token string">"  Normal  Created    6m58s      kubelet, node1     Created container install  Normal  Started    6m57s      kubelet, node1     Started container install  Normal  Pulling    6m56s      kubelet, node1     Pulling image "</span>nginx<span class="token string">"  Normal  Pulled     6m55s      kubelet, node1     Successfully pulled image "</span>nginx"  Normal  Created    6m55s      kubelet, node1     Created container nginx  Normal  Started    6m55s      kubelet, node1     Started container nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Events可以看出，当Pod被分配给node之后，会首先建立Init Container，完成后才是主容器们。当然，最先建立的应该是Infra，即Pause，它要比Init Container建立的更早，因为要为Pod建立namespace等，不过对用户是透明的。</p><p>Pod建立完后，就可以试着去访问那个html了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl get pods -o wideNAME        READY   STATUS    RESTARTS   AGE   IP           NODE    NOMINATED NODE   READINESS GATESinit-demo   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          16m   <span class="token number">10.244</span>.2.3   node1   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">10.244</span>.2.3<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>--STATUS OK--<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span> <span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span>content-type <span class="token assign-left variable">content</span><span class="token operator">=</span>text/html<span class="token punctuation">;</span><span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-<span class="token operator"><span class="token file-descriptor important">8</span>></span><span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span>X-UA-Compatible <span class="token assign-left variable">content</span><span class="token operator">=</span>IE<span class="token operator">=</span>Edge<span class="token operator">></span><span class="token operator">&lt;</span>meta <span class="token assign-left variable">content</span><span class="token operator">=</span>always <span class="token assign-left variable">name</span><span class="token operator">=</span>referrer<span class="token operator">></span><span class="token operator">&lt;</span>link <span class="token assign-left variable">rel</span><span class="token operator">=</span>stylesheet <span class="token assign-left variable">type</span><span class="token operator">=</span>text/css <span class="token assign-left variable">href</span><span class="token operator">=</span>http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>百度一下，你就知道<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span> <span class="token operator">&lt;</span>body <span class="token assign-left variable">link</span><span class="token operator">=</span><span class="token comment">#0000cc> </span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h2><p>我们知道 Pod 是 Kubernetes 集群中的最小单元，而 Pod 是由容器组成的，所以在讨论 Pod 的生命周期的时候我们可以先来讨论下容器的生命周期。实际上 Kubernetes 为我们的容器提供了生命周期的钩子，就是我们说的<code>Pod Hook</code>。它虽然叫Pod Hook，但却是对容器的Hook。</p><p>Pod Hook 是由 kubelet 发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。我们可以同时为 Pod 中的所有容器都配置 hook。</p><p>k8s有两种钩子：</p><ul><li><code>PostStart</code>：这个钩子在容器创建后立即执行。但是，并不能保证钩子将在容器 ENTRYPOINT 之前运行，因为没有参数传递给处理程序。主要用于资源部署、环境准备等。</li><li><code>PreStop</code>：这个钩子在容器终止之前立即被调用。它是阻塞的，意味着它是同步的，所以它必须在删除容器的调用发出之前完成。主要用于优雅关闭应用程序、通知其他系统等。如果钩子在执行期间挂起，Pod 阶段将一直停留在 running 。</li></ul><p>这两个结构可以在源码中找到，位于podSpec.Container.Lifecycle中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A single application container that you want to run within a pod.</span><span class="token keyword">type</span> Container <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    Lifecycle <span class="token operator">*</span>Lifecycle <span class="token string">`json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token comment">// Lifecycle describes actions that the management system should take in response to container lifecycle</span><span class="token comment">// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks</span><span class="token comment">// until the action is complete, unless the container process fails, in which case the handler is aborted.</span><span class="token keyword">type</span> Lifecycle <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>PostStart <span class="token operator">*</span>Handler <span class="token string">`json:"postStart,omitempty" protobuf:"bytes,1,opt,name=postStart"`</span><span class="token comment">// PreStop is called immediately before a container is terminated.</span>PreStop <span class="token operator">*</span>Handler <span class="token string">`json:"preStop,omitempty" protobuf:"bytes,2,opt,name=preStop"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 PostStart 或者 PreStop 钩子失败， 它会杀死容器。所以我们应该让钩子函数尽可能的<code>轻量</code>。当然有些情况下，长时间运行命令是合理的， 比如在停止容器之前预先保存状态。</p><p>有两种方式实现上面的钩子：</p><ul><li><code>Exec</code> - 用于执行一段特定的命令，不过要注意的是该命令消耗的资源会被计入容器。</li><li><code>HTTP</code> - 对容器上的特定的端点执行 HTTP 请求。</li></ul><p>举个例子，这里定义一个nginx Pod，并设置一个简单的前置钩子，写入一句话到 /usr/share/message 文件中，资源清单如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hook<span class="token punctuation">-</span>demo1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hook<span class="token punctuation">-</span>demo1    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>      <span class="token key atrule">postStart</span><span class="token punctuation">:</span>        <span class="token key atrule">exec</span><span class="token punctuation">:</span>          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo Hello from the postStart handler > /usr/share/message"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建上述Pod：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl apply -f poststart_test.yaml pod/poststart-demo created<span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl get pods poststart-demoNAME             READY   STATUS    RESTARTS   AGEpoststart-demo   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          35s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建成功后可以查看容器中 <code>/usr/share/message</code> 文件是否内容正确，由于这个Pod就一个容器，所以下面两个命令是等价的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it poststart-demo <span class="token function">cat</span> /usr/share/messageHello from the postStart handler<span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it poststart-demo -c poststart-demo1 <span class="token function">cat</span> /usr/share/messageHello from the postStart handler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实验完<code>postStart</code>后，再来看看<code>preStop</code>，顾名思义，就是再容器结束前触发的钩子。当用户请求删除含有Pod的资源对象时（如Pod本身、Deployment等），k为了让容器优雅的关闭（进程正常结束当前工作，再关容器），k8s可以通过<code>preStop</code>在容器关闭前结束进程。</p><p>比如，这里仍然创建nginx Pod，并在容器中声明一个<code>preStop</code>，功能仅为打印信息。Volume使信息同步到主机中。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prestop<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> message    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /home/sakura/k8s/tmp  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> prestop<span class="token punctuation">-</span>demo1    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> message      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/    <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>      <span class="token key atrule">preStop</span><span class="token punctuation">:</span>        <span class="token key atrule">exec</span><span class="token punctuation">:</span>          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"echo Hello from the preStop Handler > /usr/share/message"</span><span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上述Pod，并查看其被分配到了哪个节点：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl apply -f prestop_test.yamlpod/prestop-demo created<span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl describe pod prestop <span class="token operator">|</span> <span class="token function">grep</span> assign  Normal  Scheduled  <span class="token operator">&lt;</span>unknown<span class="token operator">></span>  default-scheduler  Successfully assigned default/prestop-demo to node1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，Pod被分配给了node1节点。然后，删除该Pod，在node1上查看该钩子是否被触发：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl delete pod prestop-demopod <span class="token string">"prestop-demo"</span> deleted<span class="token punctuation">[</span>root@node1 tmp<span class="token punctuation">]</span>$ <span class="token function">ls</span>message<span class="token punctuation">[</span>root@node1 tmp<span class="token punctuation">]</span>$ <span class="token function">cat</span> message Hello from the preStop Handler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，Hook 调用的日志没有暴露个给 Pod，所以只能通过 describe 命令来获取。如果<code>postStart</code>或 <code>preStop</code>失败阻塞，可以在Event中看到<code>FailedPostStartHook</code> 或 <code>FailedPreStopHook</code>的信息。</p><h2 id="Pod健康检查"><a href="#Pod健康检查" class="headerlink" title="Pod健康检查"></a>Pod健康检查</h2><p>接下来看看Pod健康检查部分。顾名思义，健康检查就是定时检查一下Pod是否健康，严格来讲是检查Pod中Container是否健康。容器怎么才算健康，k8s认为，一是正在运行，二是已就绪可以通信。这两种健康状态分别用<code>liveness probe</code>和<code>readindess probe</code>来检查。probe是探针的意思，很形象了，定期去探测，像探针一样。</p><ul><li>kubelet 通过使用 <code>liveness probe</code> 来确定容器是否正在运行，通俗点将就是是否还活着。一般来说，如果容器崩溃了， Kubernetes 就会立刻知道它已经终止了，然后就会重启这个程序。而我们的 liveness probe 的目的就是来捕获到当前应用程序还没有终止，还没有崩溃，如果出现了这些情况，那么就<strong>重启</strong>处于该状态下的容器，使应用程序在存在 bug 的情况下依然能够继续运行下去。</li><li>kubelet 使用 <code>readiness probe</code> 来确定容器是否已经就绪可以接收流量过来了。这个探针通俗点讲就是说是否准备好了，现在可以开始工作了。只有当 Pod 中的容器都处于就绪状态的时候 kubelet 才会认定该 Pod 处于就绪状态，因为一个 Pod 下面可能会有多个容器。当然 Pod 如果处于非就绪状态，那么我们就会将他从 Service 的 Endpoints 列表中移除出来，这样我们的流量就不会被路由到这个 Pod 里面来了。</li></ul><p>这两个探针也是可以在源码中找到的，位于Container结构中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A single application container that you want to run within a pod.</span><span class="token keyword">type</span> Container <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Periodic probe of container liveness.</span><span class="token comment">// Container will be restarted if the probe fails.</span>    LivenessProbe <span class="token operator">*</span>Probe <span class="token string">`json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`</span>    <span class="token comment">// Periodic probe of container service readiness.</span><span class="token comment">// Container will be removed from service endpoints if the probe fails.</span>    ReadinessProbe <span class="token operator">*</span>Probe <span class="token string">`json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>资源清单中，探针支持三种配置方式：</p><ul><li>exec：执行一段命令</li><li>http：检测某个 http 请求</li><li>tcpSocket：使用此配置，kubelet 将尝试在指定端口上打开容器的套接字。如果可以建立连接，容器被认为是健康的，如果不能就认为是失败的。实际上就是检查端口。</li></ul><p>这里只说第一个，exec。</p><p>先说说<code>liveness probe</code>，如果用exec的话，它其实一条周期性执行的命令。如果该命令执行成功，说明容器还活着，不然的话，就会认为容器已经宕机了，然后重启容器，怎么重启，就是前面说的<code>重启策略</code>了。</p><p>实验一下，编写一个Pod，就一个容器。容器里声明一个<code>liveness probe</code>，这个probe会每5秒打印容器内的一个文件，仅此而已。但是这个容器会做一件事，那就是在启动之初创建上面那个文件，然后在30秒后把它给删了。资源清单如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>exec<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">args</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> /bin/sh    <span class="token punctuation">-</span> <span class="token punctuation">-</span>c    <span class="token punctuation">-</span> touch /tmp/healthy; sleep 30; rm <span class="token punctuation">-</span>rf /tmp/healthy; sleep 600    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>      <span class="token key atrule">exec</span><span class="token punctuation">:</span>        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> cat        <span class="token punctuation">-</span> /tmp/healthy      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在容器启动时，它会执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ /bin/sh -c <span class="token string">"touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在容器内，声明了一个<code>livenessProbe</code>，其中的exec不用说，而后面两个参数分别代表第一次延时和执行间隔，具体为：</p><ul><li><code>initialDelaySeconds</code>：表示在第一次执行探针的时候要等待5秒，这样能够确保我们的容器能够有足够的时间启动起来。想象一下，如果没有这个初始延时，容器启动完成之前探针就执行了，那么它肯定会失败的。这样的话，kubelet 就认为该容器需要重启，从而无限制的重启容器。</li><li><code>periodSeconds</code>：表示让 kubelet 每隔5秒执行一次探针，也就是每5秒执行一次上面的<code>cat /tmp/healthy</code>命令，如果命令执行成功了，将返回0，那么 kubelet 就会认为当前这个容器是存活的，如果返回的是非0值，那么 kubelet 就会把该容器杀掉然后重启它。默认是10秒，最小1秒。</li></ul><p>直接运行该Pod，并在30s内查看Events，发现没有什么信息，容器正常启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl apply -f liveness-exec.yaml pod/liveness-exec created<span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl describe pod liveness-exec<span class="token punctuation">..</span>. Events:  Type    Reason     Age        From               Message  ----    ------     ----       ----               -------  Normal  Scheduled  <span class="token operator">&lt;</span>unknown<span class="token operator">></span>  default-scheduler  Successfully assigned default/liveness-exec to node2  Normal  Pulling    20s        kubelet, node2     Pulling image <span class="token string">"busybox"</span>  Normal  Pulled     4s         kubelet, node2     Successfully pulled image <span class="token string">"busybox"</span>  Normal  Created    4s         kubelet, node2     Created container liveness  Normal  Started    4s         kubelet, node2     Started container liveness<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等一会后（大于30s），容器已经把<code>/tmp/healthy</code>删了，所以探针命令不会执行成功了，这时候再看一下Events：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl describe pod liveness-exec<span class="token punctuation">..</span>.Events:  Type     Reason     Age                  From               Message  ----     ------     ----                 ----               -------  Normal   Scheduled  <span class="token operator">&lt;</span>unknown<span class="token operator">></span>            default-scheduler  Successfully assigned default/liveness-exec to node2  Normal   Pulling    71s <span class="token punctuation">(</span>x2 over 2m38s<span class="token punctuation">)</span>  kubelet, node2     Pulling image <span class="token string">"busybox"</span>  Normal   Pulled     55s <span class="token punctuation">(</span>x2 over 2m22s<span class="token punctuation">)</span>  kubelet, node2     Successfully pulled image <span class="token string">"busybox"</span>  Normal   Created    55s <span class="token punctuation">(</span>x2 over 2m22s<span class="token punctuation">)</span>  kubelet, node2     Created container liveness  Normal   Started    55s <span class="token punctuation">(</span>x2 over 2m22s<span class="token punctuation">)</span>  kubelet, node2     Started container liveness  Warning  Unhealthy  11s <span class="token punctuation">(</span>x6 over 111s<span class="token punctuation">)</span>   kubelet, node2     Liveness probe failed: cat: can<span class="token string">'t open '</span>/tmp/healthy': No such <span class="token function">file</span> or directory  Normal   Killing    11s <span class="token punctuation">(</span>x2 over 101s<span class="token punctuation">)</span>   kubelet, node2     Container liveness failed liveness probe, will be restarted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>liveness probe</code>执行失败后，Pod变成了<code>unhealthy</code>，从描述中可以看到是因为这个探针运行失败了。紧接着，kubelet开始重启这个Container，所以会把原来那个<code>kill</code>掉，重启。用这个探针的话，容器只能”存活“30s，然后就会被重启：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubectl get pod liveness-execNAME            READY   STATUS    RESTARTS   AGEliveness-exec   <span class="token number">1</span>/1     Running   <span class="token number">4</span>          7m24s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大约每隔30s，上述RESTARTS数就会加一。</p><p><code>readiness probe</code>的配置跟<code>liveness probe</code>基本上一致的。唯一的不同是使用<code>readinessProbe</code>而不是<code>livenessProbe</code>。两者如果同时使用的话就可以确保流量不会到达还未准备好的容器，准备好过后，如果应用程序出现了错误，则会重新启动容器。这个以后再说。</p><p>另外除了上面的<code>initialDelaySeconds</code>和<code>periodSeconds</code>属性外，探针还可以配置如下几个参数：</p><ul><li>timeoutSeconds：探测超时时间，默认1秒，最小1秒。</li><li>successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是 1，但是如果是<code>liveness</code>则必须是 1。最小值是 1。</li><li>failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是 3，最小值是 1。</li></ul><p>另外，<code>initialDelaySeconds</code>用来确保在容器启动后才执行探针，所以设置时间。但实际上，很多容器的启动时间是不确定的，比如拉镜像的时间很不稳定，如果设久了又不合适，那怎么办？</p><p>在 k8s <code>v1.16</code> 版本官方特地新增了一个 <code>startupProbe（启动探针）</code>，该探针将推迟所有其他探针，直到 Pod 完成启动为止，使用方法和存活探针一样：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">startupProbe</span><span class="token punctuation">:</span>  <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">30</span>  <span class="token comment"># 尽量设置大点</span>  <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这里的配置表示我们的慢速容器最多可以有5分钟（30个检查 * 10秒= 300s）来完成启动，期间不会有其他探针执行。</p><h2 id="Pod运行资源"><a href="#Pod运行资源" class="headerlink" title="Pod运行资源"></a>Pod运行资源</h2><p>实际上上面几个步骤就是影响一个 Pod 生命周期的大的部分，但是还有一些细节也会在 Pod 的启动过程进行设置，比如在容器启动之前还会为当前的容器设置分配的 CPU、内存等资源，我们知道我们可以通过 CGroup 来对容器的资源进行限制，同样的，在 Pod 中我们也可以直接配置<code>某个容器</code>使用的 CPU 或者内存的上限。</p><p>现在的OS基本都是分时系统，即CPU是按<code>时间片</code>去分配的。所以，哪个任务申请的CPU时间片越多，那么它得到的CPU资源越多，好理解。</p><p>在CGroup中，CPU资源是有量化和单位的，以<code>核</code>来换算：</p><blockquote><p>1 Core = 1000 m</p><p>0.5 Core  = 500 m</p></blockquote><p><code>m</code>就是毫核的意思，k8s集群中的每一个节点都可以通过OS的命令来确定本节点的CPU内核数量，然后将这个数量乘以1000，就是node的总CPU资源数。在Pod中，可以通过配置<code>requests</code>和<code>limits</code>的配置来设置对资源的申请和限制。</p><ul><li><code>spec.containers[].resources.requests.cpu</code>：CPU请求值，Kubernetes 调度算法里的依据值，可以超过；</li><li><code>spec.containers[].resources.limits.cpu</code>：CPU 上限值，可以短暂超过，容器也不会被停止。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A single application container that you want to run within a pod.</span><span class="token keyword">type</span> Container <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Compute Resources required by this container.</span>    Resources ResourceRequirements <span class="token string">`json:"resources,omitempty" protobuf:"bytes,8,opt,name=resources"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ResourceRequirements describes the compute resource requirements.</span><span class="token keyword">type</span> ResourceRequirements <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Limits describes the maximum amount of compute resources allowed.</span>Limits ResourceList <span class="token string">`json:"limits,omitempty" protobuf:"bytes,1,rep,name=limits,casttype=ResourceList,castkey=ResourceName"`</span><span class="token comment">// Requests describes the minimum amount of compute resources required.</span><span class="token comment">// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,</span><span class="token comment">// otherwise to an implementation-defined value.</span>Requests ResourceList <span class="token string">`json:"requests,omitempty" protobuf:"bytes,2,rep,name=requests,casttype=ResourceList,castkey=ResourceName"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>requests</code>是用于集群调度使用的资源，而<code>limits</code>才是真正用于资源限制的配置。如果一个Pod中某个容器的<code>requests.cpu</code>大于任何node的CPU核数，那么这个Pod将无法调度，因为没有节点可以满足资源申请。</p><p>定义一个Pod，其中只有一个容器，配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> resource<span class="token punctuation">-</span>demo1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> resource<span class="token punctuation">-</span>demo1    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token key atrule">requests</span><span class="token punctuation">:</span>        <span class="token key atrule">memory</span><span class="token punctuation">:</span> 50Mi        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 50m      <span class="token key atrule">limits</span><span class="token punctuation">:</span>        <span class="token key atrule">memory</span><span class="token punctuation">:</span> 100Mi        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，容器会申请CPU资源50m，也就是 0.05core，这 0.05 core 也就是占了 1 CPU 里的 5% 的资源时间。而限制资源是给的是 100m，但是需要注意的是 CPU 资源是可压缩资源，也就是容器达到了这个设定的上限后，容器性能会下降，但是不会终止或退出。同样，内存申请为50M，限制为100M。</p><blockquote><p>这里注意的是<code>MiB ≠ MB</code>，MB 是十进制单位，MiB 是二进制，平时我们以为 MB 等于 1024KB，其实<code>1MB=1000KB</code>，<code>1MiB</code>才等于<code>1024KiB</code>。中间带字母 i 的是国际电工协会（IEC）定的，走1024乘积；KB、MB、GB是国际单位制，走1000乘积。</p></blockquote><p>创建这个Pod：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl apply -f resource-test.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个Pod被调度到了node2中，所以进去看看里面的容器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 k8s<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> resource-demobd2bf6e8facf   nginx                                               <span class="token string">"/docker-entrypoint.…"</span>   <span class="token number">3</span> minutes ago   Up <span class="token number">3</span> minutes             k8s_resource-demo1_resource-demo1_default_37db961b-249e-48a4-9f4d-5542de6b37e5_04444a3a0bdf0   registry.aliyuncs.com/google_containers/pause:3.1   <span class="token string">"/pause"</span>                 <span class="token number">3</span> minutes ago   Up <span class="token number">3</span> minutes             k8s_POD_resource-demo1_default_37db961b-249e-48a4-9f4d-5542de6b37e5_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，第一个就是我们的nginx容器，也就是主容器。第二个是pause容器，也就是Infra，每个Pod都会有一个它。之后就可以通过<code>inspect</code>看下这个容器的详细信息了，其中就包括资源占用相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 k8s<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect bd2bf6e8facf<span class="token punctuation">..</span>. <span class="token string">"CpuShares"</span><span class="token builtin class-name">:</span> <span class="token number">51</span>, <span class="token string">"Memory"</span><span class="token builtin class-name">:</span> <span class="token number">104857600</span>, <span class="token string">"NanoCpus"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"CgroupParent"</span><span class="token builtin class-name">:</span> <span class="token string">"kubepods-burstable-pod37db961b_249e_48a4_9f4d_5542de6b37e5.slice"</span>, <span class="token string">"BlkioWeight"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"BlkioWeightDevice"</span><span class="token builtin class-name">:</span> null, <span class="token string">"BlkioDeviceReadBps"</span><span class="token builtin class-name">:</span> null, <span class="token string">"BlkioDeviceWriteBps"</span><span class="token builtin class-name">:</span> null, <span class="token string">"BlkioDeviceReadIOps"</span><span class="token builtin class-name">:</span> null, <span class="token string">"BlkioDeviceWriteIOps"</span><span class="token builtin class-name">:</span> null, <span class="token string">"CpuPeriod"</span><span class="token builtin class-name">:</span> <span class="token number">100000</span>, <span class="token string">"CpuQuota"</span><span class="token builtin class-name">:</span> <span class="token number">10000</span>, <span class="token string">"CpuRealtimePeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"CpuRealtimeRuntime"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"CpusetCpus"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>, <span class="token string">"CpusetMems"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>, <span class="token string">"Devices"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>, <span class="token string">"DeviceCgroupRules"</span><span class="token builtin class-name">:</span> null, <span class="token string">"DeviceRequests"</span><span class="token builtin class-name">:</span> null, <span class="token string">"KernelMemory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"KernelMemoryTCP"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"MemoryReservation"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"MemorySwap"</span><span class="token builtin class-name">:</span> <span class="token number">104857600</span>, <span class="token string">"MemorySwappiness"</span><span class="token builtin class-name">:</span> null, <span class="token string">"OomKillDisable"</span><span class="token builtin class-name">:</span> false, <span class="token string">"PidsLimit"</span><span class="token builtin class-name">:</span> null, <span class="token string">"Ulimits"</span><span class="token builtin class-name">:</span> null, <span class="token string">"CpuCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"CpuPercent"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"IOMaximumIOps"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token string">"IOMaximumBandwidth"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>, <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Pod 上的资源配置最终也还是通过底层的容器运行时去控制 CGroup 来实现的，而 CGroup 是通过文件系统来进行资源限制的。</p>]]></content>
      
      
      <categories>
          
          <category> k8s上层与应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s之Pod基础</title>
      <link href="/k8s-zhi-pod-ji-chu/"/>
      <url>/k8s-zhi-pod-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>之前说过，出于Docker的进程管理机制，一个Container最好只运行一个进程。因此，k8s以Pod为最基本的调度单位，能够将一些关联性很强的进程分别运行在不同容器中，并将这些容器绑定在一起，从而实现不同进程的联系和管理。如果没有Pod的话，在多节点集群中，这些容器很有可能会被部署到不同的node上，这就导致了这些进程之间不易联系，所以需要把它们“绑“起来放在一个node中运行，这就是Pod设计的初衷。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/eb53d2583485d0b4.png"></p><h2 id="Pod原理"><a href="#Pod原理" class="headerlink" title="Pod原理"></a>Pod原理</h2><p>其实 Pod 也只是一个逻辑概念，真正起作用的还是 Linux 中 容器的 <code>Namespace</code> 和 <code>Cgroup</code> 这两个最基本的概念，Pod 被创建出来其实是一组共享了一些资源的容器而已。首先 Pod 里面的所有容器，都是共享的同一个 <code>Network namespace</code>，但是涉及到文件系统的时候，默认情况下 Pod 里面的容器之间的文件系统是完全隔离的，但是我们可以通过声明来共享同一个 <code>Volume</code>。</p><p>对于共享同一个<code>Network namespace</code>这个概念是不是比较熟悉，在 Docker 网络模式中，我们可以指定新创建的容器和一个已经存在的容器共享一个 Network namespace，在运行容器的时候只需要指定 <code>--net=container:目标容器名</code> 这个参数就可以了，但是这种模式有一个明显的问题，那就是容器的启动有先后顺序问题，那么 Pod 是怎么来处理这个问题的呢？</p><p>那就是加入一个中间容器（没有什么架构是加一个中间件解决不了的？）这个容器叫做 <code>Infra</code> 容器，全称 Infrastructure Container，又叫<code>Pause</code>容器。这个容器在 Pod 中永远都是<code>第一个</code>被创建的容器，这样是不是其他容器都加入到这个 Infra 容器就可以了，这样就完全实现了 Pod 中的所有容器都和 Infra 容器共享同一个 Network namespace 了，如下图所示：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/f2c9fed8ebf3d6e2.png"></p><p>所以当我们部署完成 k8s 集群的时候，首先需要保证在所有节点上可以拉取到默认的 Infra 镜像，默认情况下 Infra 镜像地址为 <code>k8s.gcr.io/pause:3.1</code>，这个容器占用的资源非常少，但是这个镜像默认是需要科学上网的，所以很多时候我们在部署应用的时候一直处于 <code>Pending</code> 状态，因为所有 Pod 最先启动的容器镜像都拉不下来，启动不了，那其他容器肯定也就不能启动了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master k8s<span class="token punctuation">]</span>$ kubelet --help <span class="token operator">|</span><span class="token function">grep</span> infra      --pod-infra-container-image string                                                                          The image whose network/ipc namespaces containers <span class="token keyword">in</span> each pod will use. This docker-specific flag only works when container-runtime is <span class="token builtin class-name">set</span> to docker. <span class="token punctuation">(</span>default <span class="token string">"k8s.gcr.io/pause:3.1"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上面图中我们可以看出普通的容器加入到了 Infra 容器的 Network namespace 中，所以这个 Pod 下面的所有容器就是共享同一个 Network Namespace 了，普通容器不会创建自己的网卡，配置自己的 IP，而是和 Infra 容器<code>共享 IP、端口范围等</code>，而且容器之间的进程可以通过 lo 网卡设备进行通信，也就是说：</p><ul><li>在Pod内部，容器之间可以直接用<code>localhost</code>来通信；</li><li>看到的网络设备信息和Infra容器完全一样；</li><li>同一个Pod下的容器不能绑定相同的端口；</li><li>Pod的声明周期只跟Infra容器一致，而与容器A和B无关。</li></ul><p>当然，Infra还提供其他的namespace，汇总如下：</p><ul><li>PID namespace：Pod中的不同应用程序可以看到其他应用程序的进程ID。</li><li>Network namespace：Pod中的多个容器能够访问同一个IP和端口范围。</li><li>IPC namespace：Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信。</li><li>UTS namespace：Pod中的多个容器共享一个主机名。</li></ul><p>对于文件系统 k8s 是怎么实现让一个 Pod 中的容器共享的呢？默认情况下容器的文件系统是互相隔离的，要实现共享只需要在 Pod 的顶层声明一个 <code>Volume</code>，然后在需要共享这个 Volume 的容器中声明挂载即可。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/0d53d31bcb0b12ac.png"></p><p>比如下面的示例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> counter<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> varlog    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>       <span class="token key atrule">path</span><span class="token punctuation">:</span> /var/log/counter  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> count    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">args</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> /bin/sh    <span class="token punctuation">-</span> <span class="token punctuation">-</span>c    <span class="token punctuation">-</span> <span class="token punctuation">></span><span class="token scalar string">      i=0;      while true;      do        echo "$i: $(date)" >> /var/log/1.log;        i=$((i+1));        sleep 1;      done</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> varlog      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/log  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> count<span class="token punctuation">-</span>log    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>/bin/sh<span class="token punctuation">,</span> <span class="token punctuation">-</span>c<span class="token punctuation">,</span> <span class="token string">'tail -n+1 -f /var/log/1.log'</span><span class="token punctuation">]</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> varlog      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述Pod创建了一个名为varlog的<code>Volume</code>，且这个Volume的类型是<code>hostPath</code>，意味着宿主机的<code>/var/log/counter</code>目录将被这个Pod挂载，即共享。那共享给谁呢？在Pod中需要挂载的容器上声明挂载即可。可以看到，第一个容器count将上述Volume挂载到了自己的<code>/var/log</code>中，挂载点名为carlog，第二个容器count-log也是一样。</p><p>这个方式也是 Kubernetes 中一个非常重要的设计模式：<code>sidecar 模式</code>的常用方式。典型的场景就是容器日志收集，比如上面我们的这个应用，其中应用的日志是被输出到容器的 /var/log 目录上的，这个时候我们可以把 Pod 声明的 Volume 挂载到容器的 /var/log 目录上，然后在这个 Pod 里面同时运行一个 sidecar 容器，他也声明挂载相同的 Volume 到自己容器的 /var/log （或其他）目录上，这样在第一个容器中的日志信息就会同步到sidecar容器中了。这个 sidecar 容器就只需要从 /var/log 目录下面不断消费日志发送到 Elasticsearch 中存储起来就完成了最基本的应用日志的基本收集工作了。</p><p>除了这个应用场景之外使用更多的还是利用 Pod 中的所有容器共享同一个 Network Namespace 这个特性，这样我们就可以把 Pod 网络相关的配置和管理也可以交给一个 sidecar 容器来完成，完全不需要去干涉用户容器，这个特性在现在非常火热的 Service Mesh（服务网格）中应用非常广泛，典型的应用就是 <a href="https://istio.io/">Istio</a>。这个之后再说。</p>]]></content>
      
      
      <categories>
          
          <category> k8s上层与应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker进阶(二): 启动进程</title>
      <link href="/docker-jin-jie-er-qi-dong-jin-cheng/"/>
      <url>/docker-jin-jie-er-qi-dong-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>众所周知，k8s中以Pod作为调度的基本单位，一个Pod中一般有多个Container。那为什么k8s不能像Docker一样以Container一样作为调度单位呢？那是因为，在Docker中，一个Container中最好<code>只运行一个进程</code>，这也是Docker官网建议的做法。至于为什么只运行一个进程为好，就要了解下Container的进程管理了。</p><span id="more"></span><h2 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h2><p>在Docker中，进程管理的基础就是Linux内核中的<code>PID namespace</code>技术，也就是PID名空间。在不同的PID namespace中，进程ID是相互独立的，也就是说：</p><blockquote><p>两个不同的PID namespace下，进程可以拥有相同的PID</p></blockquote><p>Linux内核为所有的PID namespace维护了一个树状结构：最顶层的是系统初始化创建的root namespace，再创建的新PID namespace就称之为child namespace，而原先的PID namespace就是其Parent namespace。通过这种方式，系统中的PID namespace就会形成一个层级体系。</p><p>父namespace中可以看到子namespace中的所有进程，并通过信号等方式对其产生影响，比如kill掉。但是反过来，子无法看见父，也不能影响父。</p><p>可以通过<code>lsns</code>查看Linux中所有的namespace，包括PID namespace。如果只看pid，使用下述命令即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsns <span class="token operator">|</span> <span class="token function">grep</span> pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可用列(用于 –output)：<br>        NS  namespace identifier (inode number)<br>        TYPE  kind of namespace<br>        PATH  path to the namespace<br>        NPROCS  number of processes in the namespace<br>        PID  lowest PID in the namespace<br>        PPID  PPID of the PID<br>        COMMAND  command line of the PID<br>        UID  UID of the PID<br>        USER  username of the PID</p></blockquote><p>在Docker中，每个Container都是Docker Daemon的子进程，每个Container在建立时都会缺省建立一个新的PID namespace，所以每个Container都有自己的PID namespace。通过这种机制，Docker实现了容器间的进程隔离。</p><p>另外，Docker Daemon也会利用PID namespace的树状结构，实现了对容器中的进程交互、监控和回收。当然，Docker还利用了其他namespace，比如UTS、IPC、USER等等，实现了各种系统资源的隔离。</p><p>当<code>docker run</code>一个Container时，其中的启动进程在该PID namespace中的PID为<code>1</code>。比如，这里，我们创建两个<code>redis</code>容器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> run -d --name<span class="token operator">=</span>redis1 redisad704440fbe91fdf113fa551ebf687482d6468b26e240af6f9bf7e09842a6d2e<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> run -d --name<span class="token operator">=</span>redis2 redis6113d916add9615fd154f70e9f74016a53898d8a7b4bf3914913727037edd863<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>随后，给两个容器都装上<code>ps</code>工具包，在容器内使用命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt-get</span> update$ <span class="token function">apt-get</span> <span class="token function">install</span> procps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装完毕后，分别在两个容器内部执行<code>ps -ef</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> redis1 <span class="token function">ps</span> -ef<span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDredis         <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> 08:32 ?        00:00:00 redis-server *:6379root        <span class="token number">362</span>      <span class="token number">0</span>  <span class="token number">0</span> 08:39 ?        00:00:00 <span class="token function">ps</span> -ef<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> redis2 <span class="token function">ps</span> -ef<span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDredis         <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> 08:32 ?        00:00:00 redis-server *:6379root        <span class="token number">353</span>      <span class="token number">0</span>  <span class="token number">0</span> 08:39 ?        00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，两个容器的启动进程都是<code>redis-server</code>，且PID都是1。更重要的是，这些进程的PPID都为0，说明他们的父进程并不在Container中。那么，在宿主机中分别查看下这俩Container中的进程信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">top</span> redis1<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDpolkitd             <span class="token number">45068</span>               <span class="token number">45047</span>               <span class="token number">0</span>                   <span class="token number">16</span>:32               ?                   00:00:00            redis-server *:6379<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">top</span> redis2<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDpolkitd             <span class="token number">45210</span>               <span class="token number">45189</span>               <span class="token number">0</span>                   <span class="token number">16</span>:32               ?                   00:00:00            redis-server *:6379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，两个容器的<code>redis-server *:6379</code>在这个PID namespace中有了新的PID，分别为45068和45210。</p><hr><h2 id="启动进程"><a href="#启动进程" class="headerlink" title="启动进程"></a>启动进程</h2><p>现在，在redis1中再启动一个进程，这个进程的pid当然是随机的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -d redis1 <span class="token function">sleep</span> <span class="token number">10000</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> redis1 <span class="token function">ps</span> -ef<span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDredis         <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> 08:32 ?        00:00:03 redis-server *:6379root        <span class="token number">416</span>      <span class="token number">0</span>  <span class="token number">0</span> 09:22 ?        00:00:00 <span class="token function">sleep</span> <span class="token number">10000</span>root        <span class="token number">423</span>      <span class="token number">0</span>  <span class="token number">0</span> 09:22 ?        00:00:00 <span class="token function">ps</span> -ef<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">top</span> redis1<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDpolkitd             <span class="token number">74762</span>               <span class="token number">74741</span>               <span class="token number">0</span>                   <span class="token number">17</span>:30               ?                   00:00:00            redis-server *:6379root                <span class="token number">74847</span>               <span class="token number">74741</span>               <span class="token number">0</span>                   <span class="token number">17</span>:30               ?                   00:00:00            <span class="token function">sleep</span> <span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题来了，如果在宿主机上kill掉Container的启动进程，也就是上述<code>redis-server *:6379</code>，会发生什么？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token number">45068</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">top</span> redis1Error response from daemon: Container ad704440fbe91fdf113fa551ebf687482d6468b26e240af6f9bf7e09842a6d2e is not running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，当杀掉启动进程后，整个Container直接停掉了。这就意味着，这个Container中的所有进程全部被杀了，包括刚才的sleep进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span><span class="token comment"># ps -ef | grep 74847</span>root      <span class="token number">75781</span>   <span class="token number">7737</span>  <span class="token number">0</span> <span class="token number">17</span>:32 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto <span class="token number">74847</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并且，当我们重新启动Container后，之前那些进程并不会保留，而是从头也就是从启动进程重新运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> start redis1redis1<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">top</span> redis1<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDpolkitd             <span class="token number">75999</span>               <span class="token number">75979</span>               <span class="token number">0</span>                   <span class="token number">17</span>:32               ?                   00:00:00            redis-server *:6379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，重启Container之后，启动进程在该PID namespace中的PID也发生了变化，说明和之前完全是两个进程。</p><blockquote><p>杀掉启动进程后，容器会直接停掉，其中的所有进程也会结束。</p></blockquote><p>这也就解释了，为什么Docker最好一个Container只运行一个进程，也就是启动进程。</p><p>实际上，PID=1的进程对任何OS都是无比重要的。Linux的PID=1进程是<code>init进程</code>，以守护进程方式运行，是所有其他进程的祖先，具有完整的进程声明周期管理能力，这点在OS理论课上提到过。而对于Docker Container而言，PID=1进程就是启动进程，它也会负责容器内部进程管理的工作。</p><p>总结一下：</p><ul><li>每个Container都有自己的PID namespace；</li><li>Container的声明周期和其启动进程的生命周期一致。</li></ul><hr><h2 id="指定启动进程（exec-shell）"><a href="#指定启动进程（exec-shell）" class="headerlink" title="指定启动进程（exec/shell）"></a>指定启动进程（exec/shell）</h2><p>Container的启动进程可以被Dockerfile中的<code>ENTRYPOINT</code>或<code>CMD</code>指令所指令，意味着也可以被<code>docker run</code>命令的启动参数所覆盖。也就是说，容器建立时运行的那个进程，就是它的启动进程，PID为1。</p><p>来看看redis的<code>ENTRYPOINT</code>和<code>CMD</code>：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]...CMD [&quot;redis-server&quot;]...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，如果不覆盖CMD的话，redis容器的启动进程就是执行<code>docker-entrypoint.sh redis-server </code>后启动的redis-server。</p><p>如果覆盖了CMD，那么启动进程就会更改。举个最常见的例子-<code>/bin/bash</code>。在之前的博客里有提到过，后台服务类的Container都不要以<code>-it ... bash</code>的方式启动，因为这样并不会运行相关服务。现在可以更进一步理解，不仅相关服务没有运行，该Container的启动进程也会变为<code>bash</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> run -it --name<span class="token operator">=</span>redis3 redis <span class="token function">bash</span>root@48646a552559:/data$ <span class="token builtin class-name">exit</span>         <span class="token builtin class-name">exit</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span><span class="token comment"># docker top redis3</span><span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDroot                <span class="token number">79982</span>               <span class="token number">79960</span>               <span class="token number">0</span>                   <span class="token number">17</span>:40               pts/0               00:00:00            <span class="token function">bash</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> start redis3redis3<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it redis3 <span class="token function">bash</span><span class="token punctuation">..</span>.<span class="token comment"># 容器安装procps</span><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> redis3 <span class="token function">ps</span> -ef<span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot          <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> 09:40 pts/0    00:00:00 <span class="token function">bash</span>root        <span class="token number">405</span>      <span class="token number">0</span>  <span class="token number">0</span> 09:53 ?        00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过，上面的Dockerfile中<code>ENTRYPOINT</code>和<code>CMD</code>采用的是exec格式，那如果用shell格式会怎么样，仅仅是编写格式不一样吗？为了检验，这里编写一个新的Dockerfile，CMD格式改为shell：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM ubuntu:14.04RUN apt-get update &amp;&amp; apt-get -y install redis-server &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*EXPOSE 6379CMD &quot;&#x2F;usr&#x2F;bin&#x2F;redis-server&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后构建一个新的镜像 redis_shell：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build -t redis_shell -f Dockerfile_redis_shell <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行新的镜像，因为ubuntu镜像本身自带procps，所以不需另外安装，直接ps -ef查看其启动进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span><span class="token comment"># docker run -d --name=redis4 redis_shell</span>4ca1d8bf78201fd9d8b2c5dbc9535c774aff5a82fe8ce3620f2e319f39febdac<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span><span class="token comment"># docker exec redis4 ps -ef</span><span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot          <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">10</span>:18 ?        00:00:00 /bin/sh -c <span class="token string">"/usr/bin/redis-server"</span>root          <span class="token number">8</span>      <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">10</span>:18 ?        00:00:00 /usr/bin/redis-server *:6379root         <span class="token number">11</span>      <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">10</span>:18 ?        00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很神奇的是，<code>/usr/bin/redis-server *:6379</code>并没有成为该Container的启动进程，取而代之的是启动它的一条shell指令。而最核心的<code>redis-server</code>进程由shell命令启动，自然而然的称为了启动进程的子进程。如果是exec格式，根本不会有第一个进程，<code>/usr/bin/redis-server *:6379</code>会直接成为启动进程。这点是shell格式和exec格式一个很重要的不同点。</p><p>不过即使是shell格式，CMD也会被<code>docker run</code>覆盖，即启动进程仍然会被覆盖</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span>$ <span class="token function">docker</span> run -it --name<span class="token operator">=</span>redis5 redis_shell /bin/bashroot@13e3466d688b:/$ <span class="token function">ps</span> -ef<span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot          <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">10</span>:23 pts/0    00:00:00 /bin/bashroot         <span class="token number">16</span>      <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">10</span>:23 pts/0    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下：</p><p>在ENTRYPOINT和CMD字段中，提供两种不同的进程执行方式： shell 和 exec</p><ul><li>shell 方式下，shell命令是启动进程，其运行出的应用是子进程；</li><li>exec方式下，应用就是启动进程。</li></ul><p>通常而言，建议使用<code>exec</code>格式，这样可以将核心进程直接设为启动进程。这也就是为什么各大Image的Dockerfile都使用该格式。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设备驱动</title>
      <link href="/linux-she-bei-qu-dong/"/>
      <url>/linux-she-bei-qu-dong/</url>
      
        <content type="html"><![CDATA[<p>在Linux中，一切皆文件，包括设备。对设备使用接口的实现，其实就是对文件操作接口的实现。本博客将详述一个简单的读写设备驱动的编写，理解设备即文件的理念。</p><p>总所周知，Linux是整体式OS，采用<code>模块</code>的开发方式。当想添加什么新功能时，编写新的模块即可，设备也不例外。设备驱动程序的注册需要依赖模块，因此写驱动之前，要先明白如何编写模块。</p><h2 id="编写Linux内核模块"><a href="#编写Linux内核模块" class="headerlink" title="编写Linux内核模块"></a>编写Linux内核模块</h2><p>这里编写一个简单的Linux内核，用来向内核的日志中打印不同的字符串。一个基础模块的编写不难，无非就是模块的<code>加载</code>函数和<code>卸载</code>函数，在Linux库中分别用<code>module_init()</code>和<code>module_exit</code>来实现。前者为安装模块时执行的动作，后者为卸载模块时执行的动作。因此，只需要在这两个函数中进行输出即可，完整代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token comment">//模块许可证声明</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"Dual BSD/GPLi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//模块加载函数</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printk</span><span class="token punctuation">(</span>KERN_ALERT <span class="token string">"Hello World enter\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//模块卸载函数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ALERT <span class="token string">"Hello World exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//模块的注册</span><span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明模块的作者</span><span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"YeSiyuan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明模块的描述</span><span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"This is a simple example!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明模块的别名</span><span class="token function">MODULE_ALIAS</span><span class="token punctuation">(</span><span class="token string">"A simplest example"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>printk</code>为内核态的输出函数，用于将内容输出进内核日志，可以用<code>dmesg</code>查看日志。<code>MODULE_LICENSE</code>用于指定模块的许可证声明，这个是必须的，包括后面的设备驱动编写。<code>MODULE_AUTHOR</code>、<code>MODULE_DESCRIPTIO</code>、<code>MODULE_ALIAS</code>用来声明作者、描述、别名，都是非必须的。</p><p>编写完成后，即可开始编译。编译需要用Linux内核本身的编译工具，还需要附加一下链接，因此为了编译方便，我们编写一个Makefile文件，内容如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-m <span class="token operator">+=</span> hello.o  <span class="token comment"># 要和编译的cpp文件一致</span>  <span class="token comment">#generate the path</span>CURRENT_PATH<span class="token operator">:=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span> <span class="token comment">#the current kernel version number</span>LINUX_KERNEL<span class="token operator">:=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> uname -r<span class="token punctuation">)</span> <span class="token comment">#the absolute path--根据获取的内核版本拼装绝对路</span>LINUX_KERNEL_PATH<span class="token operator">:=</span>/lib/modules/<span class="token variable">$</span><span class="token punctuation">(</span>LINUX_KERNEL<span class="token punctuation">)</span>/build/ <span class="token comment">#complie object</span><span class="token target symbol">all</span><span class="token punctuation">:</span>        make -C <span class="token variable">$</span><span class="token punctuation">(</span>LINUX_KERNEL_PATH<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>CURRENT_PATH<span class="token punctuation">)</span><span class="token comment">#clean</span> make -C <span class="token variable">$</span><span class="token punctuation">(</span>LINUX_KERNEL_PATH<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>CURRENT_PATH<span class="token punctuation">)</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在工作目录下执行命令make，它会自动找到该上述Makefile进行执行。编译完成后即可安装/卸载该模块。使用<code>insmod hello.ko</code>来安装，使用<code>rmmod hello.ko</code>来卸载，结果如下，注意要<code>sudo</code>。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/c3ee7eee2c20e6bc.png"></p><hr><h2 id="编写Linux设备驱动"><a href="#编写Linux设备驱动" class="headerlink" title="编写Linux设备驱动"></a>编写Linux设备驱动</h2><p>这里将简单的编写一个Linux驱动程序，功能：write 几个整数进去，read 出其和。先要明白，在Linux中设备即文件，对设备驱动程序的实现实际上就是对文件操作各个接口的的实现。文件操作的结构定义在结构体<code>file_operations</code>中，其是一个函数指针的集合，其中比较重要的的为<code>open()</code>，<code>close()</code>，<code>write()</code>,<code> read()</code>。这里就重点实现这四者。</p><p>首先实现<code>open</code>，这个很简单，只需要<code>printk</code>一下就行：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span> ip<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 一般用来做初始化设备的操作 */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后实现<code>close</code>，也只需要<code>printk</code>一下就行：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hello_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span> ip<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 一般用来做和open相反的操作，open申请资源，close释放资源 */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着实现最重要的<code>wirte</code>函数和<code>read</code>函数。这里要求write函数能够写进去2个整数，然后read可以读回两数之和。需要注意的是，用户程序是工作在用户态的，而驱动程序是工作在<code>内核态</code>的，两者是不能直接进行数据通信的，必须借助一些通信函数才能实现，即<code>copy_from_user</code>和<code>copy_to_user</code>，前者将数据从用户空间拷贝到内核空间，后者将数据从内核空间拷贝到用户空间。因此，编写如下write函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">hello_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> fp<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span> loff<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>        <span class="token comment">/* 将用户需要的数据从用户空间copy到内核空间(buf) */</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"data1 = %c\ndata2 = %c\n"</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来开始编写<code>read</code>函数。需要注意的是，文件操作接口中write和read的缓冲区参数的是char*类型的，而求和是数字求和，因此要减去两个z字符‘0’。完成后，计算出两数之和，然后返回该数即可，代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">hello_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> fp<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span> loff<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token comment">/* 将用户需要的数据从内核空间copy到用户空间(buf) */</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> data<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sum is %d\n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写完四个接口实现后，需要在<code>file_operations</code>结构体中对各接口进行注册，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 分配file_operations结构体 */</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> hello_fops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>    <span class="token punctuation">.</span>open  <span class="token operator">=</span> hello_open<span class="token punctuation">,</span>    <span class="token punctuation">.</span>release <span class="token operator">=</span> hello_close<span class="token punctuation">,</span>    <span class="token punctuation">.</span>read <span class="token operator">=</span> hello_read<span class="token punctuation">,</span>    <span class="token punctuation">.</span>write <span class="token operator">=</span> hello_write8<span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，由于设备驱动程序也是借助了Linux的模块机制，添加设备也需要添加模块，因此还要实现init和exit即进行<code>module_init</code>和<code>module_exit</code>。和上一个任务的<code>init</code>不同，该任务由于要新增设备，因此在init的实现中要使用<code>MKDV</code>生成设备号，并使用<code>register_chrdev_region</code>来注册设备字符设备。注册完之后，还要通过<code>cdev_add</code>、<code>cdev_init</code>来分配、设置、注册<code>cdev</code>结构体，最终的init和exit代码为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev<span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 1. 生成并注册设备号 */</span>    devno <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ret  <span class="token operator">=</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span>devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> DEVNAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d fail to register_chrdev_region\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">/* 3. 分配、设置、注册cdev结构体 */</span>    cdev<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev<span class="token punctuation">,</span> devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hello_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d fail to cdev_add\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"Init success!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s : %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">/* 释放资源 */</span>    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写完设备驱动的代码后，同上一个任务，编写Makefile，模块名为ysy_dev，同cpp文件名：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">KERNEL_PATH <span class="token operator">:=</span> /lib/modules/`uname -r`/buildPWD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>MODULE_NAME <span class="token operator">:=</span> ysy_dev obj-m <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MODULE_NAME<span class="token punctuation">)</span>.o <span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNEL_PATH<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> <span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf .*.cmd *.o *.mod.c *.order *.symvers *.tmp *.ko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，模块是模块，设备是设备，设备只是借助模块来注册和卸载，所以设备名不等同于模块名，根据驱动代码可知，设备名为<code>ysy_device</code>。</p><p>使用make进行编译，然后使用insmod来安装该模块，之后使用<code>cat /proc/devices</code>来查看所有设备编号，发现设备安装成功，如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/635f65497e34ca1c.png"></p><p>可以看到，设备安装成功，设备编号为255。但是，到该步为止只是将驱动安装到了内核中，如果想要访问驱动，必须先创建设备节点，通过设备节点来访问，输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mknod</span> /dev/ysy_device c <span class="token number">255</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，c指字符设备，255是主编好，0是次编号，要和编写的设备对用。该命令会创建设备节点和设备挂钩，实际就是一个文件，位于<code>/dev</code>目录下。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/83b75198a56a32bf.png"></p><p>至此，设备驱动与设备节点全部创建成功，可以开始测试。</p><hr><h2 id="设备测试"><a href="#设备测试" class="headerlink" title="设备测试"></a>设备测试</h2><p>编写了的测试程序代码如下，会接收第1个参数作为设备路径，然后使用设备驱动将第2、3个参数写入内核日志，并返回两数之和。不解释了，直接上代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// two num </span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">/* 将要打开的文件的路径通过main函数的参数传入 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s &lt;filename>\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fail to open file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">/* write data */</span>    ret <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read err!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">/* read data */</span>    ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read err!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使命令<code>sudo ./devTest.o /dev/ysy_deivce 3 4 </code>来执行测试程序，打开设备驱动并计算3和4的和，并使用dmesg查看内核缓冲区，结果如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/fc7592f5505a1f5a.png"></p><p>可以看到，不仅测试程序返回了正确的执行结果，驱动程序还在内核中输出了相关信息。包括，两个输入数据分别为3和4，计算的求和结果为7都成功打印在了内核缓冲区。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s资源清单</title>
      <link href="/k8s-zi-yuan-qing-dan/"/>
      <url>/k8s-zi-yuan-qing-dan/</url>
      
        <content type="html"><![CDATA[<p>搭建好k8s之后，就可以在集群中跑一些应用啦，不过在跑之前，要先知道几个概念。</p><span id="more"></span><p>第一个当然就是应用的<code>镜像</code>，因为我们在集群中运行的是容器，所以首先需要将我们的应用打包成镜像，或者直接从仓库中拉，很简单，这里就不再赘述了。</p><p>镜像准备好了，k8s 集群也准备好了，我们就可以把应用部署到集群中了。但是镜像到集群中运行这个过程如何完成呢？</p><p>在之前 Docker 环境下面我们是直接通过命令 <code>docker run</code> 来运行我们的应用的，在 k8s环境下面我们同样也可以用类似 <code>kubectl run</code> 这样的命令来运行我们的应用，但是在 k8s中却是不推荐使用命令行的方式，而是希望使用我们称为<code>资源清单</code>的东西来描述应用，资源清单可以用 YAML 或者 JSON 文件来编写，一般来说 YAML 文件更方便阅读和理解，所以我们的课程中都会使用 YAML 文件来进行描述。</p><p>实际上，我们在集群中部署的应用，就是一个<code>Kubernetes Object</code>，或者叫<code>API Object</code>。在创建k8s对象时，必须提供对象的规约，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。当使用<code>Kubernetes API</code>创建对象时（或直接创建，或基于kubectl），API请求必须在请求体中包含<code>JSON</code>格式的信息，就是上面说的JSON文件。而当使用YAML文件作资源清单时，kubectl会在发起API请求时自动将这些信息转换成JSON格式。</p><p>通过一个资源清单文件来定义好一个应用后，我们就可以通过<code>kubectl</code>工具来直接运行它</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl create -f xxxx.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们知道 kubectl 是直接操作 <code>APIServer</code> 的，所以就相当于把我们的清单提交给了 APIServer，然后集群获取到清单描述的应用信息后存入到 <code>etcd</code> 数据库中，然后 <code>kube-scheduler</code> 组件发现这个时候有一个 <code>Pod</code> 还没有绑定到节点上，就会对这个 Pod 进行一系列的调度，把它调度到一个最合适的节点上，然后把这个节点和 Pod 绑定到一起（写回到 etcd），然后节点上的 kubelet 组件这个时候 watch 到有一个 Pod 被分配过来了，就去把这个 Pod 的信息拉取下来，然后根据描述通过容器运行时把容器创建出来，最后当然同样把 Pod 状态再写回到 etcd 中去，这样就完成了一整个的创建流程。</p><hr><h2 id="第一个容器化应用"><a href="#第一个容器化应用" class="headerlink" title="第一个容器化应用"></a>第一个容器化应用</h2><p>我们创建一个建议的nginx应用，是一个<code>Deployments</code>类型的API对象，其YAML资源清单文件如下，文件名为nginx-deployment.yaml。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1  <span class="token comment"># API版本</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment  <span class="token comment"># API对象类型</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">chapter</span><span class="token punctuation">:</span> first<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token comment"># tells deployment to run 2 pods matching the template</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>  <span class="token comment"># Pod template</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Deployment对象，顾名思义，是用于部署应用的对象。它为Pod和ReplicaSet提供了一个声明式定义(declarative)方法，用来替代以前的<a href="https://www.kubernetes.org.cn/replication-controller-kubernetes">ReplicationController</a>来方便的管理应用。典型的应用场景包括：</p><ul><li>定义Deployment来创建Pod和ReplicaSet</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续Deployment</li></ul></blockquote><p>写完yaml文件后，就可以用<code>kubectl apply</code>来创建上述对象：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl apply -f deployment.apps/nginx-deployment created$ kubectl get podsNAME                            READY   STATUS    RESTARTS   AGEnginx-deploy-786b576769-6lcpn   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          108snginx-deploy-786b576769-cz2f6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          108s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，上述的Deployment创建出了两个Pod，因为资源清单里指令了字段<code>replicas: 2</code>。当然，Deployment本身也是个对象，因此我们也可以通过kubctl来查看到它的状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl get deploymentNAME           READY   UP-TO-DATE   AVAILABLE   AGEnginx-deploy   <span class="token number">2</span>/2     <span class="token number">2</span>            <span class="token number">2</span>           12m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>READY 2/2</code>指该Deployment期望创建2个副本，实际创建了2个副本，这里的副本就是Pod。<code>UP-TO-DATE</code>指有多少个副本已更新到最新状态，这里两个Pod都是最新的。</p><p>这个模板中定义了我们的 Pod 中只有一个名为 nginx 的容器，容器使用的镜像是 <code>nginx:1.7.9</code>（spec.containers[0].image），并且这个容器监听的端口是 80（spec.containers[0].ports[0].containerPort），另外我们还为 Pod 添加了一个<code>app: nginx</code>这样的 Label 标签，这里需要非常注意的是上面的 <code>selector.matchLabels</code> 区域就是来表示我们的 Deployment 来管理哪些 Pod 的，所以这个地方需要和 Pod 模板中的 Label 标签保持一致，非常重要的。</p><p>另外我们也可以发现每个 API 对象都有一个 <code>Metadata</code> 的字段，用来表示该对象的元数据的，比如定义 name、namespace 等，比如上面 Deployment 和 Pod 模板中都有这个字段，至于为什么 Pod 模板中没有 name 这个元信息呢，这是因为 Deployment 这个控制器会自动在他自己的 name 基础上生成 Pod 名，不过 Deployment 下面定义的 Label 标签就没有 Pod 中定义的 Label 标签那么重要了，只是起到一个对该对象标识和过滤的作用。比如我们在查询对象的时候可以带上标签来进行过滤：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl get deployment -l <span class="token assign-left variable">chapter</span><span class="token operator">=</span>first-appNAME           READY   UP-TO-DATE   AVAILABLE   AGEnginx-deploy   <span class="token number">2</span>/2     <span class="token number">2</span>            <span class="token number">2</span>           51m$ kubectl get pods -l <span class="token assign-left variable">app</span><span class="token operator">=</span>nginxNAME                            READY   STATUS    RESTARTS   AGEnginx-deploy-786b576769-6lcpn   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          22mnginx-deploy-786b576769-cz2f6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          22m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们就完成了我们的第一个应用的容器化部署，但是往往我们在部署应用的过程中或多或少会遇到一些问题，这个时候我们可以使用一个 <code>kubectl describe</code> 命令来查看资源对象的详细信息，比如我们用下面的命令来查看 Pod 的详细信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl describe pod nginx-deploy-786b576769-6lcpnName:         nginx-deploy-786b576769-6lcpnNamespace:    defaultPriority:     <span class="token number">0</span>Node:         node1/192.168.186.150Start Time:   Mon, <span class="token number">28</span> Feb <span class="token number">2022</span> <span class="token number">21</span>:07:03 +0800Labels:       <span class="token assign-left variable">app</span><span class="token operator">=</span>nginx              pod-template-hash<span class="token operator">=</span>786b576769Annotations:  <span class="token operator">&lt;</span>none<span class="token operator">></span>Status:       RunningIP:           <span class="token number">10.244</span>.2.4IPs:  IP:           <span class="token number">10.244</span>.2.4Controlled By:  ReplicaSet/nginx-deploy-786b576769Containers:  nginx:    Container ID:   docker://59159005469e5cb0ee5dd544bb11f06bf16bd04290d01d6b0f39a81962f9ef52    Image:          nginx:latest    Image ID:       docker-pullable://nginx@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31    Port:           <span class="token number">80</span>/TCP    Host Port:      <span class="token number">0</span>/TCP    State:          Running      Started:      Mon, <span class="token number">28</span> Feb <span class="token number">2022</span> <span class="token number">21</span>:07:04 +0800    Ready:          True    Restart Count:  <span class="token number">0</span>    Environment:    <span class="token operator">&lt;</span>none<span class="token operator">></span>    Mounts:      /var/run/secrets/kubernetes.io/serviceaccount from default-token-fkt88 <span class="token punctuation">(</span>ro<span class="token punctuation">)</span>Conditions:  Type              Status  Initialized       True   Ready             True   ContainersReady   True   PodScheduled      True Volumes:  default-token-fkt88:    Type:        Secret <span class="token punctuation">(</span>a volume populated by a Secret<span class="token punctuation">)</span>    SecretName:  default-token-fkt88    Optional:    <span class="token boolean">false</span>QoS Class:       BestEffortNode-Selectors:  <span class="token operator">&lt;</span>none<span class="token operator">></span>Tolerations:     node.kubernetes.io/not-ready:NoExecute <span class="token keyword">for</span> 300s                 node.kubernetes.io/unreachable:NoExecute <span class="token keyword">for</span> 300sEvents:  Type    Reason     Age        From               Message  ----    ------     ----       ----               -------  Normal  Scheduled  <span class="token operator">&lt;</span>unknown<span class="token operator">></span>  default-scheduler  Successfully assigned default/nginx-deploy-786b576769-6lcpn to node1  Normal  Pulled     22m        kubelet, node1     Container image <span class="token string">"nginx:latest"</span> already present on machine  Normal  Created    22m        kubelet, node1     Created container nginx  Normal  Started    22m        kubelet, node1     Started container nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到看到很多这个 Pod 的详细信息，比如调度到的节点、状态、IP 等，一般我们比较关心的是下面的 <code>Events</code> 部分，就是我们说的<strong>事件</strong>。在 Kubernetes 创建资源对象的过程中，对该对象的一些重要操作，都会被记录在这个对象的 <code>Events</code> 里面，可以通过 <code>kubectl describe</code> 指令查看对应的结果，所以这个指令会使以后排错过程中经常使用的指令。</p><p><code>Events</code>中越往后的信息越新。比如上面的这个 Pod，可以看到它被创建之后，被调度器调度（Successfully assigned）到了 node1 节点上，然后指定的镜像已经在该节点上存在了，所以没有再去拉取镜像，然后创建我们定义的 nginx 容器，最后启动定义的容器。</p><p>前面说过Deployment支持滚动升级，也就是滚动更新。当我们需要更新Deployment时，可以直接该上述yaml文件。比如这里要将Pod的nginx镜像版本改为latest：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">...</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>latest  <span class="token comment"># 这里被从 1.7.9 修改为latest</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再重新执行一次<code>kubectl apply</code>即可更新。我们不必担心当前的操作是创建，还是更新，k8s会更新yaml文件的内容变化自动处理。也就是，不管是创建还是更新，都可用命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl apply -f nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h2><p>YAML是专门用来写配置文件的语言，非常简洁和强大，远比JSON格式方便，它实质上是一种通用的数据串行化格式。其基本语法规则为：</p><blockquote><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用<code>Tab</code>键，只允许使用空格</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul></blockquote><p>在 Kubernetes 中，我们只需要了解两种结构类型就行了：</p><blockquote><ul><li>Lists</li><li>Maps</li></ul></blockquote><p>也就说，我们编写的资源文件，基本都是Lists和Maps的嵌套。</p><h3 id="MAPS"><a href="#MAPS" class="headerlink" title="MAPS"></a>MAPS</h3><p>就是多个<code>key-value</code>，例如：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，首行的<code>---</code>是有意义的，但这里非必须。它是分隔符，在yaml中可以用它区分多个文件，这就意味着，在一个yaml文件中可以进行多个对象的描述，互相之间用<code>---</code>分隔即可。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ydzs<span class="token punctuation">-</span>site  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 YAML 文件，metadata 这个 KEY 对应的值就是一个 <code>Maps</code> 了，而且嵌套的 labels 这个 KEY 的值又是一个 Map，可以根据需求多层嵌套。</p><p>YAML 根据行缩进来知道内容之间的嗯关联性的。比如上面的 YAML 文件，用了两个空格作为缩进，空格的数量并不重要，但是你得保持一致，并且至少要求一个空格（什么意思？就是你别一会缩进两个空格，一会缩进4个空格）。我们可以看到 name 和 labels 是相同级别的缩进，所以 YAML 处理器就知道了他们属于同一个 Map，而 app 是 labels 的值是因为 app 的缩进更大。</p><blockquote><p>注意！ 在 YAML 文件中绝对不要使用 tab 键来进行缩进，只能空格。</p></blockquote><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p><code>Lists</code>就是列表，说白了就是数组，在 YAML 文件中我们可以这样定义：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">args  <span class="token punctuation">-</span> Cat  <span class="token punctuation">-</span> Dog  <span class="token punctuation">-</span> Fish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然，Lists 的子项也可以是 Maps，Maps 的子项也可以是 Lists 如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ydzs<span class="token punctuation">-</span>site  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> front<span class="token punctuation">-</span>end      <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx      <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flaskapp<span class="token punctuation">-</span>demo      <span class="token key atrule">image</span><span class="token punctuation">:</span> cnych/flaskapp      <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个 YAML 文件，定义了一个叫 containers 的 List 对象，每个子项都由 name、image、ports 组成，每个 ports 都有一个 key 为 containerPort 的 Map 组成。</p><hr><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>那么，我们该如何知道诸如Pod、Deployment这些API对象的资源清单该怎么写呢？有哪些字段需要指定，该怎么指定呢？答案就是官网 =&gt; <a href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/">Workload Resources</a>。诸如Pod、ReplicaSet、Deployment这些都属于API对象的<code>Workload Resources</code>，官网会列出他们：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/3630664c03276690.png"></p><p>点进想看的对象中，即可看见每个字段的意义。比如点进Deployment，可以看到apiVersion、kind、metadata、spec、selector等等。注意，如果字段后面标注了<code>requested</code>，就说明该字段是必须的，不能少。</p><p><img src="https://i.bmp.ovh/imgs/2022/02/644e59ffc3fbe62a.png"></p><p>差Web文档固然是个好方法，但是如果平时我们编写资源清单的时候都这样去查找文档，势必会效率低下。Kubernetes 也考虑到了这点，我们可以直接通过 kubectl 命令行工具来获取这些字段信息，同样的，比如我们要获取 Deployment 的字段信息，我们可以通过 <code>kubectl explain</code> 命令来了解：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl explain deploymentKIND:     DeploymentVERSION:  apps/v1DESCRIPTION:     Deployment enables declarative updates <span class="token keyword">for</span> Pods and ReplicaSets.FIELDS:   apiVersion   <span class="token operator">&lt;</span>string<span class="token operator">></span>     APIVersion defines the versioned schema of this representation of an     object. Servers should convert recognized schemas to the latest internal     value, and may reject unrecognized values. More info:     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#resources</span>   kind <span class="token operator">&lt;</span>string<span class="token operator">></span>     Kind is a string value representing the REST resource this object     represents. Servers may infer this from the endpoint the client submits     requests to. Cannot be updated. In CamelCase. More info:     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#types-kinds</span>   metadata <span class="token operator">&lt;</span>Object<span class="token operator">></span>     Standard object metadata.   spec <span class="token operator">&lt;</span>Object<span class="token operator">></span>     Specification of the desired behavior of the Deployment.   status   <span class="token operator">&lt;</span>Object<span class="token operator">></span>     Most recently observed status of the Deployment.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到上面的信息和我们在 API 文档中查看到的基本一致，比如我们看到其中 <code>spec</code> 字段是一个 <code>&lt;Object&gt;</code> 类型的，证明该字段下面是一个对象，我们可以继续去查看这个字段下面的详细信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl explain deployment.specKIND:     DeploymentVERSION:  apps/v1RESOURCE: spec <span class="token operator">&lt;</span>Object<span class="token operator">></span>DESCRIPTION:     Specification of the desired behavior of the Deployment.     DeploymentSpec is the specification of the desired behavior of the     Deployment.FIELDS:   minReadySeconds  <span class="token operator">&lt;</span>integer<span class="token operator">></span>     Minimum number of seconds <span class="token keyword">for</span> <span class="token function">which</span> a newly created pod should be ready     without any of its container crashing, <span class="token keyword">for</span> it to be considered available.     Defaults to <span class="token number">0</span> <span class="token punctuation">(</span>pod will be considered available as soon as it is ready<span class="token punctuation">)</span>   paused   <span class="token operator">&lt;</span>boolean<span class="token operator">></span>     Indicates that the deployment is paused.   progressDeadlineSeconds  <span class="token operator">&lt;</span>integer<span class="token operator">></span>     The maximum <span class="token function">time</span> <span class="token keyword">in</span> seconds <span class="token keyword">for</span> a deployment to <span class="token function">make</span> progress before it is     considered to be failed. The deployment controller will <span class="token builtin class-name">continue</span> to process     failed deployments and a condition with a ProgressDeadlineExceeded reason     will be surfaced <span class="token keyword">in</span> the deployment status. Note that progress will not be     estimated during the <span class="token function">time</span> a deployment is paused. Defaults to 600s.   replicas <span class="token operator">&lt;</span>integer<span class="token operator">></span>     Number of desired pods. This is a pointer to distinguish between explicit     zero and not specified. Defaults to <span class="token number">1</span>.   revisionHistoryLimit <span class="token operator">&lt;</span>integer<span class="token operator">></span>     The number of old ReplicaSets to retain to allow rollback. This is a     pointer to distinguish between explicit zero and not specified. Defaults to     <span class="token number">10</span>.   selector <span class="token operator">&lt;</span>Object<span class="token operator">></span> -required-     Label selector <span class="token keyword">for</span> pods. Existing ReplicaSets whose pods are selected by     this will be the ones affected by this deployment. It must match the pod     template's labels.   strategy <span class="token operator">&lt;</span>Object<span class="token operator">></span>     The deployment strategy to use to replace existing pods with new ones.   template <span class="token operator">&lt;</span>Object<span class="token operator">></span> -required-     Template describes the pods that will be created.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> k8s上层与应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm搭建k8s集群（单master）</title>
      <link href="/kubeadm-da-jian-k8s-ji-qun-dan-master/"/>
      <url>/kubeadm-da-jian-k8s-ji-qun-dan-master/</url>
      
        <content type="html"><![CDATA[<p>本篇将记录采用<code>kubeadm</code>快速搭建单master的k8s集群的全过程，用于对k8s的学习。为了根据最新的集群特性，我们这里安装目前最新的版本 v1.16.2，如果在生产环境使用，建议使用上一个版本中最大的修正版本，比如 v1.15.5，由于 v1.16 版本和之前的版本有很大变化，主要体现在 APIVersion 移除了之前的一些版本，所以我们这里采用最新的<code> v1.16.2</code> 的版本</p><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>该阶段要在所有节点中都做一遍。</p><p>3个节点，都是 Centos 7.6 系统，内核版本：3.10.0-957.12.2.el7.x86_64，在每个节点上添加 hosts 信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/hosts<span class="token number">192.168</span>.186.147 master<span class="token number">192.168</span>.186.148 node1<span class="token number">192.168</span>.186.149 node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>节点的 hostname 必须使用标准的 DNS 命名，另外千万不用什么默认的 <code>localhost</code> 的 hostname，会导致各种错误出现的。在 Kubernetes 项目里，机器的名字以及一切存储在 Etcd 中的 API 对象，都必须使用标准的 DNS 命名（RFC 1123）。可以使用命令 <code>hostnamectl set-hostname ydzs-node1</code> 来修改 hostname。</p><p>禁用防火墙：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl stop firewalld$ systemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>禁用SELINUX：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ setenforce <span class="token number">0</span>$ <span class="token function">cat</span> /etc/selinux/config<span class="token assign-left variable">SELINUX</span><span class="token operator">=</span>disabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于开启内核 ipv4 转发需要加载 br_netfilter 模块，所以加载下该模块：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ modprobe br_netfilter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建文件<code>/etc/sysctl.d/k8s.conf</code>，添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net.bridge.bridge-nf-call-ip6tables <span class="token operator">=</span> <span class="token number">1</span>net.bridge.bridge-nf-call-iptables <span class="token operator">=</span> <span class="token number">1</span>net.ipv4.ip_forward <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>bridge-nf 使得 netfilter 可以对 Linux 网桥上的 IPv4/ARP/IPv6 包过滤。比如，设置<code>net.bridge.bridge-nf-call-iptables＝1</code>后，二层的网桥在转发包时也会被 iptables的 FORWARD 规则所过滤。常用的选项包括：</p><p>​    &gt; net.bridge.bridge-nf-call-arptables：是否在 arptables 的 FORWARD 中过滤网桥的 ARP 包</p><p>​    &gt; net.bridge.bridge-nf-call-ip6tables：是否在 ip6tables 链中过滤 IPv6 包</p><p>​    &gt; net.bridge.bridge-nf-call-iptables：是否在 iptables 链中过滤 IPv4 包</p><p>​    &gt; net.bridge.bridge-nf-filter-vlan-tagged：是否在 iptables/arptables 中过滤打了 vlan 标签的包。</p></blockquote><p>执行如下命令使修改生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl -p /etc/sysctl.d/k8s.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 ipvs：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&lt;&lt;</span><span class="token string">EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF</span>$ <span class="token function">chmod</span> <span class="token number">755</span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> lsmod <span class="token operator">|</span> <span class="token function">grep</span> -e ip_vs -e nf_conntrack_ipv4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面脚本创建了的<code>/etc/sysconfig/modules/ipvs.modules</code>文件，保证在节点重启后能自动加载所需模块。使用<code>lsmod | grep -e ip_vs -e nf_conntrack_ipv4</code>命令查看是否已经正确加载所需的内核模块。</p><p>接下来还需要确保各个节点上已经安装了 ipset 软件包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> ipset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了便于查看 ipvs 的代理规则，最好安装一下管理工具 ipvsadm：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> ipvsadm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同步服务器时间：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> chrony -y$ systemctl <span class="token builtin class-name">enable</span> chronyd$ systemctl start chronyd$ chronyc sources<span class="token number">210</span> Number of sources <span class="token operator">=</span> <span class="token number">4</span>MS Name/IP address         Stratum Poll Reach LastRx Last sample<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>^+ sv1.ggsrv.de                  <span class="token number">2</span>   <span class="token number">6</span>    <span class="token number">17</span>    <span class="token number">32</span>   -823us<span class="token punctuation">[</span>-1128us<span class="token punctuation">]</span> +/-   98ms^- montreal.ca.logiplex.net      <span class="token number">2</span>   <span class="token number">6</span>    <span class="token number">17</span>    <span class="token number">32</span>    -17ms<span class="token punctuation">[</span>  -17ms<span class="token punctuation">]</span> +/-  179ms^- ntp6.flashdance.cx            <span class="token number">2</span>   <span class="token number">6</span>    <span class="token number">17</span>    <span class="token number">32</span>    -32ms<span class="token punctuation">[</span>  -32ms<span class="token punctuation">]</span> +/-  161ms^* <span class="token number">119.28</span>.183.184                <span class="token number">2</span>   <span class="token number">6</span>    <span class="token number">33</span>    <span class="token number">32</span>   +661us<span class="token punctuation">[</span> +357us<span class="token punctuation">]</span> +/-   38ms$ <span class="token function">date</span>Tue Aug <span class="token number">27</span> 09:28:41 CST <span class="token number">2019</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关闭 swap 分区：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ swapoff -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改<code>/etc/fstab</code>文件，注释掉 SWAP 的自动挂载，使用<code>free -m</code>确认 swap 已经关闭。swappiness 参数调整，修改<code>/etc/sysctl.d/k8s.conf</code>添加下面一行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vm.swappiness<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行<code>sysctl -p /etc/sysctl.d/k8s.conf</code>使修改生效。</p><p>接下来可以安装 Docker：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> -y yum-utils <span class="token punctuation">\</span>  device-mapper-persistent-data <span class="token punctuation">\</span>  lvm2<span class="token comment"># 如果下面命令执行超时，可以使用阿里云的源代替：http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span>$ yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://download.docker.com/linux/centos/docker-ce.repo$ yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -r * updates: mirrors.tuna.tsinghua.edu.cnLoading mirror speeds from cached hostfileLoaded plugins: fastestmirror, langpacksInstalled Packages * extras: mirrors.tuna.tsinghua.edu.cn * epel: mirrors.yun-idc.comdocker-ce.x86_64            <span class="token number">3</span>:19.03.1-3.el7                     docker-ce-stabledocker-ce.x86_64            <span class="token number">3</span>:19.03.0-3.el7                     docker-ce-stabledocker-ce.x86_64            <span class="token number">3</span>:18.09.8-3.el7                     docker-ce-stable<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>docker-ce.x86_64            <span class="token number">18.03</span>.1.ce-1.el7.centos             docker-ce-stabledocker-ce.x86_64            <span class="token number">18.03</span>.0.ce-1.el7.centos             docker-ce-stable<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span> * base: mirror.lzu.edu.cnAvailable Packages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以选择安装一个版本，比如这里使用<code>18.09.9</code>版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> docker-ce-18.09.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置 Docker 镜像加速器，这一步在阿里云的<code>容器镜像服务</code> –&gt; <code>镜像加速器</code>中有具体代码，每个人的不一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'&#123;  "exec-opts": ["native.cgroupdriver=systemd"], # 额外加的  "registry-mirrors": ["https://xxxxxxx.mirror.aliyuncs.com"]&#125;EOF</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，这里有个坑。由于默认情况下 kubelet 使用的 cgroupdriver 是 <code>systemd</code>，而docker默认使用的cgroupdriver是<code>cgroupfs</code>，不一样。这里需要保持二者的cgroupdriver一致，为了避免更改kublet的cgroupdriver，我们将docker的cgroupdriver更改为<code>systemd</code>。这就是为什么上述代码要额外加一行。</p><p>Docker设置开机自启：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>  <span class="token comment"># 开机自启</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在确保 Docker 安装完成后，上面的相关环境配置也完成了，现在我们就可以来安装 Kubeadm 了，我们这里是通过指定yum 源的方式来进行安装的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然了，上面的 yum 源是需要科学上网的，如果不能科学上网的话，我们可以使用阿里云的源进行安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后安装 kubeadm、kubelet、kubectl：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># --disableexcludes 禁掉除了kubernetes之外的别的仓库</span>$ yum <span class="token function">install</span> -y kubelet-1.16.2 kubeadm-1.16.2 kubectl-1.16.2 --disableexcludes<span class="token operator">=</span>kubernetes$ kubeadm versionkubeadm version: <span class="token operator">&amp;</span>version.Info<span class="token punctuation">&#123;</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"16"</span>, GitVersion:<span class="token string">"v1.16.2"</span>, GitCommit:<span class="token string">"c97fe5036ef3df2967d086711e6c0c405941e14b"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2019-10-15T19:15:39Z"</span>, GoVersion:<span class="token string">"go1.12.10"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"linux/amd64"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到我们这里安装的是 v1.16.2 版本，然后将 kubelet 设置成开机启动：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl <span class="token builtin class-name">enable</span> --now kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到目前为止，上述全部操作在所有节点都要进行。</p><hr><h2 id="初始化master"><a href="#初始化master" class="headerlink" title="初始化master"></a>初始化master</h2><p>该节点只需master节点做，从节点要跳过。首先，在master 节点配置 kubeadm 初始化文件，可以通过如下命令导出默认的初始化配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubeadm config print init-defaults <span class="token operator">></span> kubeadm.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后根据我们自己的需求修改配置，比如修改 imageRepository 的值，kube-proxy 的模式为 ipvs，另外需要注意的是我们这里是准备安装 flannel 网络插件的，需要将 networking.podSubnet 设置为<code>10.244.0.0/16</code>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kubeadm.k8s.io/v1beta2<span class="token key atrule">bootstrapTokens</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">groups</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> system<span class="token punctuation">:</span>bootstrappers<span class="token punctuation">:</span>kubeadm<span class="token punctuation">:</span>default<span class="token punctuation">-</span>node<span class="token punctuation">-</span>token  <span class="token key atrule">token</span><span class="token punctuation">:</span> abcdef.0123456789abcdef  <span class="token key atrule">ttl</span><span class="token punctuation">:</span> 24h0m0s  <span class="token key atrule">usages</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> signing  <span class="token punctuation">-</span> authentication<span class="token key atrule">kind</span><span class="token punctuation">:</span> InitConfiguration<span class="token key atrule">localAPIEndpoint</span><span class="token punctuation">:</span>  <span class="token key atrule">advertiseAddress</span><span class="token punctuation">:</span> 192.168.186.147  <span class="token comment"># apiserver 节点内网IP</span>  <span class="token key atrule">bindPort</span><span class="token punctuation">:</span> <span class="token number">6443</span><span class="token key atrule">nodeRegistration</span><span class="token punctuation">:</span>  <span class="token key atrule">criSocket</span><span class="token punctuation">:</span> /var/run/dockershim.sock  <span class="token key atrule">name</span><span class="token punctuation">:</span> master  <span class="token comment"># 默认读取当前节点的hostname</span>  <span class="token key atrule">taints</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule    <span class="token key atrule">key</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>role.kubernetes.io/master<span class="token punctuation">---</span><span class="token key atrule">apiServer</span><span class="token punctuation">:</span>  <span class="token key atrule">timeoutForControlPlane</span><span class="token punctuation">:</span> 4m0s<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kubeadm.k8s.io/v1beta2<span class="token key atrule">certificatesDir</span><span class="token punctuation">:</span> /etc/kubernetes/pki<span class="token key atrule">clusterName</span><span class="token punctuation">:</span> kubernetes<span class="token key atrule">controllerManager</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token key atrule">dns</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> CoreDNS<span class="token key atrule">etcd</span><span class="token punctuation">:</span>  <span class="token key atrule">local</span><span class="token punctuation">:</span>    <span class="token key atrule">dataDir</span><span class="token punctuation">:</span> /var/lib/etcd<span class="token key atrule">imageRepository</span><span class="token punctuation">:</span> registry.aliyuncs.com/google_containers  <span class="token comment"># 修改成阿里云镜像源</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterConfiguration<span class="token key atrule">kubernetesVersion</span><span class="token punctuation">:</span> v1.16.2  <span class="token comment"># 版本一定要写对，不然会是坑</span><span class="token key atrule">networking</span><span class="token punctuation">:</span>  <span class="token key atrule">dnsDomain</span><span class="token punctuation">:</span> cluster.local  <span class="token key atrule">podSubnet</span><span class="token punctuation">:</span> 10.244.0.0/16  <span class="token comment"># Pod 网段，flannel插件需要使用这个网段</span>  <span class="token key atrule">serviceSubnet</span><span class="token punctuation">:</span> 10.96.0.0/12<span class="token key atrule">scheduler</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kubeproxy.config.k8s.io/v1alpha1<span class="token key atrule">kind</span><span class="token punctuation">:</span> KubeProxyConfiguration<span class="token key atrule">mode</span><span class="token punctuation">:</span> ipvs  <span class="token comment"># kube-proxy 模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对于上面的资源清单的文档比较杂，要想完整了解上面的资源对象对应的属性，可以查看对应的 godoc 文档，地址:</p><p><a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p></blockquote><p>然后使用上面的配置文件进行初始化：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubeadm init --config kubeadm.yaml<span class="token punctuation">[</span>init<span class="token punctuation">]</span> Using Kubernetes version: v1.16.2<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> Running pre-flight checks<span class="token punctuation">[</span>WARNING SystemVerification<span class="token punctuation">]</span>: this Docker version is not on the list of validated versions: <span class="token number">20.10</span>.12. Latest validated version: <span class="token number">18.09</span><span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> Pulling images required <span class="token keyword">for</span> setting up a Kubernetes cluster<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> This might take a minute or two, depending on the speed of your internet connection<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> You can also perform this action <span class="token keyword">in</span> beforehand using <span class="token string">'kubeadm config images pull'</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Writing kubelet environment <span class="token function">file</span> with flags to <span class="token function">file</span> <span class="token string">"/var/lib/kubelet/kubeadm-flags.env"</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Writing kubelet configuration to <span class="token function">file</span> <span class="token string">"/var/lib/kubelet/config.yaml"</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Activating the kubelet <span class="token function">service</span><span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Using certificateDir folder <span class="token string">"/etc/kubernetes/pki"</span><span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"ca"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"apiserver"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> apiserver serving cert is signed <span class="token keyword">for</span> DNS names <span class="token punctuation">[</span>master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local<span class="token punctuation">]</span> and IPs <span class="token punctuation">[</span><span class="token number">10.96</span>.0.1 <span class="token number">192.168</span>.186.147<span class="token punctuation">]</span><span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"apiserver-kubelet-client"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"front-proxy-ca"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"front-proxy-client"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/ca"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/server"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> etcd/server serving cert is signed <span class="token keyword">for</span> DNS names <span class="token punctuation">[</span>master localhost<span class="token punctuation">]</span> and IPs <span class="token punctuation">[</span><span class="token number">192.168</span>.186.147 <span class="token number">127.0</span>.0.1 ::1<span class="token punctuation">]</span><span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/peer"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> etcd/peer serving cert is signed <span class="token keyword">for</span> DNS names <span class="token punctuation">[</span>master localhost<span class="token punctuation">]</span> and IPs <span class="token punctuation">[</span><span class="token number">192.168</span>.186.147 <span class="token number">127.0</span>.0.1 ::1<span class="token punctuation">]</span><span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/healthcheck-client"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"apiserver-etcd-client"</span> certificate and key<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"sa"</span> key and public key<span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Using kubeconfig folder <span class="token string">"/etc/kubernetes"</span><span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"admin.conf"</span> kubeconfig <span class="token function">file</span><span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"kubelet.conf"</span> kubeconfig <span class="token function">file</span><span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"controller-manager.conf"</span> kubeconfig <span class="token function">file</span><span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"scheduler.conf"</span> kubeconfig <span class="token function">file</span><span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Using manifest folder <span class="token string">"/etc/kubernetes/manifests"</span><span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token string">"kube-apiserver"</span><span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token string">"kube-controller-manager"</span><span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token string">"kube-scheduler"</span><span class="token punctuation">[</span>etcd<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token builtin class-name">local</span> etcd <span class="token keyword">in</span> <span class="token string">"/etc/kubernetes/manifests"</span><span class="token punctuation">[</span>wait-control-plane<span class="token punctuation">]</span> Waiting <span class="token keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="token string">"/etc/kubernetes/manifests"</span><span class="token builtin class-name">.</span> This can take up to 4m0s<span class="token punctuation">[</span>apiclient<span class="token punctuation">]</span> All control plane components are healthy after <span class="token number">14.001969</span> seconds<span class="token punctuation">[</span>upload-config<span class="token punctuation">]</span> Storing the configuration used <span class="token keyword">in</span> ConfigMap <span class="token string">"kubeadm-config"</span> <span class="token keyword">in</span> the <span class="token string">"kube-system"</span> Namespace<span class="token punctuation">[</span>kubelet<span class="token punctuation">]</span> Creating a ConfigMap <span class="token string">"kubelet-config-1.16"</span> <span class="token keyword">in</span> namespace kube-system with the configuration <span class="token keyword">for</span> the kubelets <span class="token keyword">in</span> the cluster<span class="token punctuation">[</span>upload-certs<span class="token punctuation">]</span> Skipping phase. Please see --upload-certs<span class="token punctuation">[</span>mark-control-plane<span class="token punctuation">]</span> Marking the <span class="token function">node</span> master as control-plane by adding the label <span class="token string">"node-role.kubernetes.io/master=''"</span><span class="token punctuation">[</span>mark-control-plane<span class="token punctuation">]</span> Marking the <span class="token function">node</span> master as control-plane by adding the taints <span class="token punctuation">[</span>node-role.kubernetes.io/master:NoSchedule<span class="token punctuation">]</span><span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Using token: abcdef.0123456789abcdef<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="token keyword">in</span> order <span class="token keyword">for</span> nodes to get long term certificate credentials<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> configured RBAC rules to allow certificate rotation <span class="token keyword">for</span> all <span class="token function">node</span> client certificates <span class="token keyword">in</span> the cluster<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Creating the <span class="token string">"cluster-info"</span> ConfigMap <span class="token keyword">in</span> the <span class="token string">"kube-public"</span> namespace<span class="token punctuation">[</span>addons<span class="token punctuation">]</span> Applied essential addon: CoreDNS<span class="token punctuation">[</span>addons<span class="token punctuation">]</span> Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully<span class="token operator">!</span>To start using your cluster, you need to run the following as a regular user:  <span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/.kube  <span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config  <span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/configYou should now deploy a pod network to the cluster.Run <span class="token string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.186.147:6443 --token abcdef.0123456789abcdef <span class="token punctuation">\</span>    --discovery-token-ca-cert-hash sha256:8db87a6d2a260bcb89b9df0e98072173578c34c160493c6915917143763a97e4 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，如果之前没有更改过docker的cgroupdriver，这里会报一个Warning：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>WARNING IsDockerSystemdCheck<span class="token punctuation">]</span>: detected <span class="token string">"cgroupfs"</span> as the Docker cgroup driver. The recommended driver is <span class="token string">"systemd"</span><span class="token builtin class-name">.</span> Please follow the guide at https://kubernetes.io/docs/setup/cri/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着，按照提示，依次执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/.kube$ <span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config$ <span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，<code>kubeadm init</code>输出结果的最后一部分<code>kubeadm join &lt;flags&gt;</code>非常重要，如果从节点想要加入该master的集群，就需要敲入该命令。如果一不小心忘记了该命令，也没关系，可以使用下述命令重现：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubeadm token create --print-join-command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>kubeadm init</code>的执行流程如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/8769f00a20eb55a8.png"></p><hr><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>该阶段只需在从节点中进行。直接复制master节点给出的<code>kubeadm join ...</code>在终端执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 sakura<span class="token punctuation">]</span><span class="token comment"># kubeadm join 192.168.186.147:6443 --token abcdef.0123456789abcdef \</span><span class="token operator">></span>     --discovery-token-ca-cert-hash sha256:8db87a6d2a260bcb89b9df0e98072173578c34c160493c6915917143763a97e4 <span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> Running pre-flight checks<span class="token punctuation">[</span>WARNING SystemVerification<span class="token punctuation">]</span>: this Docker version is not on the list of validated versions: <span class="token number">20.10</span>.12. Latest validated version: <span class="token number">18.09</span><span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> Reading configuration from the cluster<span class="token punctuation">..</span>.<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> FYI: You can <span class="token function">look</span> at this config <span class="token function">file</span> with <span class="token string">'kubectl -n kube-system get cm kubeadm-config -oyaml'</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Downloading configuration <span class="token keyword">for</span> the kubelet from the <span class="token string">"kubelet-config-1.16"</span> ConfigMap <span class="token keyword">in</span> the kube-system namespace<span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Writing kubelet configuration to <span class="token function">file</span> <span class="token string">"/var/lib/kubelet/config.yaml"</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Writing kubelet environment <span class="token function">file</span> with flags to <span class="token function">file</span> <span class="token string">"/var/lib/kubelet/kubeadm-flags.env"</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Activating the kubelet <span class="token function">service</span><span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Waiting <span class="token keyword">for</span> the kubelet to perform the TLS Bootstrap<span class="token punctuation">..</span>.This <span class="token function">node</span> has joined the cluster:* Certificate signing request was sent to apiserver and a response was received.* The Kubelet was informed of the new secure connection details.Run <span class="token string">'kubectl get nodes'</span> on the control-plane to see this <span class="token function">node</span> <span class="token function">join</span> the cluster.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>kubeadm join</code>命令的执行流程：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/c1e651a5b466bc39.png"></p><p>出现上述结果就说明节点已经加入集群成功，使用<code>kubectl get nodes</code>就可以看到所在集群的全部节点信息，但此时执行该命令会报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 k8s<span class="token punctuation">]</span><span class="token comment"># kubectl get nodes</span>Unable to connect to the server: x509: certificate signed by unknown authority <span class="token punctuation">(</span>possibly because of <span class="token string">"crypto/rsa: verification error"</span> <span class="token keyword">while</span> trying to verify candidate authority certificate <span class="token string">"kubernetes"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们需要将master节点中<code>$HOME/.kube/config </code>的内容拷贝进当前节点的<code>$HOME/.kube/config</code>中，上述命令才得以执行成功：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 k8s<span class="token punctuation">]</span><span class="token comment"># kubectl get nodes</span>NAME     STATUS     ROLES    AGE   VERSIONmaster   NotReady   master   30m   v1.16.2node2    NotReady   <span class="token operator">&lt;</span>none<span class="token operator">></span>   28m   v1.16.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用同样的方式加入其他从节点即可</p><hr><h2 id="网络插件"><a href="#网络插件" class="headerlink" title="网络插件"></a>网络插件</h2><p>该阶段配置的整个集群的网络插件，所以在集群内的任何一个节点进行即可。</p><p>在上一步中可以看到，节点都是NotReady状态，这是因为还没有安装网络插件，在k8s官网中是这样描述网络插件的重要性的：</p><blockquote><p>你必须部署一个基于 Pod 网络插件的 容器网络接口(CNI)，以便你的 Pod 可以相互通信。 在安装网络之前，**集群 DNS (CoreDNS) **将不会启动。</p></blockquote><p>接下来安装网络插件，可以在文档：<a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model">k8s网络插件</a> 中选择我们要用的网络插件，这里使用的是<code>flannel</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wget</span> https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml<span class="token comment"># 因为有节点是多网卡，所以需要在资源清单文件中指定内网网卡</span><span class="token comment"># 搜索到名为 kube-flannel-ds-amd64 的 DaemonSet，在kube-flannel容器下面</span>$ <span class="token function">vi</span> kube-flannel.yml<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>containers:- name: kube-flannel  image: quay.io/coreos/flannel:v0.11.0-amd64  command:  - /opt/bin/flanneld  args:  - --ip-masq  - --kube-subnet-mgr  - --iface<span class="token operator">=</span>ens33  <span class="token comment"># 如果是多网卡的话，指定内网网卡的名称</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>$ kubectl apply -f kube-flannel.yml  <span class="token comment"># 安装 flannel 网络插件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隔一会儿查看 Pod 运行状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 k8s<span class="token punctuation">]</span><span class="token comment"># kubectl get pods -n kube-system</span>NAME                             READY   STATUS    RESTARTS   AGEcoredns-58cc8c89f4-9qb66         <span class="token number">1</span>/1     Running   <span class="token number">0</span>          75mcoredns-58cc8c89f4-zmdk7         <span class="token number">1</span>/1     Running   <span class="token number">0</span>          75metcd-master                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          74mkube-apiserver-master            <span class="token number">1</span>/1     Running   <span class="token number">0</span>          74mkube-controller-manager-master   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          74mkube-flannel-ds-amd64-654x9      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          72skube-flannel-ds-amd64-p6dsg      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          72skube-proxy-26225                 <span class="token number">1</span>/1     Running   <span class="token number">0</span>          75mkube-proxy-vwtbd                 <span class="token number">1</span>/1     Running   <span class="token number">0</span>          73mkube-scheduler-master            <span class="token number">1</span>/1     Running   <span class="token number">0</span>          74m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们部署完网络插件后执行 ifconfig 命令，正常会看到新增的<code>cni0</code>与<code>flannel1</code>这两个虚拟设备，但是如果没有看到<code>cni0</code>这个设备也不用太担心，我们可以观察<code>/var/lib/cni</code>目录是否存在，如果不存在并不是说部署有问题，而是该节点上暂时还没有应用运行，我们只需要在该节点上运行一个 Pod 就可以看到该目录会被创建，并且<code>cni0</code>设备也会被创建出来。</p><p>网络插件运行成功了，node 状态也正常了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@node2 k8s<span class="token punctuation">]</span><span class="token comment"># kubectl get nodes</span>NAME     STATUS   ROLES    AGE   VERSIONmaster   Ready    master   76m   v1.16.2node2    Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   74m   v1.16.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>至于为什么说这个配置在一个节点运行，可以看下flannel的yaml文件中有这么一行：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">...</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DeaomSet也是一个k8s对象，它保证在<strong>每个Node</strong>上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。典型的应用包括：</p><ul><li>日志收集，比如fluentd，logstash等</li><li>系统监控，比如Prometheus Node Exporter，collectd，New Relic agent，Ganglia gmond等</li><li>系统程序，比如kube-proxy, kube-dns, glusterd, ceph等</li></ul><h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>Dashboard 是基于网页的 Kubernetes 管理界面，你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment，Job，DaemonSet 等等）。例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用等。在集群中的任何一个节点运行即可。</p><p>v1.16.2 版本的集群需要安装最新的 2.0+ 版本的 Dashboard，首先下载下来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wget</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Dashboard的默认Service是ClusterIP类型（只有集群内部能访问），这里要改为NodePort类型，使集群外部可以访问。修改<code>recommended.yaml</code>中的Service部分，加一行代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> recommended.yaml<span class="token comment"># 修改Service为NodePort类型</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  ports:    - port: <span class="token number">443</span>      targetPort: <span class="token number">8443</span>  selector:    k8s-app: kubernetes-dashboard  type: NodePort  <span class="token comment"># 加上type=NodePort变成NodePort类型的服务</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接应用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl apply -f recommended.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Dashboard会默认安装在<code>kubernetes-dashboard</code>这个命名空间下，查看全部服务状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl get all -n kubernetes-dashboardNAME                                             READY   STATUS    RESTARTS   AGEpod/dashboard-metrics-scraper-76585494d8-hznl6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          8m21spod/kubernetes-dashboard-6b86b44f87-slgtm        <span class="token number">1</span>/1     Running   <span class="token number">0</span>          8m21sNAME                                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>         AGEservice/dashboard-metrics-scraper   ClusterIP   <span class="token number">10.105</span>.26.186   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">8000</span>/TCP        8m21sservice/kubernetes-dashboard        NodePort    <span class="token number">10.102</span>.177.14   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>:30454/TCP   8m21sNAME                                        READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/dashboard-metrics-scraper   <span class="token number">1</span>/1     <span class="token number">1</span>            <span class="token number">1</span>           8m21sdeployment.apps/kubernetes-dashboard        <span class="token number">1</span>/1     <span class="token number">1</span>            <span class="token number">1</span>           8m21sNAME                                                   DESIRED   CURRENT   READY   AGEreplicaset.apps/dashboard-metrics-scraper-76585494d8   <span class="token number">1</span>         <span class="token number">1</span>         <span class="token number">1</span>       8m21sreplicaset.apps/kubernetes-dashboard-6b86b44f87        <span class="token number">1</span>         <span class="token number">1</span>         <span class="token number">1</span>       8m21s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>service</code>部分可以看到，dashboard映射到30454端口。使用<code>任意一个节点的IP:30454</code>即可进入dashborad，注意要用https，不能用http。这里用主节点IP：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/65306290a2f4ae76.png"></p><p>选择Token来进入，但是现在没有Token，因此需要先创建一个用户。这里创建一个具有全局所有权限的用户来登录dashboard。新建文件<code>admin.yml</code>，写入下述内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">rbac.authorization.kubernetes.io/autoupdate</span><span class="token punctuation">:</span> <span class="token string">"true"</span><span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后值即apply上述yaml文件，创建用户admin：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl apply -f admin.yamlclusterrolebinding.rbac.authorization.k8s.io/admin createdserviceaccount/admin created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着，获取该用户的Token，是一个很长的base64解码后的字符串：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubectl get secret -n kubernetes-dashboard<span class="token operator">|</span><span class="token function">grep</span> admin-tokenadmin-token-ctmrh                  kubernetes.io/service-account-token   <span class="token number">3</span>      26s$ kubectl get secret admin-token-ctmrh -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>.data.token<span class="token punctuation">&#125;</span> -n kubernetes-dashboard <span class="token operator">|</span>base64 -d  <span class="token comment">#会生成一个很长的字符串，即Token</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>copy下上述Token就行了：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/84dae40830ba58a8.png"></p><p>至此，我们完成了使用 kubeadm 搭建 v1.16.2 版本的 kubernetes 集群、coredns、ipvs、flannel、dashboard。</p><hr><h2 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h2><p>如果你的集群安装过程中遇到了其他问题，我们可以使用下面的命令来进行重置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kubeadm reset$ <span class="token function">ifconfig</span> cni0 down <span class="token operator">&amp;&amp;</span> <span class="token function">ip</span> <span class="token function">link</span> delete cni0$ <span class="token function">ifconfig</span> flannel.1 down <span class="token operator">&amp;&amp;</span> <span class="token function">ip</span> <span class="token function">link</span> delete flannel.1$ <span class="token function">rm</span> -rf /var/lib/cni/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，第2、3步非常重要，要删除cni0和flannel.1虚拟网卡。以cni0为例，之前说过，新加入的节点会在刚建立第一个Pod时建立一个cni0网卡，并在Pod网段中给它分配IP。</p><p>如果之前的cni0没有删除，很不幸，这个node并不会覆盖之前的cni0或者直接使用它，而是会一直尝试用新的ip创建一个cni0并会一直失败，导致这个node上的Pod根本无法建立，<code>describe</code>可以看到Pod创建错误如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/e8e6d81e44ab5e5b.png"></p>]]></content>
      
      
      <categories>
          
          <category> k8s上层与应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特权级与TSS</title>
      <link href="/te-quan-ji-yu-tss/"/>
      <url>/te-quan-ji-yu-tss/</url>
      
        <content type="html"><![CDATA[<p>整个计算机世界其实可以分为两个部分，<code>访问者</code>和<code>受访者</code>。访问者是动态的，具有能动性，它主动去访问各种资源。受访者是静态的，它就是被访问的资源，只能干坐着等待访问者光顾。访问者的特权级<code>可变</code>，受访者的特权级<code>不可变</code>。</p><span id="more"></span><p>CPU即是大脑，又是守卫，它负责维护计算机内的安全，将程序分为四个特权级，从高到低依次为<code>0,1,2,3</code>级，数字越小，特权越大。0特权级是<code>OS内核</code>所在的特权级，PC在启动之处就以0级运行，当MBR从BIOS那接完棒后，就像神一样处于最高特权级。</p><img src="https://i.bmp.ovh/imgs/2022/02/10468c6c38f2834f.png" style="zoom:50%;" /><p>OS位于最内环的0级特权，它要直接控制硬件，掌控各种核心数据，权力最大。系统程序分别为于1级和2级，运行在这两层的一般是<code>虚拟机</code>、<code>驱动程序</code>等系统服务。在最外层的是3级特权级，我们的用户程序就运行在此层，它不需要太大的能力，权力最弱。当用户程序需要完成更深层的功能时，应当进行特权级跨越，进入系统服务层或OS内核来执行。</p><h2 id="TSS简介"><a href="#TSS简介" class="headerlink" title="TSS简介"></a>TSS简介</h2><p>TSS，即<code>Task State Segment</code>，意为任务状态段，和特权级有着密不可分的联系。TSS是处理器在<code>硬件层面</code>上原生支持<code>多任务</code>的一种数据结构，也就是说，CPU在硬件上就已经为OS提供了完成多任务的一种解决方法（不过后来OS并不买账）。</p><p>就像每个任务都有自己的<code>LDT</code>一样，任何一个任务都有独自的<code>TSS</code>，它用于标识一个任务并存储相关信息，相当于身份证，任务拥有此结构才能运行。注意，TSS是处理器硬件上用于任务管理的系统结构，处理器能够<code>自动</code>识别其中每一个字段代表什么，因此开发者只需按意义指定每个字段的值即可，其结构为：</p><img src = 'https://i.bmp.ovh/imgs/2022/02/72036687bde47a0d.png' style="zoom:67%;" /><p>这个结构看上去很复杂，一共26个字段，104字节。实际上，104字节只是TSS的最小尺寸，按照需要还可以再接上个IO位图，不过这些现在不考虑。这里简单介绍一下第28字节及以上的一些字段：</p><p>这些字段都是CPU运行任务时要给响应寄存器设置的值，比如EAX=0100h，就会把eax寄存器设为eax。<code>cr3</code>字段即cr3寄存器，指向该任务所用的<code>页目录</code>基址。<code>ESP</code>为该任务的堆栈段的栈顶指针，即该任务的LDT中的堆栈段的栈顶地址。<code>CS</code>为该任务的代码段，即LDT中代码段的<code>选择子</code>、<code>SS</code>为该任务的堆栈段，即LDT中堆栈段的<code>选择子</code>。顾名思义，<code>LDT</code>就是该任务的LDT<code>选择子</code>。EFLAGS寄存器的第9位<code>IF</code>指是否允许外部中断，置位是允许，所以将EFLAGS设为0200h才允许外部中断。这里给出一个简单的任务TSS示例：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[SECTION .TSSB]ALIGN32[BITS32]LABEL_TSSB:DD0; BackDDTopOfStackB; 0 级堆栈DDSelectorStackB; DD0; 1 级堆栈DD0; DD0; 2 级堆栈DD0; DDPageDirBase1; CR3DD0; EIPDD0; EFLAGSDD0; EAXDD0; ECXDD0; EDXDD0; EBXDDTopOfStackLDTB; ESPDD0; EBPDD0; ESIDD0; EDIDD0; ESDDSelectorLDTBCodeB; CSDDSelectorLDTBStack; SSDD0; DSDD0; FSDD0; GSDDSelectorLDTB; LDTDW0; 调试陷阱标志DW$ - LABEL_TSSB + 2; I&#x2F;O位图基址DB0ffh; I&#x2F;O位图结束标志TSSBLenequ$ - LABEL_TSSB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而真正和特权级相关联的，是28字节一下的内容，即3个堆栈段选择子和3个栈偏移，这里着重介绍下这6个字段。</p><p>在没有操作系统的情况下，可以认为进程就是任务，任务就是一段在处理器上运行的程序，相当于某个计算机高手在能够脱离OS执行代码，直接控制硬件。但是有了OS之后，程序被分为了<code>用户程序</code>和<code>操作系统内核程序</code>，故，一个完整的任务也被分为<code>用户部分</code>和<code>内核部分</code>两部分。由于内核程序位于0特权级，用户程序位于3特权级，所以，一个任务按特权级来划分的话，实质上是被分成了3特权级的用户程序和0特权级的内核程序，这两部分加在一起才是能让处理器完整运行的程序，也就是说，<code>完整的任务要经历这两种特权级的变化</code>。所以，我们平时在Linux下所写的程序只是个<strong>半成品</strong>，咱们只负责完成用户态下的部分，内核的部分由操作系统提供。</p><p>任务是由处理器执行的，任务在特权级变换时，本质上是处理器的<code>当前特权级CPL</code>在变换，由一个特权级变成了另一个特权级，这就开始涉及栈的问题了。处理器固定，在不同的特权级下，应该用不同特权级的栈，原因是如果在同一个栈中容纳所有特权级的的数据时，这种交叉引用会使栈变得非常混乱。并且，用一个栈容纳多个特权级下的数据，栈容量有限，这很容易溢出。因此，一个任务在每个特权级下只能用该特权级的栈。</p><p>每个任务的每个特权级下只能有一个栈，也就是说，一共4个特权级，一个任务最多4个栈，那么为什么TSS中只有3对堆栈段选择子和栈偏移呢？要搞清楚这个问题，得先弄明白TSS中记录的3个栈是用来干什么的。</p><p>刚才说过，当处理器要进入不同的的特权级时，它自动在TSS中找到同特权级（目标特权级）的栈，由于TSS是硬件结构，所以处理器可以直接识别各字段的意义。</p><p>特权级转移分为两类：</p><p>1&gt; 由<code>中断门</code>、<code>调用门</code>等手段实现低特权级向高特权级转移；</p><p>2&gt; 由<code>调用返回指令</code>从高特权级返回到低特权级，这是<strong>唯一</strong>能够处理器降低特权级的情况；</p><p>对于第1种，当处理器要从低向高跳转时，会提前将目标栈记录在某个地方，当实行跳转时再从中取出来加载到<code>SS</code>和<code>ESP</code>中以转换栈，TSS中的3对栈字段就是那个用来存放的地方。由于除了返回指令，处理器只能<code>由低到高</code>跳转，所以TSS中所记录的栈是转移后的高特权级目标栈，所以它一定要比当前特权级要高。这样就明白了，TSS中不会记录第3特权级的栈，因为没有更低特权级向它转移。</p><p>对于第2种，由高特权级返回到低特权级，处理器已经不需要从TSS中找对应的目标栈了，因为此时要返回到的低特权级的地址其实已经被暂存起来了，这就是由转移指令（<code>int</code>、<code>call</code>）的机制来决定的，换句话说，处理器知道去哪里找低特权级的目标栈。</p><img src="https://i.bmp.ovh/imgs/2022/02/c95bebd5c32659c5.png" style="zoom:67%;" /><p>如上图所示，当处理器由低特权级向高特权级跳转时，会自动的当时低特权级的栈地址（<code>ss</code>和<code>esp</code>）压入了转移后的高特权级所在的栈中。当返回指令如<code>retf</code>或<code>iret</code>从高特权级向低特权级中返回时，处理器可以从当前使用的高特权级的栈中获取低特权级的栈段选择子以及偏移量。具体过程参考<code>call-ret</code>的机制。</p><p>那处理器是怎么找到TSS的呢？</p><p>TSS是硬件支持的数据结构，它和GDT等一样，由软件填写其内容，由硬件使用。GDT要加载到寄存器<code>GDTR</code>中才能处理器找到，TSS也一样，由<code>TR (Task Register)</code>寄存器加载的，每次处理器执行不同任务时，将TR寄存器加载不同任务的TSS就行了。</p>]]></content>
      
      
      <categories>
          
          <category> OS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断和异常</title>
      <link href="/zhong-duan-he-yi-chang/"/>
      <url>/zhong-duan-he-yi-chang/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nasm探测机器内存</title>
      <link href="/nasm-tan-ce-ji-qi-nei-cun/"/>
      <url>/nasm-tan-ce-ji-qi-nei-cun/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDT与描述符</title>
      <link href="/gdt-yu-miao-shu-fu/"/>
      <url>/gdt-yu-miao-shu-fu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实模式到保护模式</title>
      <link href="/shi-mo-shi-dao-bao-hu-mo-shi/"/>
      <url>/shi-mo-shi-dao-bao-hu-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>在不知道保护模式之前，让我们先看一段代码，如果没有接触过保护模式，会一头雾水，不过没关系，在这种好奇心的驱使下，会学的更高效。</p><span id="more"></span><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;; pmtest1.asm; 编译方法：nasm pmtest1.asm -o pmtest1.com; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%include&quot;pm.inc&quot;; 常量, 宏, 以及一些说明org07c00hjmpLABEL_BEGIN[SECTION .gdt]; GDT;                                         段基址,      段界限     , 属性LABEL_GDT:Descriptor       0,                0, 0     ; 空描述符LABEL_DESC_CODE32:Descriptor       0, SegCode32Len - 1, DA_C + DA_32; 非一致代码段, 32LABEL_DESC_VIDEO:Descriptor 0B8000h,           0ffffh, DA_DRW; 显存首地址; GDT 结束GdtLenequ$ - LABEL_GDT; GDT长度GdtPtrdwGdtLen - 1; GDT界限dd0; GDT基地址; GDT 选择子SelectorCode32equLABEL_DESC_CODE32- LABEL_GDTSelectorVideoequLABEL_DESC_VIDEO- LABEL_GDT; END of [SECTION .gdt][SECTION .s16][BITS16]LABEL_BEGIN:movax, csmovds, axmoves, axmovss, axmovsp, 0100h; 初始化 32 位代码段描述符; 旨在将LABEL_SEG_CODE32设为保护模式的基址xoreax, eaxmovax, csshleax, 4addeax, LABEL_SEG_CODE32movword [LABEL_DESC_CODE32 + 2], axshreax, 16movbyte [LABEL_DESC_CODE32 + 4], almovbyte [LABEL_DESC_CODE32 + 7], ah; 为加载 GDTR 作准备xoreax, eaxmovax, dsshleax, 4addeax, LABEL_GDT; eax &lt;- gdt 基地址movdword [GdtPtr + 2], eax; [GdtPtr + 2] &lt;- gdt 基地址; 加载 GDTRlgdt[GdtPtr] ; 将GdtPtr指示的6字节加载到寄存器gdtr,其中32为GDT基地址,16为GDT界限; 关中断cli; 打开地址线A20,即第20号地址位(从0开始)，超过了1MB，开机时默认关闭; 只有打开才能寻1MB以外的空间inal, 92horal, 00000010bout92h, al; 准备切换到保护模式; 将寄存器cr0的第0号位置设为1，相当于打开了保护模式的开关moveax, cr0oreax, 1movcr0, eax; 真正进入保护模式jmpdword SelectorCode32:0; 执行这一句会把 SelectorCode32 装入 cs, 并跳转到 Code32Selector:0  处; END of [SECTION .s16][SECTION .s32]; 32 位代码段. 由实模式跳入.[BITS32]LABEL_SEG_CODE32:movax, SelectorVideomovgs, ax; 视频段选择子(目的)movedi, (80 * 10 + 0) * 2; 屏幕第 10 行, 第 0 列。movah, 0Ch; 0000: 黑底    1100: 红字moval, &#39;P&#39;mov[gs:edi], ax; 到此停止jmp$SegCode32Lenequ$ - LABEL_SEG_CODE32; END of [SECTION .s32]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会将OS从实模式跳转到保护模式，然后在屏幕的第10行第0列输出黑底红字的P，让我们先运行下看看效果，这里使用的工具为：Ubuntu虚拟机 + NASM + Bochs + FreeDos。</p><p>最基础的，可以将上如代码编译为pmtest1.bin然后直接写入Boot Sector（引导扇区），这样做很方便，可以直接运行，不需要FreeDos。但是，有个很明显的缺点，就是空间有限，限制为512B，一旦代码量大了起来就不行了，所以不是长久之计。</p><p>解决上述问题有两个方法，一个是写一个Boot Sector，然后是它读取我们写的程序并运行，即引导我们写的OS内核，不过难度较大。第二个方法就是借助别的东西，比如DOS，我们把程序编译成<code>COM</code>文件，然后让DOS来执行它，这里，我们使用<code>FreeDos</code>来完成这个任务。</p><p>首先去Bochs官方下载一个FreeDos，主要用到其中的<code>a.img</code>。解压后，将a.img复制到工作目录，更名为<code>freedos.img</code>。</p><p>用<code>bximage</code>生成一个<code>软盘镜像</code>，起名为<code>pm.img</code>。</p><p>新建文件<code>bochsrc</code>，内容如下，重点为floppya、floppyb和boot：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">megs<span class="token punctuation">:</span><span class="token number">32</span>romimage<span class="token punctuation">:</span>file=$BXSHARE/BIOS<span class="token punctuation">-</span>bochs<span class="token punctuation">-</span>latestvgaromimage<span class="token punctuation">:</span>file=$BXSHARE/VGABIOS<span class="token punctuation">-</span>lgpl<span class="token punctuation">-</span>latestfloppya<span class="token punctuation">:</span>1_44=freedos.img<span class="token punctuation">,</span>status=insertedfloppyb<span class="token punctuation">:</span>1_44=pm.img<span class="token punctuation">,</span>status=inserted<span class="token comment">#软盘映射</span>boot<span class="token punctuation">:</span>a<span class="token comment">#硬盘</span><span class="token comment">#boot:disk</span><span class="token comment">#分配HD为60M，根据分配硬盘大小，cylinders, heads, spt会变化</span><span class="token comment">#ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><span class="token comment">#ata0-master: type=disk, mode=flat, path="boot.img", cylinders=121, heads=16, spt=63</span>log<span class="token punctuation">:</span>bochsout.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>bochs -f bochsrc</code>启动Bochs，待FreeDos启动完毕后格式化B盘：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/597d1f0674ed20d5.png"></p><p>这里说下为什么要用Ubuntu，因为Linux的挂载（<code>mount</code>）操作可以将宿主目录和Dos中的镜像关联起来，轻易实现将目标文件复制到Dos运行的镜像中。首先，编译出.COM文件，然后将其复制到虚拟软盘pm.img上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nasm pmtest1.asm -o pmtest1.com<span class="token function">sudo</span> <span class="token function">mount</span> -o loop pm.img /mnt/floppy<span class="token function">sudo</span> <span class="token function">cp</span> pmtest1.com /mnt/floppy/<span class="token function">sudo</span> <span class="token function">umount</span> /mnt/floppy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后到FreeDos中，执行命令：<code>B:\pmtest1.com</code>，就运行起来了，如图所示，显示一个红色的p。</p><p><img src="https://i.bmp.ovh/imgs/2022/02/e8e4882d1409b8c8.png"></p><p>好了，演示完毕，接下来开始介绍各部分代码的含义，由此了解保护模式，不过更重要的，是要先了解保护模式的一些历史。</p><h2 id="初始保护模式"><a href="#初始保护模式" class="headerlink" title="初始保护模式"></a>初始保护模式</h2><p>保护模式重在“保护”二字，顾名思义，其主要提供了安全上的服务，那它到底安全在哪？保护了什么？这个还在要从8086的16位寄存器时开始说起。</p><p>在Intel 8086中，CPU是16位的，它有着16位的寄存器、16位的数据总线以及20位的地址总线，共1MB的寻址空间，由于数据总线是少于地址总线的，所以物理地址是又<code>段:偏移</code>组成的，两者都是16位。</p><blockquote><p>物理地址 = 段基址*16 + 偏移</p></blockquote><p>上述模式就是我们后来所称的实模式，它的弊端是很大的：</p><p>1&gt;    操作系统和用户程序属于同一特权级，平起平坐，没有区别；</p><p>2&gt;    用户程序引用的地址直接为<code>物理地址</code>，即逻辑地址=物理地址，指哪打哪，没有限制很不安全；</p><p>3&gt;    用户程序可以自由设定段基址，在1MB空间中随意访问，不安全;</p><p>4&gt;    16位寄存器只能访问64KB，所以当访问的地址跨越64KB时，需要更改段基址，很麻烦;</p><p>5&gt;    一次只能运行一个程序，无法充分利用计算机资源;</p><p>6&gt;    最大的弊端，空间只有1MB，这在20年前就已经不够用了;</p><p>其中，(1)(2)(3)是安全方面的缺陷，没有安全可言的CPU是注定不可依赖的，它从本质上决定了程序乃至操作系统的数据有被随意删改的风险。(4)(5)是使用方面的缺陷，这个再20年前似乎还能忍受，但是随着计算需求的提升必会被淘汰。最硬伤的就是(6)，1MB完全不够用，因此急需更高的寻址空间。</p><p>从80286开始，Intel的CPU进入32位时代，32位CPU具有两种运行模式，分别为<code>实模式</code>和<code>保护模式</code>，可以兼容8086时代的16位运行环境。实际上，在8086时代，16位CPU根本没有实模式的概念！当时的人用的只有16位CPU，他们从没想过自己习惯的模式还要重新命名。直到CPU发展到了32位，新的运行模式和之前不大相同，但不管怎么发展，都一定要满足一个原则：<code>兼容</code>。</p><p>也就是说，32位CPU具有两种模式，一种是为了克服8086运行模式弊端的新模式，即它自己的运行模式；另一种就是为了兼容8086运行模式而存在的，实模式。为了凸显前者的优势，将其称为保护模式。再强调一遍：</p><blockquote><p>实模式是32CPU时才提出的概念，旨在兼容8086的16位运行模式</p></blockquote><p>实模式的运行环境为16位，保护模式为32位。但是要注意的是，当PC运行在实模式下时，CPU依然是32位，硬件本身不会变！相当于高中生去做初中生的题，当它处在16位的运行模式时，依然可以处理32位的操作数，因为它在硬件层面上是32位的。也即：</p><blockquote><p>实模式指32位CPU运行在16位模式下的状态，但CPU本身是32位的，依然可以处理32位操作数</p></blockquote><p>了解完其基础概念后，来看看保护模式究竟从哪些方面得到了进化。</p><h2 id="寄存器扩展"><a href="#寄存器扩展" class="headerlink" title="寄存器扩展"></a>寄存器扩展</h2><p>无论PC怎么发展，兼容都是最基本的要求，包括寄存器、访存方式、指令格式等的兼容。CPU发展到了32位后，地址总线和数据总线也发展到了32位，即寻址空间夸大到了4GB，一次可以处理的操作数升至32位。4GB的空间如果还用曾经的<code>段:偏移</code>法来寻址的话，段基址要左移16位，这显然很不合适。</p><p>最关键的，从设计思想上将，段基址本身就应该是某个内存段的起始地址，它不应该在应用前先做个处理。在原来的16位模式下，由于数据总线小于地址总线，所以迫不得已预先将段基址*16，才产生了这种蹩脚的方式。现在，数据总线和地址总线一样宽了，就可从根本上解决这个问题——扩展寄存器到32位。</p><p>寄存器要保持向下兼容，不能推翻之前的方案重来，因此要在原有16位的基础上向高位扩展16位，延申到32位，新的寄存器用前缀e表示扩展，即eax、ebx等等，如图：</p> <img src="https://i.bmp.ovh/imgs/2022/02/477588c3761f2737.png" style="zoom:80%;" /><p>可以看到，通用寄存器、标志寄存器、指令指针寄存器都扩展到了32位，但是段寄存器没有，仍然只有32位，这是因为段寄存器16位就够用了，这个后面会解释到。</p><p>上图中，寄存器的低16位是为了兼容实模式的，在任何模式下都可以<code>单独使用</code>，但是高16位不行，必须在引用32位寄存器时才能用到他们。</p><p>之前提到过，在80286之后，引入了保护模式的概念，大大提高了安全性，其中很重要的一部分，就是对内存段的描述。它改变了段基址的实质，引入了<code>GRT(Global Descriptor Table)</code>的概念。</p><h2 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h2><p>保护模式下，偏移地址和实模式是一样的，但是段基址不再是简单的一个地址了。之前说过，实模式下段基址可以任意设定，随意访问空间内的任何地方，很不安全。因此为了更加安全，要给它加一些约束条件，这些约束条件就是对内存段的描述信息。由于信息太多了，所以专门找了个数据结构——全局描述符表，即<code>GDT</code>。该表很大，故放在了内存中，由<code>GDTR</code>寄存器指向它的首址，这个寄存器有6字节。</p><p>既然是表，那一定有表项，每一个表项就是一个<code>段描述符</code>，大小为8字节，用来描述一个内存段的段基址、段界限和段属性等等。注意，表项就是描述符，而不是描述符的索引。不过这里不会详细介绍，只浅谈一下即可，后面会专门开一篇博客专门介绍GDT和描述符。</p><p><img src="https://i.bmp.ovh/imgs/2022/02/ccabd82c4185bc24.png"></p><p>这样，段寄存器中保存的再也不是段基址了，里面保存的内容叫<code>选择子</code>，selector。实际上，这个选择子就是个<code>数</code>，用这个数来<code>索引</code>GDT中的段描述符。把全局描述符当成数组，选择子就像数组下标一样。</p><blockquote><p>1&gt; 段描述符是在内存中的，访问会很耗时</p><p>2&gt; 段描述符的格式很奇怪，CPU把这些七零八落的数拼凑起来也会耗时</p></blockquote><p>既然访问内存中的段描述符很耗时间，那CPU如何提高效率呢？使用缓存。在80286的保护模式中，为了提高获取段信息的效率，对段寄存器率先应用了缓存技术，将段信息用一个寄存器来缓存，这就是<code>段描述符缓冲寄存器</code>。对程序员而言它是不可见的。CPU每次访问描述符并获取到内存段信息后，会将其存入上述缓冲寄存器中，下次访问相同段时，直接从中取就行了。</p><p>另外，虽然段描述符缓冲寄存器是保护模式下的产物，但是它也可以用在实模式下。在16为的实模式下，段基址左移4位这个操作也是耗时的。因此，CPU会将段基址左移后的结果存在上述寄存器中，以后每次引用这个段时，就直接走缓冲寄存器，直到换段，也就是段寄存器被重新赋值。</p><p>在进入代码解释之前按，先简单概括下描述符各属性的含义：</p><p><strong>P位</strong>：存在位，P=1表示段在内存中存在；P=0表示在内存中不存在。</p><p><strong>DPL</strong>：描述符特权级（Privilege Level），可以是0123，数字越小特权级越大。</p><p><strong>S位</strong>：指明描述符是数据段/代码段（S=1）还是系统段/门描述符（S=0）.</p><p><strong>TYPE</strong>：描述符类型，详情见下表：</p><img src="https://i.bmp.ovh/imgs/2022/02/331f5d92ee10678c.png" style="zoom: 67%;" /><p>其中，当S=1时，TYPE&lt;8对应数据段，&gt;=8对应代码段；当S=0时，TYPE&lt;8对应系统段，&gt;=8对应门描述符。</p><p><strong>G位</strong>：段界限粒度（Granularity）位。G=0时段界限为字节；G=1时段界限粒度为4KB。</p><p><strong>D/B位</strong>：这一位比较复杂，分三种情况：</p><ul><li>   在可执行代码段描述符中，这一位叫做D位。D=1时，在默认情况下指令使用32位地址以及32位或8位操作数；D=0时，在默认情况下使用16位地址以及16位或8位操作数；</li><li>   在向下扩展数据段的描述符中，这一位叫做B位。B=1时，段的上部界限为4GB；B=0时，段的上部界限为64KB；</li><li>   在描述堆栈段（由ss寄存器指向的段）的描述符中，这一位叫做B位。B=1时，隐式的堆栈访问指令（如push、pop和call）使用32位堆栈指针寄存器esp；D=0时，隐式的堆栈访问指令（如push、pop和call）使用16位堆栈指针寄存器sp；</li></ul><p><strong>AVL位</strong>：保留位：可以被系统软件使用。</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>好了，知道保护模式和GDT的相关基础后，可以开始通过解释文初的代码来进一步学习保护模式了。</p><p>代码一共分为三个部分，即三个段：[SECTION .gdt]、[SECTION .s16]、[SECTION .s32]。顾名思义，第一部分定义了GDT，第二部分为16位环境下运行的代码，即实模式，第三部分为32位环境下运行的代码，即保护模式。我们一个一个看。</p><h3 id="SECTION-gdt"><a href="#SECTION-gdt" class="headerlink" title="[SECTION .gdt]"></a>[SECTION .gdt]</h3><p>这个部分定义了一个数组，每一个元素都是一个<code>Descriptor</code>，很明显，这个数组就是<code>GDT</code>。其中，<code>Descriptor</code>是一个宏，这个宏用比较自动化的方法把段基址、段界限和段属性放入一个描述符中合适的位置，这个宏在pm.inc中，内容如下：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 描述符; usage: Descriptor Base, Limit, Attr;        Base:  dd;        Limit: dd (low 20 bits available);        Attr:  dw (lower 4 bits of higher byte are always 0)%macro Descriptor 3dw%2 &amp; 0FFFFh; 段界限 1(2 字节)dw%1 &amp; 0FFFFh; 段基址 1(2 字节)db(%1 &gt;&gt; 16) &amp; 0FFh; 段基址 2(1 字节)dw((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh); 属性 1 + 段界限 2 + 属性 2(2 字节)db(%1 &gt;&gt; 24) &amp; 0FFh; 段基址 3(1 字节)%endmacro ; 共 8 字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码的GDT中共有3个描述符，为方便起见，这里分别简称为DESC_DUMMY、DESC_CODE32和DESC_VIDEO。其中DESC_VIDEO的段基址是<code>0B800h</code>，这个地址是显存的起始地址，故该描述符指向了显存。</p><p>段基址和段界限都好说，来看下段属性。DESC_CODE32的属性为<code>DA_C + DA_32</code>，DESC_VIDEO的属性为<code>DA_DRW</code>。这些值都定义在pm.inc中：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">;---------------------------------------------------------------; 描述符类型值说明; 其中:;       DA_  : Descriptor Attribute;       D    : 数据段;       C    : 代码段;       S    : 系统段;       R    : 只读;       RW   : 读写;       A    : 已访问;       其它 : 可按照字面意思理解;---------------------------------------------------------------DA_32EQU4000h; 32 位段DA_DPL0EQU  00h; DPL &#x3D; 0DA_DPL1EQU  20h; DPL &#x3D; 1DA_DPL2EQU  40h; DPL &#x3D; 2DA_DPL3EQU  60h; DPL &#x3D; 3;---------------------------------------------------------------; 存储段描述符类型值说明;---------------------------------------------------------------DA_DREQU90h; 存在的只读数据段类型值DA_DRWEQU92h; 存在的可读写数据段属性值DA_DRWAEQU93h; 存在的已访问可读写数据段类型值DA_CEQU98h; 存在的只执行代码段属性值DA_CREQU9Ah; 存在的可执行可读代码段属性值DA_CCOEQU9Ch; 存在的只执行一致代码段属性值DA_CCOREQU9Eh; 存在的可执行可读一致代码段属性值;---------------------------------------------------------------; 系统段描述符类型值说明;---------------------------------------------------------------DA_LDTEQU  82h; 局部描述符表段类型值DA_TaskGateEQU  85h; 任务门类型值DA_386TSSEQU  89h; 可用 386 任务状态段类型值DA_386CGateEQU  8Ch; 386 调用门类型值DA_386IGateEQU  8Eh; 386 中断门类型值DA_386TGateEQU  8Fh; 386 陷阱门类型值;---------------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DA_C + DA_32的二进制为<code>0100 0000 1001 1000</code>，更具描述符TYPE的含义可知该内存段为<strong>存在的只执行的32位代码段，DPL为0</strong>。同理可知，DESC_VIDEO段为<strong>可读写数据段</strong>。</p><p>定义完GDT后，用变量<code>GdtLen</code>存储GDT的长度，结构变量<code>GdtPtr</code>存储GDT的长度和基地址。</p><p>随后，开始存储后两个描述符的<code>选择子</code>，可以看到，<code>SelectorCode32</code>和<code>SelectorVideo</code>分别存储了DESC_CODE32和DESC_VIDEO相对于GDT首址的偏移，这个数就是他们各自的选择子。实际上，选择子不止是一个偏移，它的结构要稍微复杂一些，这里不详细介绍。</p><p>数据结构<code>GdtPtr</code>是用来记录GDT界限和GDT基址的。前文提到过，<code>GDTR</code>寄存器要指向GDT的首址，先来看看这个寄存器的结构：</p><p><img src="https://i.bmp.ovh/imgs/2022/02/71d060da237efc08.png"></p><p>可以看到，这个寄存器和我们定义的<code>GdtPtr</code>结构是一样的，实际上，定义<code>GdtPtr</code>的目的就是将其赋值给<code>GDTR</code>。</p><h2 id="SECTION-s32"><a href="#SECTION-s32" class="headerlink" title="[SECTION .s32]"></a>[SECTION .s32]</h2><p>这个部分为保护模式下要执行的代码，目的很简单，在指定位置打印一个红色的P。首先，把显存的内存段也就是描述符DESC_VIDEO的<code>选择子</code>写入段寄存器<code>GS</code>:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movax, SelectorVideomovgs, ax; 视频段选择子(目的)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着，把想要显示的位置写入<code>edi</code>，然后通过<code>[gs:edi]</code>要显示的东西写入显存的对应位置中：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movedi, (80 * 10 + 0) * 2; 屏幕第 10 行, 第 0 列。movah, 0Ch; 0000: 黑底    1100: 红字moval, &#39;P&#39;mov[gs:edi], ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>保护模式运行的代码到此为止，使用一个死循环来停在此处即可。可以看到，这部分并不难。核心目的就是把字符写入显存对应的位置，不过由于保护模式用<code>描述符</code>来表示各个内存段，因此需要借助<code>GDT</code>来完成。</p><h2 id="SECTION-s16"><a href="#SECTION-s16" class="headerlink" title="[SECTION .s16]"></a>[SECTION .s16]</h2><p>我们知道，当PC启动时，首先进入的是实模式，只有1MB的寻址空间，要转入保护模式，就需要另做一些操作，比如打开某些开关，然后<code>jmp</code>到保护模式，[SECTION .s16]就是在实模式中做这些事的。</p><p>在将cs、ds、es、ss相统一之后，开始初始化保护模式代码段描述符。因为最后要跳到保护模式所在的内存段（代码段），因此需要一个描述符来存储它，就是<code>DESC_CODE32</code>，不过由于描述符结构比较蹩脚，所以得分步来赋值。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 初始化 32 位代码段描述符xoreax, eaxmovax, csshleax, 4addeax, LABEL_SEG_CODE32movword [LABEL_DESC_CODE32 + 2], axshreax, 16movbyte [LABEL_DESC_CODE32 + 4], almovbyte [LABEL_DESC_CODE32 + 7], ah<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化完该描述符后，开始加载GDT，即将GDT的首址和界限写入寄存器<code>GDTR</code>，期间要借助数据结构<code>GdtPtr</code>：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 为加载 GDTR 作准备xoreax, eaxmovax, dsshleax, 4addeax, LABEL_GDT; eax &lt;- gdt 基地址movdword [GdtPtr + 2], eax; [GdtPtr + 2] &lt;- gdt 基地址; 加载 GDTRlgdt[GdtPtr]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一行的<code>lgdt</code>的作用是将以GdtPtr为首址的6字节加载到寄存器<code>GDTR</code>中。</p><p>接下来就是关中断，因为保护模式下中断处理的机制是不同的，不关掉会出错误：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 关中断cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再下面几行的作用就是打开<code>A20</code>地址线，这里简单介绍下什么时候A20地址线。在8086中，地址线只有20位，空间为1MB，那么如果试图访问1MB之外的空间呢？系统并不会发生异常，而是<code>回卷</code>，重新从0地址开始。但是到了80286时，空间变成了4GB，访问1MB之外不再需要回卷了，这就造成了和旧模式的不兼容，怎么办呢？IBM想出一个办法，使用8042键盘控制器来控制第20号（从0开始）地址位，这就是<code>A20</code>地址线，如果不被打开，默认为0，地址会回卷。也即，<code>A20</code>是程序或OS能够访问到1MB之外的空间，可以认为是进入保护模式的第一步。代码通过操作端口92h来打开它：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 打开地址线A20inal, 92horal, 00000010bout92h, al<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，离最后的<code>jmp</code>就只差一步了，那就是打开保护模式的开关：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 准备切换到保护模式moveax, cr0oreax, 1movcr0, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码很简单，就是把<code>cr0</code>寄存器的第0位设1。寄存器<code>cr0</code>的第0位是PE位，此位为0时，CPU运行于实模式，为1时，CPU运行于保护模式。因此，这一步打开了进入保护模式的开关。</p><p>此时，系统已经进入了保护模式，但是<code>cs</code>仍然是实模式的值，即依然停留在实模式的代码处。因此，需要将其更改为保护模式的代码段，那就是<code>jmp</code>。通过之前定义的DESC_CODE32的选择子<code>SelectorCode32</code>，来执行保护模式处的代码：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 真正进入保护模式jmpdword SelectorCode32:0; 执行这一句会把 SelectorCode32 装入 cs, 并跳转到 Code32Selector:0  处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，成功进入了保护模式，下面总结一下进入保护模式的主要步骤：</p><p>1&gt;    准备GDT；</p><p>2&gt;    用lgdt加载gdtr；</p><p>3&gt;    打开A20；</p><p>4&gt;    置cr0的PE位，使系统处于保护模式；</p><p>5&gt;    跳转，进入保护模式；</p>]]></content>
      
      
      <categories>
          
          <category> OS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unicode和UTF-8</title>
      <link href="/unicode-he-utf-8/"/>
      <url>/unicode-he-utf-8/</url>
      
        <content type="html"><![CDATA[<p>都知道Unicode编码，但我经常把它和UTF-8弄混，都是囫囵吞枣式的理解，基础不扎实。今天突然想搞清楚它俩的前世今生缘，想着连这都不知道也太Low了，就去查了查资料，发现比我想象的要复杂。</p><span id="more"></span><h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><h2 id="非ASCII码"><a href="#非ASCII码" class="headerlink" title="非ASCII码"></a>非ASCII码</h2><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><h2 id="Unicode的问题"><a href="#Unicode的问题" class="headerlink" title="Unicode的问题"></a>Unicode的问题</h2><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><h2 id="Unicode与UTF-8之间的转换"><a href="#Unicode与UTF-8之间的转换" class="headerlink" title="Unicode与UTF-8之间的转换"></a>Unicode与UTF-8之间的转换</h2><h2 id="大端对齐和小端对齐"><a href="#大端对齐和小端对齐" class="headerlink" title="大端对齐和小端对齐"></a>大端对齐和小端对齐</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker进阶(一): DockerFile解析</title>
      <link href="/docker-jin-jie-yi-dockerfile-jie-xi/"/>
      <url>/docker-jin-jie-yi-dockerfile-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条<code>构建镜像</code>所需的指令和参数构成的脚本，类似于Linux的MakeFile。现在，假设我们需要构建一个包含vim/ifconfig的ubuntu镜像，我们需要<code>run</code>一个原始ubuntun镜像，然后在其中安装vim/ifconfig，最后通过<code>commit</code>来生成镜像。但是，如果需要多次安装，就要多次重复上述commit步骤，很麻烦。那么，能不能将需要安装的东西列一个清单，然后一次性搞定呢？==&gt; Dockerfile。</p><span id="more"></span><p>Dockerfile就像一个<code>图纸</code>，把镜像需要安装的东西全部写进去，然后<code>build</code>生成镜像时一口气直接装完。可以看到，<code>commit</code>是通过Container来生成镜像的，而Dockerfile则不需要操作者通过手动运行Container来对镜像进行增强。</p><p><img src="https://img-blog.csdnimg.cn/1e96f3b77c9f4c1ca483a90b4c6112f3.png" alt="img"></p><hr><h2 id="构建过程解析"><a href="#构建过程解析" class="headerlink" title="构建过程解析"></a>构建过程解析</h2><p>每条保留字指令都必须为<code>大写字母</code>，且后面要跟随至少一个参数，如COPY保留字：</p><p><img src="https://img-blog.csdnimg.cn/a2c7708eb2ee436c970c88f58160552a.png" alt="img"></p><p>指令按照从上到下，顺序执行，<strong>每条指令都会创建一个新的<code>镜像层</code>并对镜像进行提交</strong>，#表示注释。至于镜像层，简单来说，就是Docker镜像是一层层构成的，这样才能使我们可以在一个初始镜像的基础上生成新的镜像，具体分层概念将在下一篇博客中讲述。</p><p><strong>【Dockerfile执行流程】</strong></p><p>1&gt;  Docker从基础镜像运行一个Container。</p><p>2&gt;  顺序执行一条指令并对Container作出修改。</p><p>3&gt;  执行类似<code>commit</code>的操作来提交一个新的镜像层。</p><p>4&gt;  Docker再基于刚提交的镜像运行一个新的Container。</p><p>5&gt;  执行Dockerfile中的下一条指令直到所有指令都执行完成。</p><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表了软件的三个不同阶段：</p><blockquote><p>Dockerfile使软件的设计图纸</p><p>Docker镜像使软件的交付品</p><p>Docker容器则是软件镜像的运行态，也即运行实例</p></blockquote><p><img src="https://img-blog.csdnimg.cn/34fb7878c7cd40528ad9b6cc634c9ce4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU3JjTWlMZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>总的来说，Dockerfile定义了最终的容器进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道时，需要考虑如何设计namespace的权限控制）等等。</p><hr><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>参考tomcat8的Dockerfile入门：<a href="https://github.com/docker-library/tomcat%EF%BC%8C%E8%BF%99%E9%87%8C%E7%BD%97%E5%88%97%E4%BA%8612%E4%B8%AA%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E7%95%99%E5%AD%97%E3%80%82">https://github.com/docker-library/tomcat，这里罗列了12个最常用的保留字。</a></p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>基础镜像，说明当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，Dockerfile的第一条指令必须是FROM。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM [--platform&#x3D;&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]  # orFROM [--platform&#x3D;&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]  #orFROM [--platform&#x3D;&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>可以通过该保留字留下维护者的姓名和邮箱地址，非必须。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">MAINTAINER &lt;name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新版本中，官方建议用<code>LABEL</code>来替代它：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">LABEL org.opencontainers.image.authors&#x3D;&quot;SvenDowideit@home.org.au&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>容器构建镜像时需要运行的命令，有两种格式，<code>shell</code>格式和<code>exec</code>格式。注意，<code>RUN</code>是在<code>docker build</code>时运行的，那为什么会和容器有关呢？就像前文说的，dockerfile每一条指令实质上就是在前一步运行的新的Container上进行操作，然后通过类似<code>commit</code>的操作来构建新镜像，所以实际上是对容器的操作。两种格式分别为：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># shell 格式RUN &lt;命令行命令&gt;# &lt;命令行命令&gt;等同于，在容器终端操作的shell命令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># exec 格式RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;]# RUN [&quot;.&#x2F;test.php&quot;, &quot;dev&quot;, &quot;offline&quot;]等价于RUN .&#x2F;test.php dev offline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以shell格式为例，如果我们想要安装vim，那么在容器中就需要使用命令<code>yum -y install vim</code>，然后出容器使用<code>docker commit</code>来构建镜像。现在有了dockerfile，只需要在其中加一句<code>RUN yum -y install vim</code>即可，docker运行完该指令会自动commit。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>暴露出容器将要提供服务所开放的端口，严格来说，是用该dockerfile构建的镜像，运行出的容器提供的服务对外暴露的端口。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">EXPOSE &lt;端口1&gt;[&#x2F;传输格式] [&lt;端口2&gt;[&#x2F;传输格式]...]# EXPOSE 8080&#x2F;tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意，<code>EXPOSE</code>指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明就开启这个端口的服务。在Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射EXPOSE的端口。</p><p>要将<code>EXPOSE</code>和<code>docker run -p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开来。-p，是将宿主端口映射向容器端口，也就是说将容器端口向宿主机外暴漏。而EXPOSE，仅仅是声明<code>容器内</code>暴露的端口。</p><p>一般使用<code>docker run -p &lt;宿主端口&gt;:EXPOSE端口</code>来指定宿主机端口和该容器暴露端口的映射，或者使用<code>-P</code>来进行随机映射。这样一想，我们最终在外部直接访问的仍然是宿主机上的端口，<code>EXPOSE</code>只是在设置<code>-p/-P</code>时提醒操作者容器内服务的端口是多少，从而构成映射吗，是不是有些鸡肋？我个人觉得是的，它只是起到声明和提醒的作用。</p><p>但是，<code>EXPOSE</code>也有中有趣的玩法，那就是不使用端口映射，让端口直接暴露在宿主机外。怎么做？==&gt; host模式。在<code>docker run</code>时设置<code>--net=host</code>，这样一来容器就和宿主机公用同样的网络配置，包括端口。运行之后，使用<code>docker inspect containerID </code>发现没有任何端口映射信息，因为容器的端口直接就是宿主机的端口。</p><p><img src="https://img-blog.csdnimg.cn/ee6b3d3a19dd40fba1c422850a0e7c09.png" alt="img"></p><p>这样一来，就可以在使用EXPOSE端口来访问容器内的服务了，不再需要-p/-P映射。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定构建的镜像运行出容器后，终端默认的初始工作目录，也就是落脚点。比如，tomcat容器的落脚点为<code>/usr/local/tomcat</code>，它的dockerfile就这样写：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;tomcat# ...WORKDIR $CATALINA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>指定该镜像以什么样的用户去执行，如果都不指定，默认为<code>root</code></p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">USER &lt;user&gt;[:&lt;group&gt;] #orUSER &lt;UID&gt;[:&lt;GID&gt;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>用来在构建镜像过程中设置环境变量，注意，是<code>构建过程中</code>，不是构建后。这个环境变量可以在后续的任何<code>RUN</code>指令中使用，也可以在其他指令中直接使用，比如<code>WORKDIR</code>，引用时加<code>$</code>。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV NAME VALUE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>容器数据卷，不用多说，相当于<code>docker run -v ...</code>，用于数据保存和持久化工作。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM ubuntuRUN mkdir &#x2F;myvolRUN echo &quot;hello world&quot; &gt; &#x2F;myvol&#x2F;greetingVOLUME &#x2F;myvol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述指令会在容器的<code> /myvol</code>目录下设置一个挂载点，并在宿主机上创建一个数据卷和其相关联，由于没有指定宿主机目录，所以是默认的，类似于 <code>docker run -v /myvol 镜像名 </code>。可以使用<code>docker inspect 容器名/ID</code>来查看相关联的宿主机目录的路径，会发现数据卷名是一串编号：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;0ab0aaf0d6ef391cb68b72bd8c43216a8f8ae9205f0ae941ef16ebe32dc9fc01&#x2F;_data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，也可以同时创建多个挂载点，每个挂载点都有独立的数据卷：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">VOLUME [&quot;&#x2F;data1&quot;,&quot;&#x2F;data2&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"d411f6b8f17f4418629d4e5a1ab69679dee369b39e13bb68bed77aa4a0d12d21"</span><span class="token punctuation">,</span>            <span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/d411f6b8f17f4418629d4e5a1ab69679dee369b39e13bb68bed77aa4a0d12d21/_data"</span><span class="token punctuation">,</span>            <span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/data1"</span><span class="token punctuation">,</span>            <span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>            <span class="token property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>            <span class="token property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"6d3badcf47c4ac5955deda6f6ae56f4aaf1037a871275f46220c14ebd762fc36"</span><span class="token punctuation">,</span>            <span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/6d3badcf47c4ac5955deda6f6ae56f4aaf1037a871275f46220c14ebd762fc36/_data"</span><span class="token punctuation">,</span>            <span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/data2"</span><span class="token punctuation">,</span>            <span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>            <span class="token property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>            <span class="token property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>把宿主机目录下的文件和目录拷贝进镜像中，将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY src dest #orCOPY [&quot;src&quot;,&quot;dest&quot;]# &lt;src源路径&gt;：源文件或者源目录# &lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包，即<code>COPY</code>的升级版：COPY+解压，一般用这个就行。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>指定容器启动后要干的事情。注意，这个容器是运行最终镜像的容器，而不是构建镜像过程中的临时容器，也就是说，这个时候已经和镜像的构建无关了。</p><blockquote><p>RUN是在docker build时运行</p><p>CMD是在docker run时运行</p></blockquote><p><code>CMD</code>指令和<code>RUN</code>的格式相似，外加了一个参数列表格式：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># shell 格式CMD &lt;命令&gt;# exec 格式CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;...]# 参数列表格式，在指定了ENTRYPOINT后，用CMD指定具体参数CMD [&quot;参数1&quot;,&quot;参数2&quot;...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dockerfile中可以有多个CMD指令，但只有<code>最后一个</code>生效，并且，CMD会被<code>docker run</code>设定的运行命令替换。比如，tomcat的dockerfile的最后一行为：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即，运行tomcat容器后会在WORKDIR下执行命令<code>catalina.sh run </code>。但是，如果在<code>docker run</code>之后加入了<code>/bin/bash</code>，就会发现tomcat服务并没有启动，因为原本应该执行的<code>catalina.sh run</code>被自己写的<code>/bin/bash</code>覆盖了，因此只启动了容器，并没有启动服务。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>也是用来指定一个容器启动时要运行的命令，类似于<code>CMD</code>指令，但不同的是，<code>ENTRYPOINT</code>不会被<code>docker run </code>后面的命令覆盖，而且这些命令行参数会被当作参数送给<code>ENTRYPOINT</code>指令指定的程序。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># exec 格式ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# shell 格式ENTRYPOINT command param1 param2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>ENTRYPOINT</code>可以和<code>CMD</code>一起使用，一般是变参才会使用CMD，这里的CMD等于是在给ENTRYPOINT传参。当指定了ENTRYPOINT之后，CMD的含义就发生了变化，不再是直接运行其命令，而是将CMD的内容作为参数传递给ENTRYPOINT，它们两个组合成<code>&lt;ENTRYPOINT&gt;&lt;CMD&gt;</code> 来执行。</p><p>比如，通过Dokcerfile构建nginx:test镜像，规定运行时指令，分为定参和变参两部分：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginx#...ENTRYPOINT [&quot;nginx&quot;,&quot;-c&quot;] # 定参CMD [&quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;] # 变参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th></th><th>不传参</th><th>传参</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run nginx:test</td><td>docker run nginx:test /etc/nginx/new.conf</td></tr><tr><td>衍生出的容器命令</td><td>nginx -c /etc/nginx/nginx.conf</td><td>nginx -c /etc/nginx/new.conf</td></tr></tbody></table><p>如果Dockerfile中存在多个<code>ENTRYPOINT</code>指令，仅最后一个生效。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/c5f220a24bb0472287fc7bd95cf481e7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU3JjTWlMZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s源码(一): Pod创建流程</title>
      <link href="/k8s-yuan-ma-yi-pod-chuang-jian-liu-cheng/"/>
      <url>/k8s-yuan-ma-yi-pod-chuang-jian-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>kubelet 的工作核心，就是一个控制循环，即：<code>SyncLoop</code>。驱动整个控制循环的事件有：pod更新事件、pod生命周期变化、kubelet本身设置的执行周期、定时清理事件等。在SyncLoop循环上还有很多Manager，例如probeManager 会定时去监控 pod 中容器的健康状况、statusManager 负责维护状态信息，并把 pod 状态更新到 apiserver、ontainerRefManager 容器引用的管理等等。不过这些Manage在这里先不管，只聚焦于Pod的创建。</p><span id="more"></span><img src="https://i.bmp.ovh/imgs/2022/01/5089f514aabe5eeb.png"  /><p>注，这里使用的k8s版本号为<code>v1.9.3</code>，git commit为<code>d2835416544</code>，因为最近在学漏洞<code>CVE-2017</code>，所以选的k8s版本比较老，不过问题不大，创建Pod的主要流程基本没变。</p><h3 id="syncLoop循环监听管道信息"><a href="#syncLoop循环监听管道信息" class="headerlink" title="syncLoop循环监听管道信息"></a>syncLoop循环监听管道信息</h3><p>整个Kubelet的启动，都记录在<code>kubernetes\pkg\kubelet\kubelet.go</code>文件中的<code>Run</code>方法中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Run starts the kubelet reacting to config updates</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">Run</span><span class="token punctuation">(</span>updates <span class="token operator">&lt;-</span><span class="token keyword">chan</span> kubetypes<span class="token punctuation">.</span>PodUpdate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//注册 logServer</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>logServer <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>logServer <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">StripPrefix</span><span class="token punctuation">(</span><span class="token string">"/logs/"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">FileServer</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">Dir</span><span class="token punctuation">(</span><span class="token string">"/var/log/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>kubeClient <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Warning</span><span class="token punctuation">(</span><span class="token string">"No api server defined - no node status update will be sent."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">initializeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>nodeRef<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>KubeletSetupFailed<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Start volume manager</span><span class="token keyword">go</span> kl<span class="token punctuation">.</span>volumeManager<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>sourcesReady<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>kubeClient <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Start syncing node status immediately, this may set up things the runtime needs to run.</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>syncNodeStatus<span class="token punctuation">,</span> kl<span class="token punctuation">.</span>nodeStatusUpdateFrequency<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>syncNetworkStatus<span class="token punctuation">,</span> <span class="token number">30</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>updateRuntimeUp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token comment">// Start loop to sync iptables util rules</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>makeIPTablesUtilChains <span class="token punctuation">&#123;</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>syncNetworkUtil<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Minute<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Start a goroutine responsible for killing pods (that are not properly</span><span class="token comment">// handled by pod workers).</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>podKiller<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token comment">// Start gorouting responsible for checking limits in resolv.conf</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>dnsConfigurer<span class="token punctuation">.</span>ResolverConfig <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> kl<span class="token punctuation">.</span>dnsConfigurer<span class="token punctuation">.</span><span class="token function">CheckLimitsForResolvConf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Start component sync loops.</span>kl<span class="token punctuation">.</span>statusManager<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>kl<span class="token punctuation">.</span>probeManager<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Start the pod lifecycle event generator.</span>    <span class="token comment">//启动 pleg 该模块主要用于周期性地向 container runtime 刷新当前所有容器的状态</span>kl<span class="token punctuation">.</span>pleg<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>kl<span class="token punctuation">.</span><span class="token function">syncLoop</span><span class="token punctuation">(</span>updates<span class="token punctuation">,</span> kl<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Run</code>方法的最后，会调用<code>kl.syncLoop</code>方法来启动事件循环，方法位于<code>pkg/kubelet/kubelet.go</code>:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// syncLoop is the main loop for processing changes. It watches for changes from</span><span class="token comment">// three channels (file, apiserver, and http) and creates a union of them. For</span><span class="token comment">// any new change seen, will run a sync against desired state and running state. If</span><span class="token comment">// no changes are seen to the configuration, will synchronize the last known desired</span><span class="token comment">// state every sync-frequency seconds. Never returns.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncLoop</span><span class="token punctuation">(</span>updates <span class="token operator">&lt;-</span><span class="token keyword">chan</span> kubetypes<span class="token punctuation">.</span>PodUpdate<span class="token punctuation">,</span> handler SyncHandler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"Starting kubelet main sync loop."</span><span class="token punctuation">)</span><span class="token comment">// The resyncTicker wakes up kubelet to checks if there are any pod workers</span><span class="token comment">// that need to be sync'd. A one-second period is sufficient because the</span><span class="token comment">// sync interval is defaulted to 10s.</span>syncTicker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">defer</span> syncTicker<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>housekeepingTicker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>housekeepingPeriod<span class="token punctuation">)</span><span class="token keyword">defer</span> housekeepingTicker<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>plegCh <span class="token operator">:=</span> kl<span class="token punctuation">.</span>pleg<span class="token punctuation">.</span><span class="token function">Watch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> rs <span class="token operator">:=</span> kl<span class="token punctuation">.</span>runtimeState<span class="token punctuation">.</span><span class="token function">runtimeErrors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"skipping pod synchronization - %v"</span><span class="token punctuation">,</span> rs<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>kl<span class="token punctuation">.</span>syncLoopMonitor<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">syncLoopIteration</span><span class="token punctuation">(</span>updates<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> syncTicker<span class="token punctuation">.</span>C<span class="token punctuation">,</span> housekeepingTicker<span class="token punctuation">.</span>C<span class="token punctuation">,</span> plegCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>kl<span class="token punctuation">.</span>syncLoopMonitor<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>syncLoop</code>将同时 watch 3 个不同来源的 pod 信息的变化（file，http，apiserver），一旦某个来源的 pod 信息发生了更新（创建/更新/删除），这个 channel 中就会出现被更新的 pod 信息和更新的具体操作。而这个监听逻辑，主要由它调用的<code>syncLoopIteration</code>实现。</p><h3 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h3><p><code>syncLoopIteration</code>会从不同的管道读取，并将Pods交付给指定Handler：</p><blockquote><p>syncLoopIteration reads from various channels and dispatches pods to the given handler.</p></blockquote><p>其传入的参数有5个，1个handler和4个chan：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Arguments:</span><span class="token comment">// 1.  configCh:       a channel to read config events from</span><span class="token comment">// 2.  handler:        the SyncHandler to dispatch pods to</span><span class="token comment">// 3.  syncCh:         a channel to read periodic sync events from</span><span class="token comment">// 4.  houseKeepingCh: a channel to read housekeeping events from</span><span class="token comment">// 5.  plegCh:         a channel to read PLEG updates from</span><span class="token comment">// * configCh: dispatch the pods for the config change to the appropriate</span><span class="token comment">//             handler callback for the event type</span><span class="token comment">// * plegCh: update the runtime cache; sync pod</span><span class="token comment">// * syncCh: sync all pods waiting for sync</span><span class="token comment">// * houseKeepingCh: trigger cleanup of pods</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于只关注Pod的创建过程，因此只探讨<code>configCh</code>部分的代码即可：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncLoopIteration</span><span class="token punctuation">(</span>configCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> kubetypes<span class="token punctuation">.</span>PodUpdate<span class="token punctuation">,</span> handler SyncHandler<span class="token punctuation">,</span><span class="token comment">//方法会监听多个 channel，当发现任何一个 channel 有数据就交给 handler 去处理，在 handler 中通过调用 dispatchWork 分发任务</span>syncCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> housekeepingCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> plegCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>pleg<span class="token punctuation">.</span>PodLifecycleEvent<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> u<span class="token punctuation">,</span> open <span class="token operator">:=</span> <span class="token operator">&lt;-</span>configCh<span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token operator">!</span>open <span class="token punctuation">&#123;</span>klog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Update channel is closed. Exiting the sync loop."</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> u<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>ADD<span class="token punctuation">:</span>klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (ADD, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span> handler<span class="token punctuation">.</span><span class="token function">HandlePodAdditions</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>UPDATE<span class="token punctuation">:</span>klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (UPDATE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">PodsWithDeletionTimestamps</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodUpdates</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>REMOVE<span class="token punctuation">:</span>klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (REMOVE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodRemoves</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>RECONCILE<span class="token punctuation">:</span>klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (RECONCILE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodReconcile</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>DELETE<span class="token punctuation">:</span>klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (DELETE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span> handler<span class="token punctuation">.</span><span class="token function">HandlePodUpdates</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>SET<span class="token punctuation">:</span> klog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Kubelet does not support snapshot update"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>klog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Invalid event type received: %d."</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Op<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>kl<span class="token punctuation">.</span>sourcesReady<span class="token punctuation">.</span><span class="token function">AddSource</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Source<span class="token punctuation">)</span> <span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该模块会根据<code>configCh</code>中的<code>u.Op</code>来选择对Pods的处理方式。当事件类型为<code>ADD</code>时，即调用<code>HandlePodAdditions</code>方法创建Pods。</p><h3 id="Pod-Struct"><a href="#Pod-Struct" class="headerlink" title="Pod Struct"></a>Pod Struct</h3><p>在进入上述方法前，先看下它的入参。<code>u.Pods</code>是一个<code>Pod Struct </code>类型的切片，而这个结构就是源码中存储Pod信息的最外层结构。其源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Pod is a collection of containers that can run on a host. This resource is created</span><span class="token comment">// by clients and scheduled onto hosts.</span><span class="token keyword">type</span> Pod <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>metav1<span class="token punctuation">.</span>TypeMeta <span class="token string">`json:",inline"`</span><span class="token comment">// Standard object's metadata.</span><span class="token comment">// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata</span><span class="token comment">// +optional</span>metav1<span class="token punctuation">.</span>ObjectMeta <span class="token string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span><span class="token comment">// Specification of the desired behavior of the pod.</span><span class="token comment">// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</span><span class="token comment">// +optional</span>Spec PodSpec <span class="token string">`json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`</span><span class="token comment">// Most recently observed status of the pod.</span><span class="token comment">// This data may not be up to date.</span><span class="token comment">// Populated by the system.</span><span class="token comment">// Read-only.</span><span class="token comment">// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</span><span class="token comment">// +optional</span>Status PodStatus <span class="token string">`json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这四个字段都大有来头，第一个记录了<code>kind</code>和<code>apiVersion</code>，第二个存储了Pod的标准对象原数据，如<code>name</code>、<code>namespace</code>、<code>UID</code>等等。第三个就是大名鼎鼎的<code>PodSpec</code>，记录了Pod的详述，如<code>volume</code>、<code>containers</code>、<code>restartPloicy</code>等等。第四个<code>PodStatus</code>顾名思义就是Pod的状态，里面的<code>phase</code>字段标识了Pod的大体状态，分为Pending、Running、Succeed、Failed、Unkonw，其中Succeed和Failed都为Terminated状态。</p><p>很容易想到，这个<code>Pod Struct</code>是和<code>资源清单</code>文件对应的，结构中的很多字段都从清单中读取，来记录这个待创建Pod的信息。</p><p>上面几个字段的类型都位于package <code>v1</code>中，比如<code>PodStatus</code>，所以叫<code>v1.PodStatus</code>。要注意的是，其他包里也有同名的结构体，比如<code>container.PodStatus</code>，要区分开来。</p><h3 id="HandlePodAdditions"><a href="#HandlePodAdditions" class="headerlink" title="HandlePodAdditions"></a>HandlePodAdditions</h3><p>好了，看完这个结构就可以往下看了。进入刚才那个接口实现体看下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// HandlePodAdditions is the callback in SyncHandler for pods being added from</span><span class="token comment">// a config source.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">HandlePodAdditions</span><span class="token punctuation">(</span>pods <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>start <span class="token operator">:=</span> kl<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 将待创建的Pods按创建时间排序</span>sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>sliceutils<span class="token punctuation">.</span><span class="token function">PodsByCreationTime</span><span class="token punctuation">(</span>pods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> pod <span class="token operator">:=</span> <span class="token keyword">range</span> pods <span class="token punctuation">&#123;</span><span class="token comment">// 获取当前Pod管理器中已存在的Pods</span>existingPods <span class="token operator">:=</span> kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">GetPods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span><span class="token comment">// manager as the source of truth for the desired state. If a pod does</span><span class="token comment">// not exist in the pod manager, it means that it has been deleted in</span><span class="token comment">// the apiserver and no action (other than cleanup) is required.</span><span class="token comment">// 将待创建的Pod加入Pod管理器中</span>kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">AddPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token keyword">if</span> kubepod<span class="token punctuation">.</span><span class="token function">IsMirrorPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span><span class="token function">handleMirrorPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果该Pod没有被terminate</span>        <span class="token comment">// 通过PodStatus判断，Succeed和Failed都视为terminated</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Only go through the admission process if the pod is not</span><span class="token comment">// terminated.</span><span class="token comment">// We failed pods that we rejected, so activePods include all admitted</span><span class="token comment">// pods that are alive.</span><span class="token comment">// 从existingPods中筛选出处于处于非terminated态的Pods</span>activePods <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">filterOutTerminatedPods</span><span class="token punctuation">(</span>existingPods<span class="token punctuation">)</span><span class="token comment">// Check if we can admit the pod; if not, reject it.</span><span class="token comment">// 验证该Pod是否被允许在该节点允许，如果不可以则拒绝创建</span><span class="token keyword">if</span> ok<span class="token punctuation">,</span> reason<span class="token punctuation">,</span> message <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">canAdmitPod</span><span class="token punctuation">(</span>activePods<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span><span class="token function">rejectPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> reason<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>mirrorPod<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">GetMirrorPodByPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token comment">// 把该Pod交给dispatchWork来创建</span>kl<span class="token punctuation">.</span><span class="token function">dispatchWork</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kubetypes<span class="token punctuation">.</span>SyncPodCreate<span class="token punctuation">,</span> mirrorPod<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token comment">// Pod创建完毕后，加入probeManager进行健康检查</span>kl<span class="token punctuation">.</span>probeManager<span class="token punctuation">.</span><span class="token function">AddPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码流程还是相对明确的。可以看到，<code>HandlePodAdditions</code>的主要工作为:</p><p>​    1&gt; 按照创建时间给待创建的Pods进行排序。然后对其中<strong>每个Pod</strong>进行下述处理；</p><p>​    2&gt; 获取当前Pod管理器中已存在的所有Pods（existingPods）；</p><p>​    3&gt; 将该Pod添加到Pod管理器中；</p><p>​    4&gt; 检验该Pod是否能在该节点上允许，如果不允许则直接拒绝；</p><p>​    5&gt; 将该Pod交付给<code>dispathWork</code>来创建；</p><p>​    6&gt; 当该Pod创建完毕后，将其添加到probeManager中，进行健康检查。</p><p>也就是说，创建Pod的，实际上是<code>dispathWork</code>方法，且传入参数<code>kubetypes.SyncPodCreate</code>指明对该Pod的操作为创建。</p><h4 id="dispatchWork"><a href="#dispatchWork" class="headerlink" title="dispatchWork"></a>dispatchWork</h4><p>我们进入该方法看下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">dispatchWork</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> syncType kubetypes<span class="token punctuation">.</span>SyncPodType<span class="token punctuation">,</span> mirrorPod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> start time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 若pod处于终结态，直接删除</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> pod<span class="token punctuation">.</span>DeletionTimestamp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// If the pod is in a terminated state, there is no pod worker to</span><span class="token comment">// handle the work item. Check if the DeletionTimestamp has been</span><span class="token comment">// set, and force a status update to trigger a pod deletion request</span><span class="token comment">// to the apiserver.</span>kl<span class="token punctuation">.</span>statusManager<span class="token punctuation">.</span><span class="token function">TerminatePod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// Run the sync in an async worker.</span>kl<span class="token punctuation">.</span>podWorkers<span class="token punctuation">.</span><span class="token function">UpdatePod</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>UpdatePodOptions<span class="token punctuation">&#123;</span>Pod<span class="token punctuation">:</span>        pod<span class="token punctuation">,</span>MirrorPod<span class="token punctuation">:</span>  mirrorPod<span class="token punctuation">,</span>UpdateType<span class="token punctuation">:</span> syncType<span class="token punctuation">,</span>OnCompleteFunc<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>metrics<span class="token punctuation">.</span>PodWorkerLatency<span class="token punctuation">.</span><span class="token function">WithLabelValues</span><span class="token punctuation">(</span>syncType<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span><span class="token function">SinceInMicroseconds</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// Note the number of containers for new pods.</span><span class="token keyword">if</span> syncType <span class="token operator">==</span> kubetypes<span class="token punctuation">.</span>SyncPodCreate <span class="token punctuation">&#123;</span>metrics<span class="token punctuation">.</span>ContainersPerPodCount<span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>Containers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该方法主要做三个工作：</p><p>​    1&gt; 如果Pod是终结态（”Failed” or “Succeeded”），则对status进行更新，触发对Pod的删除；</p><p>​    2&gt; 封装一个<code>UpdatePodOptions</code>来交给<code>UpdatePod</code>处理，其中字段<code>UpdateType</code>就是方法的<code>syncType</code>参数，在这里就是<code>kubetypes.SyncPodCreate</code>；</p><p>​    3&gt; 如果是创建操作，当然这里就是创建操作，会记录下新的Pod中的container数量。</p><p>也即，核心操作是<code>UpdatePod</code>方法，该文件位于<code>pkg/kubelet/pod_workers.go</code>。</p><h4 id="UpdatePod"><a href="#UpdatePod" class="headerlink" title="UpdatePod"></a>UpdatePod</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>podWorkers<span class="token punctuation">)</span> <span class="token function">UpdatePod</span><span class="token punctuation">(</span>options <span class="token operator">*</span>UpdatePodOptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pod <span class="token operator">:=</span> options<span class="token punctuation">.</span>Poduid <span class="token operator">:=</span> pod<span class="token punctuation">.</span>UID<span class="token keyword">var</span> podUpdates <span class="token keyword">chan</span> UpdatePodOptions<span class="token keyword">var</span> exists <span class="token builtin">bool</span>p<span class="token punctuation">.</span>podLock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 加锁</span><span class="token keyword">defer</span> p<span class="token punctuation">.</span>podLock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 延时开锁</span><span class="token comment">// 如果该pod在podUpdates数组里面找不到，那么就创建channel，并启动异步线程，调用managePodLoop</span><span class="token keyword">if</span> podUpdates<span class="token punctuation">,</span> exists <span class="token operator">=</span> p<span class="token punctuation">.</span>podUpdates<span class="token punctuation">[</span>uid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>exists <span class="token punctuation">&#123;</span><span class="token comment">// We need to have a buffer here, because checkForUpdates() method that</span><span class="token comment">// puts an update into channel is called from the same goroutine where</span><span class="token comment">// the channel is consumed. However, it is guaranteed that in such case</span><span class="token comment">// the channel is empty, so buffer of size 1 is enough.</span>podUpdates <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> UpdatePodOptions<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>podUpdates<span class="token punctuation">[</span>uid<span class="token punctuation">]</span> <span class="token operator">=</span> podUpdates<span class="token comment">// Creating a new pod worker either means this is a new pod, or that the</span><span class="token comment">// kubelet just restarted. In either case the kubelet is willing to believe</span><span class="token comment">// the status of the pod for the first pod worker sync. See corresponding</span><span class="token comment">// comment in syncPod.</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> runtime<span class="token punctuation">.</span><span class="token function">HandleCrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">managePodLoop</span><span class="token punctuation">(</span>podUpdates<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>isWorking<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>isWorking<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>podUpdates <span class="token operator">&lt;-</span> <span class="token operator">*</span>options<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// if a request to kill a pod is pending, we do not let anything overwrite that request.</span>update<span class="token punctuation">,</span> found <span class="token operator">:=</span> p<span class="token punctuation">.</span>lastUndeliveredWorkUpdate<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token operator">!</span>found <span class="token operator">||</span> update<span class="token punctuation">.</span>UpdateType <span class="token operator">!=</span> kubetypes<span class="token punctuation">.</span>SyncPodKill <span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>lastUndeliveredWorkUpdate<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>options<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该方法会在<code>p.podUpdates</code>数组里找当前Pod，如果没找到，就说明该Pod是要新创建的，或者Kubelet刚刚重启。不管是那种情况，方法都会创建一个新的channel，这个channel元素个数为1，即只有一个<code>UpdatePodOptions</code>。完成后，将该channel加入到<code>p.podUpdates</code>中。接着，开始调用<code>managePodLoop</code>。</p><h4 id="managePodLoop"><a href="#managePodLoop" class="headerlink" title="managePodLoop"></a>managePodLoop</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>podWorkers<span class="token punctuation">)</span> <span class="token function">managePodLoop</span><span class="token punctuation">(</span>podUpdates <span class="token operator">&lt;-</span><span class="token keyword">chan</span> UpdatePodOptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> lastSyncTime time<span class="token punctuation">.</span>Time<span class="token comment">// 遍历channel</span><span class="token keyword">for</span> update <span class="token operator">:=</span> <span class="token keyword">range</span> podUpdates <span class="token punctuation">&#123;</span>err <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>podUID <span class="token operator">:=</span> update<span class="token punctuation">.</span>Pod<span class="token punctuation">.</span>UID<span class="token comment">// This is a blocking call that would return only if the cache</span><span class="token comment">// has an entry for the pod that is newer than minRuntimeCache</span><span class="token comment">// Time. This ensures the worker doesn't start syncing until</span><span class="token comment">// after the cache is at least newer than the finished time of</span><span class="token comment">// the previous sync.</span><span class="token comment">// 直到cache里面有新数据之前这段代码会阻塞，这保证worker在cache里面有新的数据之前不会提前开始</span>status<span class="token punctuation">,</span> err <span class="token operator">:=</span> p<span class="token punctuation">.</span>podCache<span class="token punctuation">.</span><span class="token function">GetNewerThan</span><span class="token punctuation">(</span>podUID<span class="token punctuation">,</span> lastSyncTime<span class="token punctuation">)</span><span class="token comment">//syncPodFn会在kubelet初始化的时候设置，调用的是kubelet的syncPod方法</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// This is the legacy event thrown by manage pod loop</span><span class="token comment">// all other events are now dispatched from syncPodFn</span>p<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedSync<span class="token punctuation">,</span> <span class="token string">"error determining status: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span>err <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">syncPodFn</span><span class="token punctuation">(</span>syncPodOptions<span class="token punctuation">&#123;</span>mirrorPod<span class="token punctuation">:</span>      update<span class="token punctuation">.</span>MirrorPod<span class="token punctuation">,</span>pod<span class="token punctuation">:</span>            update<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span>podStatus<span class="token punctuation">:</span>      status<span class="token punctuation">,</span>killPodOptions<span class="token punctuation">:</span> update<span class="token punctuation">.</span>KillPodOptions<span class="token punctuation">,</span>updateType<span class="token punctuation">:</span>     update<span class="token punctuation">.</span>UpdateType<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>lastSyncTime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// notify the call-back function if the operation succeeded or not</span><span class="token keyword">if</span> update<span class="token punctuation">.</span>OnCompleteFunc <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>update<span class="token punctuation">.</span><span class="token function">OnCompleteFunc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// IMPORTANT: we do not log errors here, the syncPodFn is responsible for logging errors</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Error syncing pod %s (%q), skipping: %v"</span><span class="token punctuation">,</span> update<span class="token punctuation">.</span>Pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>p<span class="token punctuation">.</span><span class="token function">wrapUp</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>Pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法会遍历传入的channel中的数据，不过这里由于刚刚传入channel元素个数只有1，因此相当于取出其中的<code>UpdatePodOptions</code>，命名为<code>update</code>。然后，会根据<code>update</code>中的字段构造一个新的结构体<code>syncPodOptions</code>，并将其传给<code>syncPodFn</code>进行处理。</p><p><code>synvPodFn</code>是在Kubelet初始化时设置的。在初始化时，Kubelet会在执行<code>NewMainKubelet</code>时调用<code>newPodWorkers</code>方法设置<code>syncPodFn</code>为Kublet的<code>syncPod</code>方法，如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewMainKubelet</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">...</span>klet <span class="token operator">:=</span> <span class="token operator">&amp;</span>Kubelet<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token operator">...</span>klet<span class="token punctuation">.</span>podWorkers <span class="token operator">=</span> <span class="token function">newPodWorkers</span><span class="token punctuation">(</span>klet<span class="token punctuation">.</span>syncPod<span class="token punctuation">,</span> kubeDeps<span class="token punctuation">.</span>Recorder<span class="token punctuation">,</span> klet<span class="token punctuation">.</span>workQueue<span class="token punctuation">,</span> klet<span class="token punctuation">.</span>resyncInterval<span class="token punctuation">,</span> backOffPeriod<span class="token punctuation">,</span> klet<span class="token punctuation">.</span>podCache<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也即，要创建Pod，就要进入方法<code>syncPod</code>，该方法位于<code>pkg/kubelet/kubelet.go</code>中。</p><p>但是要注意的是，<code>syncPodOptions</code>结构中有一个<code>podStatus</code>字段，这个字段的类型也叫<code>PodStatus</code>，位于<code>pkg/kubelet/container/runtime.go</code>中，包名为<code>container</code>，源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PodStatus represents the status of the pod and its containers.</span><span class="token comment">// v1.PodStatus can be derived from examining PodStatus and v1.Pod.</span><span class="token keyword">type</span> PodStatus <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// ID of the pod.</span>ID types<span class="token punctuation">.</span>UID<span class="token comment">// Name of the pod.</span>Name <span class="token builtin">string</span><span class="token comment">// Namspace of the pod.</span>Namespace <span class="token builtin">string</span><span class="token comment">// IP of the pod.</span>IP <span class="token builtin">string</span><span class="token comment">// Status of containers in the pod.</span>ContainerStatuses <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>ContainerStatus<span class="token comment">// Status of the pod sandbox.</span><span class="token comment">// Only for kuberuntime now, other runtime may keep it nil.</span>SandboxStatuses <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>PodSandboxStatus<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从注释中可以看出来，之前说的<code>v1.PodStatus</code>是可以通过这个<code>container.PodStatus</code>转换而得到的。实际上，这个结构可以认为只是一个中间态，最终标识Pod状态，依然是之前的那个<code>v1.PodStatus</code>。</p><h4 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncPod</span><span class="token punctuation">(</span>o syncPodOptions<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token comment">// pull out the required options</span>pod <span class="token operator">:=</span> o<span class="token punctuation">.</span>podmirrorPod <span class="token operator">:=</span> o<span class="token punctuation">.</span>mirrorPodpodStatus <span class="token operator">:=</span> o<span class="token punctuation">.</span>podStatusupdateType <span class="token operator">:=</span> o<span class="token punctuation">.</span>updateType<span class="token comment">// if we want to kill a pod, do it now!</span><span class="token keyword">if</span> updateType <span class="token operator">==</span> kubetypes<span class="token punctuation">.</span>SyncPodKill <span class="token punctuation">&#123;</span>killPodOptions <span class="token operator">:=</span> o<span class="token punctuation">.</span>killPodOptions<span class="token keyword">if</span> killPodOptions <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> killPodOptions<span class="token punctuation">.</span>PodStatusFunc <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"kill pod options are required if update type is kill"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>apiPodStatus <span class="token operator">:=</span> killPodOptions<span class="token punctuation">.</span><span class="token function">PodStatusFunc</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span>kl<span class="token punctuation">.</span>statusManager<span class="token punctuation">.</span><span class="token function">SetPodStatus</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> apiPodStatus<span class="token punctuation">)</span><span class="token comment">// we kill the pod with the specified grace period since this is a termination</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">killPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> killPodOptions<span class="token punctuation">.</span>PodTerminationGracePeriodSecondsOverride<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToKillPod<span class="token punctuation">,</span> <span class="token string">"error killing pod: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token comment">// there was an error killing the pod, so we return that error directly</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token comment">// Latency measurements for the main workflow are relative to the</span><span class="token comment">// first time the pod was seen by the API server.</span><span class="token keyword">var</span> firstSeenTime time<span class="token punctuation">.</span>Time<span class="token keyword">if</span> firstSeenTimeStr<span class="token punctuation">,</span> ok <span class="token operator">:=</span> pod<span class="token punctuation">.</span>Annotations<span class="token punctuation">[</span>kubetypes<span class="token punctuation">.</span>ConfigFirstSeenAnnotationKey<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>firstSeenTime <span class="token operator">=</span> kubetypes<span class="token punctuation">.</span><span class="token function">ConvertToTimestamp</span><span class="token punctuation">(</span>firstSeenTimeStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Record pod worker start latency if being created</span><span class="token comment">// TODO: make pod workers record their own latencies</span><span class="token keyword">if</span> updateType <span class="token operator">==</span> kubetypes<span class="token punctuation">.</span>SyncPodCreate <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>firstSeenTime<span class="token punctuation">.</span><span class="token function">IsZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// This is the first time we are syncing the pod. Record the latency</span><span class="token comment">// since kubelet first saw the pod if firstSeenTime is set.</span>metrics<span class="token punctuation">.</span>PodWorkerStartLatency<span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span><span class="token function">SinceInMicroseconds</span><span class="token punctuation">(</span>firstSeenTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"First seen time not recorded for pod %q"</span><span class="token punctuation">,</span> pod<span class="token punctuation">.</span>UID<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Generate final API pod status with pod and status manager status</span>apiPodStatus <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">generateAPIPodStatus</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span><span class="token comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span><span class="token comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span>podStatus<span class="token punctuation">.</span>IP <span class="token operator">=</span> apiPodStatus<span class="token punctuation">.</span>PodIP<span class="token comment">// Record the time it takes for the pod to become running.</span>existingStatus<span class="token punctuation">,</span> ok <span class="token operator">:=</span> kl<span class="token punctuation">.</span>statusManager<span class="token punctuation">.</span><span class="token function">GetPodStatus</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token operator">||</span> existingStatus<span class="token punctuation">.</span>Phase <span class="token operator">==</span> v1<span class="token punctuation">.</span>PodPending <span class="token operator">&amp;&amp;</span> apiPodStatus<span class="token punctuation">.</span>Phase <span class="token operator">==</span> v1<span class="token punctuation">.</span>PodRunning <span class="token operator">&amp;&amp;</span><span class="token operator">!</span>firstSeenTime<span class="token punctuation">.</span><span class="token function">IsZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>metrics<span class="token punctuation">.</span>PodStartLatency<span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span><span class="token function">SinceInMicroseconds</span><span class="token punctuation">(</span>firstSeenTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 校验该Pod能否运行</span>runnable <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">canRunPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token comment">// 如果不能运行，将Reason和Message写回v1.PodStatus</span><span class="token keyword">if</span> <span class="token operator">!</span>runnable<span class="token punctuation">.</span>Admit <span class="token punctuation">&#123;</span><span class="token comment">// Pod is not runnable; update the Pod and Container statuses to why.</span>apiPodStatus<span class="token punctuation">.</span>Reason <span class="token operator">=</span> runnable<span class="token punctuation">.</span>ReasonapiPodStatus<span class="token punctuation">.</span>Message <span class="token operator">=</span> runnable<span class="token punctuation">.</span>Message<span class="token comment">// Waiting containers are not creating.</span>        <span class="token comment">// 写回Container的等待原因，为Blocked</span><span class="token keyword">const</span> waitingReason <span class="token operator">=</span> <span class="token string">"Blocked"</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> cs <span class="token operator">:=</span> <span class="token keyword">range</span> apiPodStatus<span class="token punctuation">.</span>InitContainerStatuses <span class="token punctuation">&#123;</span><span class="token keyword">if</span> cs<span class="token punctuation">.</span>State<span class="token punctuation">.</span>Waiting <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>cs<span class="token punctuation">.</span>State<span class="token punctuation">.</span>Waiting<span class="token punctuation">.</span>Reason <span class="token operator">=</span> waitingReason<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> cs <span class="token operator">:=</span> <span class="token keyword">range</span> apiPodStatus<span class="token punctuation">.</span>ContainerStatuses <span class="token punctuation">&#123;</span><span class="token keyword">if</span> cs<span class="token punctuation">.</span>State<span class="token punctuation">.</span>Waiting <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>cs<span class="token punctuation">.</span>State<span class="token punctuation">.</span>Waiting<span class="token punctuation">.</span>Reason <span class="token operator">=</span> waitingReason<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Update status in the status manager</span><span class="token comment">// 更新状态管理器中的状态</span>kl<span class="token punctuation">.</span>statusManager<span class="token punctuation">.</span><span class="token function">SetPodStatus</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> apiPodStatus<span class="token punctuation">)</span><span class="token comment">// Kill pod if it should not be running</span><span class="token comment">// 如果校验没通过或pod已被删除或pod跑失败了，那么kill掉pod</span><span class="token keyword">if</span> <span class="token operator">!</span>runnable<span class="token punctuation">.</span>Admit <span class="token operator">||</span> pod<span class="token punctuation">.</span>DeletionTimestamp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> apiPodStatus<span class="token punctuation">.</span>Phase <span class="token operator">==</span> v1<span class="token punctuation">.</span>PodFailed <span class="token punctuation">&#123;</span><span class="token keyword">var</span> syncErr <span class="token builtin">error</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">killPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToKillPod<span class="token punctuation">,</span> <span class="token string">"error killing pod: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>syncErr <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"error killing pod: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>syncErr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>runnable<span class="token punctuation">.</span>Admit <span class="token punctuation">&#123;</span><span class="token comment">// There was no error killing the pod, but the pod cannot be run.</span><span class="token comment">// Return an error to signal that the sync loop should back off.</span>syncErr <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"pod cannot be run: %s"</span><span class="token punctuation">,</span> runnable<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> syncErr<span class="token punctuation">&#125;</span><span class="token comment">// If the network plugin is not ready, only start the pod if it uses the host network</span><span class="token comment">//校验网络插件是否已准备好</span><span class="token keyword">if</span> rs <span class="token operator">:=</span> kl<span class="token punctuation">.</span>runtimeState<span class="token punctuation">.</span><span class="token function">networkErrors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>kubecontainer<span class="token punctuation">.</span><span class="token function">IsHostNetworkPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>NetworkNotReady<span class="token punctuation">,</span> <span class="token string">"network is not ready: %v"</span><span class="token punctuation">,</span> rs<span class="token punctuation">)</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"network is not ready: %v"</span><span class="token punctuation">,</span> rs<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Create Cgroups for the pod and apply resource parameters</span><span class="token comment">// to them if cgroups-per-qos flag is enabled.</span><span class="token comment">// 为该Pod创建PodContainerManager</span>pcm <span class="token operator">:=</span> kl<span class="token punctuation">.</span>containerManager<span class="token punctuation">.</span><span class="token function">NewPodContainerManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// If pod has already been terminated then we need not create</span><span class="token comment">// or update the pod's cgroup</span><span class="token comment">// 如果该Pod不是终结态</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// When the kubelet is restarted with the cgroups-per-qos</span><span class="token comment">// flag enabled, all the pod's running containers</span><span class="token comment">// should be killed intermittently and brought back up</span><span class="token comment">// under the qos cgroup hierarchy.</span><span class="token comment">// Check if this is the pod's first sync</span>firstSync <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token comment">// 校验该pod是否首次创建</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> containerStatus <span class="token operator">:=</span> <span class="token keyword">range</span> apiPodStatus<span class="token punctuation">.</span>ContainerStatuses <span class="token punctuation">&#123;</span><span class="token keyword">if</span> containerStatus<span class="token punctuation">.</span>State<span class="token punctuation">.</span>Running <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>firstSync <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Don't kill containers in pod if pod's cgroups already</span><span class="token comment">// exists or the pod is running for the first time</span>podKilled <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token comment">// 如果该pod 的cgroups不存在，并且不是首次启动，那么kill掉</span><span class="token keyword">if</span> <span class="token operator">!</span>pcm<span class="token punctuation">.</span><span class="token function">Exists</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>firstSync <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">killPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>podKilled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Create and Update pod's Cgroups</span><span class="token comment">// Don't create cgroups for run once pod if it was killed above</span><span class="token comment">// The current policy is not to restart the run once pods when</span><span class="token comment">// the kubelet is restarted with the new flag as run once pods are</span><span class="token comment">// expected to run only once and if the kubelet is restarted then</span><span class="token comment">// they are not expected to run again.</span><span class="token comment">// We don't create and apply updates to cgroup if its a run once pod and was killed above</span><span class="token comment">// 如果该pod在上面没有被kill掉，或重启策略不是永不重启</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token punctuation">(</span>podKilled <span class="token operator">&amp;&amp;</span> pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>RestartPolicy <span class="token operator">==</span> v1<span class="token punctuation">.</span>RestartPolicyNever<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>pcm<span class="token punctuation">.</span><span class="token function">Exists</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>containerManager<span class="token punctuation">.</span><span class="token function">UpdateQOSCgroups</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Failed to update QoS cgroups while syncing pod: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>                <span class="token comment">// 如果该pod的cgroup不存在，那么就创建cgroup</span><span class="token keyword">if</span> err <span class="token operator">:=</span> pcm<span class="token punctuation">.</span><span class="token function">EnsureExists</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreatePodContainer<span class="token punctuation">,</span> <span class="token string">"unable to ensure pod container exists: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"failed to ensure that the pod: %v cgroups exist and are correctly applied: %v"</span><span class="token punctuation">,</span> pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//为静态pod 创建镜像，如果还未存在的话</span><span class="token comment">// Create Mirror Pod for Static Pod if it doesn't already exist</span><span class="token keyword">if</span> kubepod<span class="token punctuation">.</span><span class="token function">IsStaticPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>podFullName <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">GetPodFullName</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span>deleted <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token keyword">if</span> mirrorPod <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> mirrorPod<span class="token punctuation">.</span>DeletionTimestamp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">IsMirrorPodOf</span><span class="token punctuation">(</span>mirrorPod<span class="token punctuation">,</span> pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// The mirror pod is semantically different from the static pod. Remove</span><span class="token comment">// it. The mirror pod will get recreated later.</span>glog<span class="token punctuation">.</span><span class="token function">Warningf</span><span class="token punctuation">(</span><span class="token string">"Deleting mirror pod %q because it is outdated"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>mirrorPod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">DeleteMirrorPod</span><span class="token punctuation">(</span>podFullName<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed deleting mirror pod %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>mirrorPod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>deleted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> mirrorPod <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> deleted <span class="token punctuation">&#123;</span>node<span class="token punctuation">,</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">GetNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> node<span class="token punctuation">.</span>DeletionTimestamp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"No need to create a mirror pod, since node %q has been removed from the cluster"</span><span class="token punctuation">,</span> kl<span class="token punctuation">.</span>nodeName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating a mirror pod for static pod %q"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">CreateMirrorPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed creating a mirror pod for %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Make data directories for the pod</span><span class="token comment">// 创建pod的文件目录</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">makePodDataDirs</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToMakePodDataDirectories<span class="token punctuation">,</span> <span class="token string">"error making pod data directories: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to make pod data directories for pod %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token comment">// Volume manager will not mount volumes for terminated pods</span><span class="token comment">// 如果该pod没有被终止，那么需要等待attach/mount volumes</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Wait for volumes to attach/mount</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>volumeManager<span class="token punctuation">.</span><span class="token function">WaitForAttachAndMount</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedMountVolume<span class="token punctuation">,</span> <span class="token string">"Unable to mount volumes for pod %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to mount volumes for pod %q: %v; skipping pod"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Fetch the pull secrets for the pod</span><span class="token comment">// 如果有 image secrets，去 apiserver 获取对应的 secrets 数据</span>pullSecrets <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">getPullSecretsForPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token comment">// Call the container runtime's SyncPod callback</span><span class="token comment">// 真正的容器创建逻辑，调用SyncPod来真正的创建Pod</span>result <span class="token operator">:=</span> kl<span class="token punctuation">.</span>containerRuntime<span class="token punctuation">.</span><span class="token function">SyncPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> apiPodStatus<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> kl<span class="token punctuation">.</span>backOff<span class="token punctuation">)</span>kl<span class="token punctuation">.</span>reasonCache<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Do not record an event here, as we keep all event logging for sync pod failures</span><span class="token comment">// local to container runtime so we get better errors</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法比较复杂，主要是完成创建Pod前的<code>准备工作</code>，主要准备工作如下：</p><p>​    1&gt; 校验该Pod能否运行，如果不能运行，则将Reason和Message写回v1.PodStatus，并回写container的等待原因，然后通过<code>statusManager</code>更新Pod状态；</p><p>​    2&gt; 如果校验没通过或Pod已被删除或Pod跑失败了，那么kill掉Pod，返回；</p><p>​    3&gt; 校验网络插件是否已经准备好，如果没有，那么当且仅当Pod使用<code>host network</code>才允许启动，否则直接结束；</p><p>​    4&gt; 如果该Pod的<code>cgroup</code>不存在，且不是首次运行，则kill掉；</p><p>​    5&gt; 如果该Pod的cgroup不存在，且在上面没有被kill掉（首次运行），或重启策略不是永不重启，则创建cgroup；</p><p>​    6&gt; 如果Pod是静态（Static）的，且其mirror Pod不存在，创建这个镜像；</p><p>​    7&gt; 调用<code>makePodDataDirs</code>创建Pod的基础文件目录，</p><p>​    8&gt; 等待<code>volume attach/mount</code>；</p><p>​    9&gt; 拉取这个Pod的Secret；</p><p>​    10&gt; 调用<code>containerRuntime.SyncPod</code>来真正创建Pod。</p><p>这整个方法做的事情非常多，这里只看一些比较重要的。首先是第8步，创建Pod基础目录，进入这个方法看看：</p><h4 id="makePodDataDirs"><a href="#makePodDataDirs" class="headerlink" title="makePodDataDirs"></a>makePodDataDirs</h4><p>该方法位于<code>pkg/kubelet/kubelet_pods.go</code>中，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// makePodDataDirs creates the dirs for the pod datas.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">makePodDataDirs</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>uid <span class="token operator">:=</span> pod<span class="token punctuation">.</span>UID<span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodDir</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>os<span class="token punctuation">.</span><span class="token function">IsExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodVolumesDir</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>os<span class="token punctuation">.</span><span class="token function">IsExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodPluginsDir</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>os<span class="token punctuation">.</span><span class="token function">IsExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>MkdirAll</code>就是字面意义的创建目录，主要是其中的几个<code>getxxxDir</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// getPodsDir returns the full path to the directory under which pod</span><span class="token comment">// directories are created.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">getPodsDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getRootDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>DefaultKubeletPodsDirName<span class="token punctuation">)</span><span class="token comment">// "pods"</span><span class="token punctuation">&#125;</span><span class="token comment">// getPodDir returns the full path to the per-pod directory for the pod with</span><span class="token comment">// the given UID.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">getPodDir</span><span class="token punctuation">(</span>podUID types<span class="token punctuation">.</span>UID<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodsDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>podUID<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// getPodVolumesDir returns the full path to the per-pod data directory under</span><span class="token comment">// which volumes are created for the specified pod.  This directory may not</span><span class="token comment">// exist if the pod does not exist.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">getPodVolumesDir</span><span class="token punctuation">(</span>podUID types<span class="token punctuation">.</span>UID<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodDir</span><span class="token punctuation">(</span>podUID<span class="token punctuation">)</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>DefaultKubeletVolumesDirName<span class="token punctuation">)</span>  <span class="token comment">// "volumes"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先看<code>getPodDir</code>，这个方法会将<code>getPodsDir</code>返回的结果和Pod的UID进行拼接。而<code>getPodsDir</code>也很简单，调用<code>getRootDir</code>获取kubelet的根目录，一般为<code>/var/lib/kubelet</code>，然后在后面拼接上字符串<code>pods</code>。也就是说，这一步会创建目录<code>/var/lib/kubelet/pods/&#123;UID&#125;</code>。</p><p>接着，<code>getPodVolumesDir</code>会在上述路径后拼接上字符串<code>volumes</code>，然后交由<code>MkdirAll</code>来创建。<code>plugin</code>也是同理。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/90c8c7649e1f1740.png"></p><p>但是至此为止，只是创建了目录而已，并没有任何数据。</p><p>至于如何获取到上述目录，都知道，Pod实质就是一堆容器。因此通过<code>docker inpspect 容器名</code>查看容器具体信息，里面就可以看到容器的目录，而容器就存在上面的<code>containers</code>子目录下。</p><hr><p>回到<code>syncPod</code>，创建完基础目录后，阻塞等待volume的<code>attach/mount</code>，这个比较复杂，我还没咋搞明白，先跳过。然后，就到了核心方法<code>SyncPod</code>。</p><p>也就是说，上面这个<code>syncPod</code>只是完成了一些创建前的准备工作，真正执行创建Pod的，是<code>containerRuntime.SyncPod</code>方法。位于：<code>pkg/kubelet/kuberuntime/kuberuntime_manager.go</code></p><h4 id="SyncPod"><a href="#SyncPod" class="headerlink" title="SyncPod"></a>SyncPod</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">SyncPod</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> <span class="token boolean">_</span> v1<span class="token punctuation">.</span>PodStatus<span class="token punctuation">,</span> podStatus <span class="token operator">*</span>kubecontainer<span class="token punctuation">.</span>PodStatus<span class="token punctuation">,</span> pullSecrets <span class="token punctuation">[</span><span class="token punctuation">]</span>v1<span class="token punctuation">.</span>Secret<span class="token punctuation">,</span> backOff <span class="token operator">*</span>flowcontrol<span class="token punctuation">.</span>Backoff<span class="token punctuation">)</span> <span class="token punctuation">(</span>result kubecontainer<span class="token punctuation">.</span>PodSyncResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Step 1: Compute sandbox and container changes.</span><span class="token comment">// 检擦Pod Spec是否发生改变，如果是，将这些改变记录下来</span>podContainerChanges <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">computePodActions</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"computePodActions got %+v for pod %q"</span><span class="token punctuation">,</span> podContainerChanges<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> ref<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>legacyscheme<span class="token punctuation">.</span>Scheme<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Couldn't make a ref to pod %q: '%v'"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>SandboxID <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeNormal<span class="token punctuation">,</span> events<span class="token punctuation">.</span>SandboxChanged<span class="token punctuation">,</span> <span class="token string">"Pod sandbox changed, it will be killed and re-created."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncPod received new pod %q, will create a sandbox for it"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 2: Kill the pod if the sandbox has changed.</span><span class="token comment">// kill掉 sandbox 已经改变的 pod</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>KillPod <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Stopping PodSandbox for %q because all other containers are dead."</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Stopping PodSandbox for %q, will start new one"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>killResult <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">killPodWithSyncResult</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kubecontainer<span class="token punctuation">.</span><span class="token function">ConvertPodStatusToRunningPod</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>runtimeName<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddPodSyncResult</span><span class="token punctuation">(</span>killResult<span class="token punctuation">)</span><span class="token keyword">if</span> killResult<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"killPodWithSyncResult failed: %v"</span><span class="token punctuation">,</span> killResult<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">purgeInitContainers</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// Step 3: kill any running containers in this pod which are not to keep.</span><span class="token comment">// kill掉ContainersToKill列表中的container</span><span class="token keyword">for</span> containerID<span class="token punctuation">,</span> containerInfo <span class="token operator">:=</span> <span class="token keyword">range</span> podContainerChanges<span class="token punctuation">.</span>ContainersToKill <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Killing unwanted container %q(id=%q) for pod %q"</span><span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>killContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>KillContainer<span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>killContainerResult<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">killContainer</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>message<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>killContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ErrKillContainer<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"killContainer %q(id=%q) for pod %q failed: %v"</span><span class="token punctuation">,</span> containerInfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Keep terminated init containers fairly aggressively controlled</span><span class="token comment">// This is an optmization because container removals are typically handled</span><span class="token comment">// by container garbage collector.</span><span class="token comment">// 删除一些Init Container，减少容器垃圾收集器上的负载</span>m<span class="token punctuation">.</span><span class="token function">pruneInitContainersBeforeStart</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">)</span><span class="token comment">// We pass the value of the podIP down to generatePodSandboxConfig and</span><span class="token comment">// generateContainerConfig, which in turn passes it to various other</span><span class="token comment">// functions, in order to facilitate functionality that requires this</span><span class="token comment">// value (hosts file and downward API) and avoid races determining</span><span class="token comment">// the pod IP in cases where a container requires restart but the</span><span class="token comment">// podIP isn't in the status manager yet.</span><span class="token comment">//</span><span class="token comment">// We default to the IP in the passed-in pod status, and overwrite it if the</span><span class="token comment">// sandbox needs to be (re)started.</span>podIP <span class="token operator">:=</span> <span class="token string">""</span><span class="token keyword">if</span> podStatus <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>podIP <span class="token operator">=</span> podStatus<span class="token punctuation">.</span>IP<span class="token punctuation">&#125;</span><span class="token comment">// Step 4: Create a sandbox for the pod if necessary.</span><span class="token comment">// 为pod创建sandbox，如果需要的话</span>podSandboxID <span class="token operator">:=</span> podContainerChanges<span class="token punctuation">.</span>SandboxID<span class="token keyword">if</span> podContainerChanges<span class="token punctuation">.</span>CreateSandbox <span class="token punctuation">&#123;</span><span class="token keyword">var</span> msg <span class="token builtin">string</span><span class="token keyword">var</span> err <span class="token builtin">error</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating sandbox for pod %q"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>createSandboxResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>CreatePodSandbox<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>createSandboxResult<span class="token punctuation">)</span>podSandboxID<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">createPodSandbox</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podContainerChanges<span class="token punctuation">.</span>Attempt<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>createSandboxResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ErrCreatePodSandbox<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"createPodSandbox for pod %q failed: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> ref<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>legacyscheme<span class="token punctuation">.</span>Scheme<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Couldn't make a ref to pod %q: '%v'"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedCreatePodSandBox<span class="token punctuation">,</span> <span class="token string">"Failed create pod sandbox."</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Created PodSandbox %q for pod %q"</span><span class="token punctuation">,</span> podSandboxID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>podSandboxStatus<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>runtimeService<span class="token punctuation">.</span><span class="token function">PodSandboxStatus</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> ref<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>legacyscheme<span class="token punctuation">.</span>Scheme<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Couldn't make a ref to pod %q: '%v'"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedStatusPodSandBox<span class="token punctuation">,</span> <span class="token string">"Unable to get pod sandbox status: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to get pod sandbox status: %v; Skipping pod %q"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// If we ever allow updating a pod from non-host-network to</span><span class="token comment">// host-network, we may use a stale IP.</span><span class="token keyword">if</span> <span class="token operator">!</span>kubecontainer<span class="token punctuation">.</span><span class="token function">IsHostNetworkPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Overwrite the podIP passed in the pod status, since we just started the pod sandbox.</span>podIP <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">determinePodSandboxIP</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> podSandboxStatus<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Determined the ip %q for pod %q after sandbox changed"</span><span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Get podSandboxConfig for containers to start.</span>configPodSandboxResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ConfigPodSandbox<span class="token punctuation">,</span> podSandboxID<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>configPodSandboxResult<span class="token punctuation">)</span><span class="token comment">//生成Sandbox的config配置，如pod的DNS、hostName、端口映射</span>podSandboxConfig<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">generatePodSandboxConfig</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> podContainerChanges<span class="token punctuation">.</span>Attempt<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>message <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"GeneratePodSandboxConfig for pod %q failed: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>configPodSandboxResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ErrConfigPodSandbox<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 5: start the init container.</span><span class="token comment">// 启动初始化容器</span><span class="token keyword">if</span> container <span class="token operator">:=</span> podContainerChanges<span class="token punctuation">.</span>NextInitContainerToStart<span class="token punctuation">;</span> container <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Start the next init container.</span>startContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>StartContainer<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>startContainerResult<span class="token punctuation">)</span>isInBackOff<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">doBackOff</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> backOff<span class="token punctuation">)</span><span class="token keyword">if</span> isInBackOff <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Backing Off restarting init container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating init container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 启动</span><span class="token keyword">if</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"init container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// Successfully started the container; clear the entry in the failure</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Completed init container %q for pod %q"</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 6: start containers in podContainerChanges.ContainersToStart.</span><span class="token comment">// 启动主容器</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> idx <span class="token operator">:=</span> <span class="token keyword">range</span> podContainerChanges<span class="token punctuation">.</span>ContainersToStart <span class="token punctuation">&#123;</span>container <span class="token operator">:=</span> <span class="token operator">&amp;</span>pod<span class="token punctuation">.</span>Spec<span class="token punctuation">.</span>Containers<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>startContainerResult <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">NewSyncResult</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>StartContainer<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>result<span class="token punctuation">.</span><span class="token function">AddSyncResult</span><span class="token punctuation">(</span>startContainerResult<span class="token punctuation">)</span>isInBackOff<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">doBackOff</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> backOff<span class="token punctuation">)</span><span class="token keyword">if</span> isInBackOff <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Backing Off restarting container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Creating container %+v in pod %v"</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 启动</span><span class="token keyword">if</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token comment">// known errors that are logged in other places are logged at higher levels here to avoid</span><span class="token comment">// repetitive log spam</span><span class="token keyword">switch</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> err <span class="token operator">==</span> images<span class="token punctuation">.</span>ErrImagePullBackOff<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的主要工作如下：</p><p>​    1&gt; 首先会调用<code>computePodActions</code>计算一下有哪些Pod Spec中的变化，实际上就是一些是否需要执行动作。将这些变换记录在<code>podContainerChanges</code>中，是一个<code>podActions</code>结构，该结构源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// podActions keeps information what to do for a pod.</span><span class="token keyword">type</span> podActions <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Stop all running (regular and init) containers and the sandbox for the pod.</span>KillPod <span class="token builtin">bool</span><span class="token comment">// Whether need to create a new sandbox. If needed to kill pod and create a</span><span class="token comment">// a new pod sandbox, all init containers need to be purged (i.e., removed).</span>CreateSandbox <span class="token builtin">bool</span><span class="token comment">// The id of existing sandbox. It is used for starting containers in ContainersToStart.</span>SandboxID <span class="token builtin">string</span><span class="token comment">// The attempt number of creating sandboxes for the pod.</span>Attempt <span class="token builtin">uint32</span><span class="token comment">// The next init container to start.</span>NextInitContainerToStart <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token comment">// ContainersToStart keeps a list of indexes for the containers to start,</span><span class="token comment">// where the index is the index of the specific container in the pod spec (</span><span class="token comment">// pod.Spec.Containers.</span>ContainersToStart <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment">// ContainersToKill keeps a map of containers that need to be killed, note that</span><span class="token comment">// the key is the container ID of the container, while</span><span class="token comment">// the value contains necessary information to kill a container.</span>ContainersToKill <span class="token keyword">map</span><span class="token punctuation">[</span>kubecontainer<span class="token punctuation">.</span>ContainerID<span class="token punctuation">]</span>containerToKillInfo<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，依次按照<code>podContainerChanges</code>中的字段，去做相应的动作。具体如下：</p><p>​    2&gt; kill掉<code>Sandbox</code>已经改变的Pod；</p><p>​    3&gt; 如果有container已改变，那么需要调用<code>killContainer</code>方法来kill掉<code>ContainersToKill</code>列表中的container；</p><p>​    4&gt; 调用<code>pruneInitContainersBeforeStart</code>方法清理一些的<code>Init Container</code>，这其实是一种优化，以减轻容器垃圾收集器的负担；</p><p>​    5&gt; 调用<code>createPodSandbox</code>，方法，创建需要被创建的<code>Sandbox</code>；</p><p>​    6&gt; 生成<code>Sandbox</code>的config配置，如Pod的DNS、hostName、端口映射等等；</p><p>​    7&gt; 启动<code>Init Container</code>；</p><p>​    8&gt; 遍历<code>ContainersToStart</code>，启动容器列表；</p><p>不管是<code>Init Container</code>还是普通的Container，启动它都需要调用<code>startContainer</code>来实现。该方法位于：<code>pkg/kubelet/kuberuntime/kuberuntime_container.go</code>中，进去看看：</p><h4 id="startContainer"><a href="#startContainer" class="headerlink" title="startContainer"></a>startContainer</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID <span class="token builtin">string</span><span class="token punctuation">,</span> podSandboxConfig <span class="token operator">*</span>runtimeapi<span class="token punctuation">.</span>PodSandboxConfig<span class="token punctuation">,</span> container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">,</span> pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> podStatus <span class="token operator">*</span>kubecontainer<span class="token punctuation">.</span>PodStatus<span class="token punctuation">,</span> pullSecrets <span class="token punctuation">[</span><span class="token punctuation">]</span>v1<span class="token punctuation">.</span>Secret<span class="token punctuation">,</span> podIP <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Step 1: pull the image.</span><span class="token comment">// 拉取镜像</span>imageRef<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>imagePuller<span class="token punctuation">.</span><span class="token function">EnsureImageExists</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreateContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// Step 2: create the container.</span><span class="token comment">// 开始创建container</span>ref<span class="token punctuation">,</span> err <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span><span class="token function">GenerateContainerRef</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Can't make a ref to pod %q, container %v: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Generating ref for container %s: %#v"</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token comment">// For a new container, the RestartCount should be 0</span><span class="token comment">// 如果是个新的container，那么restartCount应该为0</span>restartCount <span class="token operator">:=</span> <span class="token number">0</span>containerStatus <span class="token operator">:=</span> podStatus<span class="token punctuation">.</span><span class="token function">FindContainerStatusByName</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token keyword">if</span> containerStatus <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>restartCount <span class="token operator">=</span> containerStatus<span class="token punctuation">.</span>RestartCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">// 生成Container config</span>containerConfig<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">generateContainerConfig</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> restartCount<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> imageRef<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreateContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> ErrCreateContainerConfig<span class="token punctuation">&#125;</span><span class="token comment">// 调用CRI接口创建Container</span>containerID<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>runtimeService<span class="token punctuation">.</span><span class="token function">CreateContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> containerConfig<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToCreateContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> ErrCreateContainer<span class="token punctuation">&#125;</span><span class="token comment">// 调用生命周期的钩子，预启动Pre Start Container</span>err <span class="token operator">=</span> m<span class="token punctuation">.</span>internalLifecycle<span class="token punctuation">.</span><span class="token function">PreStartContainer</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToStartContainer<span class="token punctuation">,</span> <span class="token string">"Internal PreStartContainer hook failed: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token string">"Internal PreStartContainer hook failed"</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeNormal<span class="token punctuation">,</span> events<span class="token punctuation">.</span>CreatedContainer<span class="token punctuation">,</span> <span class="token string">"Created container"</span><span class="token punctuation">)</span><span class="token keyword">if</span> ref <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span>containerRefManager<span class="token punctuation">.</span><span class="token function">SetRef</span><span class="token punctuation">(</span>kubecontainer<span class="token punctuation">.</span>ContainerID<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> m<span class="token punctuation">.</span>runtimeName<span class="token punctuation">,</span>ID<span class="token punctuation">:</span>   containerID<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 3: start the container.</span><span class="token comment">// 调用CRI接口启动container</span>err <span class="token operator">=</span> m<span class="token punctuation">.</span>runtimeService<span class="token punctuation">.</span><span class="token function">StartContainer</span><span class="token punctuation">(</span>containerID<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToStartContainer<span class="token punctuation">,</span> <span class="token string">"Error: %v"</span><span class="token punctuation">,</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> grpc<span class="token punctuation">.</span><span class="token function">ErrorDesc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> kubecontainer<span class="token punctuation">.</span>ErrRunContainer<span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeNormal<span class="token punctuation">,</span> events<span class="token punctuation">.</span>StartedContainer<span class="token punctuation">,</span> <span class="token string">"Started container"</span><span class="token punctuation">)</span><span class="token comment">// Symlink container logs to the legacy container log location for cluster logging</span><span class="token comment">// support.</span><span class="token comment">// TODO(random-liu): Remove this after cluster logging supports CRI container log path.</span>containerMeta <span class="token operator">:=</span> containerConfig<span class="token punctuation">.</span><span class="token function">GetMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span>sandboxMeta <span class="token operator">:=</span> podSandboxConfig<span class="token punctuation">.</span><span class="token function">GetMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span>legacySymlink <span class="token operator">:=</span> <span class="token function">legacyLogSymlink</span><span class="token punctuation">(</span>containerID<span class="token punctuation">,</span> containerMeta<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> sandboxMeta<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>sandboxMeta<span class="token punctuation">.</span>Namespace<span class="token punctuation">)</span>containerLog <span class="token operator">:=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>podSandboxConfig<span class="token punctuation">.</span>LogDirectory<span class="token punctuation">,</span> containerConfig<span class="token punctuation">.</span>LogPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span>osInterface<span class="token punctuation">.</span><span class="token function">Symlink</span><span class="token punctuation">(</span>containerLog<span class="token punctuation">,</span> legacySymlink<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to create legacy symbolic link %q to container %q log %q: %v"</span><span class="token punctuation">,</span>legacySymlink<span class="token punctuation">,</span> containerID<span class="token punctuation">,</span> containerLog<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Step 4: execute the post start hook.</span><span class="token comment">// 依然是调用生命周期中设置的钩子 post start</span><span class="token keyword">if</span> container<span class="token punctuation">.</span>Lifecycle <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> container<span class="token punctuation">.</span>Lifecycle<span class="token punctuation">.</span>PostStart <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kubeContainerID <span class="token operator">:=</span> kubecontainer<span class="token punctuation">.</span>ContainerID<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> m<span class="token punctuation">.</span>runtimeName<span class="token punctuation">,</span>ID<span class="token punctuation">:</span>   containerID<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 执行预处理工作</span>msg<span class="token punctuation">,</span> handlerErr <span class="token operator">:=</span> m<span class="token punctuation">.</span>runner<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>kubeContainerID<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Lifecycle<span class="token punctuation">.</span>PostStart<span class="token punctuation">)</span><span class="token keyword">if</span> handlerErr <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>m<span class="token punctuation">.</span><span class="token function">recordContainerEvent</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> container<span class="token punctuation">,</span> kubeContainerID<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedPostStartHook<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token comment">// 如果预处理失败，那么需要kill掉Container</span><span class="token keyword">if</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">killContainer</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kubeContainerID<span class="token punctuation">,</span> container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token string">"FailedPostStartHook"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to kill container %q(id=%q) in pod %q: %v, %v"</span><span class="token punctuation">,</span>container<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> kubeContainerID<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> ErrPostStartHook<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> msg<span class="token punctuation">,</span> ErrPostStartHook<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法还是比较清晰的：</p><p>​    1&gt; 拉取container需要的镜像；</p><p>​    2&gt; 计算一下container重启次数，如果是首次创建，那么应该是0；</p><p>​    3&gt; 生成<code>container config</code>，用于创建container；</p><p>​    4&gt; 调用CRI接口<code>CreateContainer</code>来创建container；</p><p>​    5&gt; 在启动之前调用<code>PreStartContainer</code>做好预处理工作；</p><p>​    6&gt; 调用CRI接口<code>StartContainer</code>启动container；</p><p>​    7&gt; 调用声明周期中设置的钩子<code>post start</code>；</p><p>至此，一个<code>dispathWork</code>的Pod创建工作基本完成，当Pods内的每个Pod都用这种方式创建完成，Pods即创建成功。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用一张图总结Pod(s)的创建流程。</p><p><img src="https://i.bmp.ovh/imgs/2022/03/8287ee100f9d8b7d.png"></p><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] <a href="https://www.cnblogs.com/luozhiyun/p/13736569.html">https://www.cnblogs.com/luozhiyun/p/13736569.html</a></p><p>[2] <a href="https://kubernetes.io/docs/concepts/workloads/pods/">https://kubernetes.io/docs/concepts/workloads/pods/</a></p><p>[3] Kubelet源码</p>]]></content>
      
      
      <categories>
          
          <category> k8s源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> kubelet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逃逸: CVE-2017-1002101</title>
      <link href="/tao-yi-cve-2017-1002101/"/>
      <url>/tao-yi-cve-2017-1002101/</url>
      
        <content type="html"><![CDATA[<p>CVE-2017-1002101漏洞能让Kubelet创建的Pod挂载到宿主机中不允许挂载的目录，从而造成了逃逸。这听上去很不可思议，因为完全可以在<code>PSP(Pod Security Policies)</code>中限制Pod对主机目录的挂载权限。是的没错，我们可以通过PSP限制Pod只能挂载特定的安全目录，对于其他目录都不允许挂载。但是，至少在k8s<code>v1.9.4</code>版本之前，这种逃逸攻击都是可行的。其核心，就是Linux的<code>软连接</code>和k8s的<code>volume subPath</code>。</p><span id="more"></span><p>软连接不用说，说一下<code>subPath</code>。没创建一个<code>volume</code>，它就会挂载到宿主机中指定的目录，将这个目录称为<code>hostPath</code>。但是，如果希望让不同的Pod或者同一个Pod下不同的容器挂载到该volume下的不同<code>子目录</code>，怎么实现？答案就是<code>subPath</code>。以同一个<code>LAMP Pod(Linux Apache Mysql PHP)</code>下的不同容器为例，我们可以让整个Pod挂载到指定volume下，但是让mysql的工作目录挂载到该volume的mysql子目录下，让html的资源目录挂载到该volume的html子目录中。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>lamp<span class="token punctuation">-</span>site<span class="token key atrule">spec</span><span class="token punctuation">:</span>    <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql      <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql      <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MYSQL_ROOT_PASSWORD        <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"rootpasswd"</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/lib/mysql        <span class="token key atrule">name</span><span class="token punctuation">:</span> site<span class="token punctuation">-</span>data        <span class="token key atrule">subPath</span><span class="token punctuation">:</span> mysql    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> php      <span class="token key atrule">image</span><span class="token punctuation">:</span> php<span class="token punctuation">:</span>7.0<span class="token punctuation">-</span>apache      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/www/html        <span class="token key atrule">name</span><span class="token punctuation">:</span> site<span class="token punctuation">-</span>data        <span class="token key atrule">subPath</span><span class="token punctuation">:</span> html    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> site<span class="token punctuation">-</span>data      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>lamp<span class="token punctuation">-</span>site<span class="token punctuation">-</span>data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，一个Pod或是容器，具体挂载进宿主机下的哪个目录，是通过<code>hostPath</code>+<code>subPath</code>来决定的。当然，默认情况下<code>subPath</code>为空。</p><p>至于为什么<code>subPath</code>配合<code>软连接</code>可以让Pod挂载到权限之外的目录，就要从Kublet源码开始分析，深入了解一下创建Pod时，volume是如何创建和挂载的。</p><hr><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Pod创建过程"><a href="#Pod创建过程" class="headerlink" title="Pod创建过程"></a>Pod创建过程</h4><p>这里使用的k8s版本为<code>v1.9.3</code>，git commit为<code>d2835416544</code>。比较老，因为这个漏洞比较早。</p><img src="https://i.bmp.ovh/imgs/2022/01/5089f514aabe5eeb.png"  /><p>可以看到，kubelet 的工作核心，就是一个控制循环，即：<code>SyncLoop</code>。驱动整个控制循环的事件有：pod更新事件、pod生命周期变化、kubelet本身设置的执行周期、定时清理事件等。在SyncLoop循环上还有很多Manager，例如probeManager 会定时去监控 pod 中容器的健康状况、statusManager 负责维护状态信息，并把 pod 状态更新到 apiserver、ontainerRefManager 容器引用的管理等等。不过这些Manage在这里先不管，只聚焦于Pod的创建。</p><p>整个Kubelet的启动，都记录在<code>kubernetes\pkg\kubelet\kubelet.go</code>文件中的<code>Run</code>方法中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Run starts the kubelet reacting to config updates</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">Run</span><span class="token punctuation">(</span>updates <span class="token operator">&lt;-</span><span class="token keyword">chan</span> kubetypes<span class="token punctuation">.</span>PodUpdate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//注册 logServer</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>logServer <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>logServer <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">StripPrefix</span><span class="token punctuation">(</span><span class="token string">"/logs/"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">FileServer</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">Dir</span><span class="token punctuation">(</span><span class="token string">"/var/log/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>kubeClient <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Warning</span><span class="token punctuation">(</span><span class="token string">"No api server defined - no node status update will be sent."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">initializeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>nodeRef<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>KubeletSetupFailed<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Start volume manager</span><span class="token keyword">go</span> kl<span class="token punctuation">.</span>volumeManager<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>sourcesReady<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>kubeClient <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Start syncing node status immediately, this may set up things the runtime needs to run.</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>syncNodeStatus<span class="token punctuation">,</span> kl<span class="token punctuation">.</span>nodeStatusUpdateFrequency<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>syncNetworkStatus<span class="token punctuation">,</span> <span class="token number">30</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>updateRuntimeUp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token comment">// Start loop to sync iptables util rules</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>makeIPTablesUtilChains <span class="token punctuation">&#123;</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>syncNetworkUtil<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Minute<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Start a goroutine responsible for killing pods (that are not properly</span><span class="token comment">// handled by pod workers).</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>podKiller<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token comment">// Start gorouting responsible for checking limits in resolv.conf</span><span class="token keyword">if</span> kl<span class="token punctuation">.</span>dnsConfigurer<span class="token punctuation">.</span>ResolverConfig <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> kl<span class="token punctuation">.</span>dnsConfigurer<span class="token punctuation">.</span><span class="token function">CheckLimitsForResolvConf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> wait<span class="token punctuation">.</span>NeverStop<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Start component sync loops.</span>kl<span class="token punctuation">.</span>statusManager<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>kl<span class="token punctuation">.</span>probeManager<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Start the pod lifecycle event generator.</span>    <span class="token comment">//启动 pleg 该模块主要用于周期性地向 container runtime 刷新当前所有容器的状态</span>kl<span class="token punctuation">.</span>pleg<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>kl<span class="token punctuation">.</span><span class="token function">syncLoop</span><span class="token punctuation">(</span>updates<span class="token punctuation">,</span> kl<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Run</code>方法以<code>kl.syncLoop</code>方法结尾。实际上，它是通过最后调用<code>kl.syncLoop</code>来启动事件循环，循环的监听管道信息，而我们要的Pod创建代码，就在其中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// in pkg/kubelet/kubelet.go</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncLoop</span><span class="token punctuation">(</span>updates <span class="token operator">&lt;-</span><span class="token keyword">chan</span> kubetypes<span class="token punctuation">.</span>PodUpdate<span class="token punctuation">,</span> handler SyncHandler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"Starting kubelet main sync loop."</span><span class="token punctuation">)</span><span class="token comment">// The resyncTicker wakes up kubelet to checks if there are any pod workers</span><span class="token comment">// that need to be sync'd. A one-second period is sufficient because the</span><span class="token comment">// sync interval is defaulted to 10s.</span>syncTicker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">defer</span> syncTicker<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>housekeepingTicker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>housekeepingPeriod<span class="token punctuation">)</span><span class="token keyword">defer</span> housekeepingTicker<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>plegCh <span class="token operator">:=</span> kl<span class="token punctuation">.</span>pleg<span class="token punctuation">.</span><span class="token function">Watch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> rs <span class="token operator">:=</span> kl<span class="token punctuation">.</span>runtimeState<span class="token punctuation">.</span><span class="token function">runtimeErrors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"skipping pod synchronization - %v"</span><span class="token punctuation">,</span> rs<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>kl<span class="token punctuation">.</span>syncLoopMonitor<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">syncLoopIteration</span><span class="token punctuation">(</span>updates<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> syncTicker<span class="token punctuation">.</span>C<span class="token punctuation">,</span> housekeepingTicker<span class="token punctuation">.</span>C<span class="token punctuation">,</span> plegCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>kl<span class="token punctuation">.</span>syncLoopMonitor<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的主要逻辑在<code>kl.syncLoopIteration</code>中实现，点进去，查看和Pod增删改有关的核心代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// in pkg/kubelet/kubelet.go</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncLoopIteration</span><span class="token punctuation">(</span>configCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> kubetypes<span class="token punctuation">.</span>PodUpdate<span class="token punctuation">,</span> handler SyncHandler<span class="token punctuation">,</span>syncCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> housekeepingCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> plegCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>pleg<span class="token punctuation">.</span>PodLifecycleEvent<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> u<span class="token punctuation">,</span> open <span class="token operator">:=</span> <span class="token operator">&lt;-</span>configCh<span class="token punctuation">:</span><span class="token comment">// Update from a config source; dispatch it to the right handler</span><span class="token comment">// callback.</span><span class="token keyword">if</span> <span class="token operator">!</span>open <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Update channel is closed. Exiting the sync loop."</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> u<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>ADD<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (ADD, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// After restarting, kubelet will get all existing pods through</span><span class="token comment">// ADD as if they are new pods. These pods will then go through the</span><span class="token comment">// admission process and *may* be rejected. This can be resolved</span><span class="token comment">// once we have checkpointing.</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodAdditions</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>UPDATE<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (UPDATE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">PodsWithDeletiontimestamps</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodUpdates</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>REMOVE<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (REMOVE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodRemoves</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>RECONCILE<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (RECONCILE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodReconcile</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>DELETE<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (DELETE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// DELETE is treated as a UPDATE because of graceful deletion.</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodUpdates</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>RESTORE<span class="token punctuation">:</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"SyncLoop (RESTORE, %q): %q"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Source<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// These are pods restored from the checkpoint. Treat them as new</span><span class="token comment">// pods.</span>handler<span class="token punctuation">.</span><span class="token function">HandlePodAdditions</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Pods<span class="token punctuation">)</span><span class="token keyword">case</span> kubetypes<span class="token punctuation">.</span>SET<span class="token punctuation">:</span><span class="token comment">// TODO: Do we want to support this?</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Kubelet does not support snapshot update"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>   <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该模块将同时监视Pod 信息的变化，一旦某个来源的 Pod 信息发生了更新（创建/更新/删除），这个 channel 中就会出现被更新的 Pod 信息和更新的具体操作。</p><p>其中，<code>HandlePodAdditions</code>就是创建Pod的接口，其实现体为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// in pkg/kubelet/kubelet.go</span><span class="token comment">// HandlePodAdditions is the callback in SyncHandler for pods being added from</span><span class="token comment">// a config source.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">HandlePodAdditions</span><span class="token punctuation">(</span>pods <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>start <span class="token operator">:=</span> kl<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>sliceutils<span class="token punctuation">.</span><span class="token function">PodsByCreationTime</span><span class="token punctuation">(</span>pods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> pod <span class="token operator">:=</span> <span class="token keyword">range</span> pods <span class="token punctuation">&#123;</span>existingPods <span class="token operator">:=</span> kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">GetPods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span><span class="token comment">// manager as the source of truth for the desired state. If a pod does</span><span class="token comment">// not exist in the pod manager, it means that it has been deleted in</span><span class="token comment">// the apiserver and no action (other than cleanup) is required.</span>kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">AddPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token keyword">if</span> kubepod<span class="token punctuation">.</span><span class="token function">IsMirrorPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span><span class="token function">handleMirrorPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Only go through the admission process if the pod is not</span><span class="token comment">// terminated.</span><span class="token comment">// We failed pods that we rejected, so activePods include all admitted</span><span class="token comment">// pods that are alive.</span>activePods <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">filterOutTerminatedPods</span><span class="token punctuation">(</span>existingPods<span class="token punctuation">)</span><span class="token comment">// Check if we can admit the pod; if not, reject it.</span><span class="token keyword">if</span> ok<span class="token punctuation">,</span> reason<span class="token punctuation">,</span> message <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">canAdmitPod</span><span class="token punctuation">(</span>activePods<span class="token punctuation">,</span> pod<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span><span class="token function">rejectPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> reason<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>mirrorPod<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> kl<span class="token punctuation">.</span>podManager<span class="token punctuation">.</span><span class="token function">GetMirrorPodByPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span>        <span class="token comment">//把 pod 分配给给 worker 做异步处理,创建pod</span>kl<span class="token punctuation">.</span><span class="token function">dispatchWork</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kubetypes<span class="token punctuation">.</span>SyncPodCreate<span class="token punctuation">,</span> mirrorPod<span class="token punctuation">,</span> start<span class="token punctuation">)</span>kl<span class="token punctuation">.</span>probeManager<span class="token punctuation">.</span><span class="token function">AddPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其主要任务为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> 按照创建时间给pods进行排序；<span class="token operator">></span> 将pod添加到pod管理器中，如果有pod不存在在pod管理器中，那么这个pod表示已经被删除了；<span class="token operator">></span> 校验pod 是否能在该节点运行，如果不可以直接拒绝；<span class="token operator">></span> 调用dispatchWork把 pod 分配给给 worker 做异步处理,创建pod；<span class="token operator">></span> 将pod添加到probeManager中，如果 pod 中定义了 readiness 和 liveness 健康检查，启动 <span class="token operator">></span> goroutine 定期进行检测；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，真正创建Pod的其实是方法<code>dispatchWork</code>，其核心代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// in pkg/kubelet/kubelet.go</span><span class="token comment">// dispatchWork starts the asynchronous sync of the pod in a pod worker.</span><span class="token comment">// If the pod is terminated, dispatchWork</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">dispatchWork</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> syncType kubetypes<span class="token punctuation">.</span>SyncPodType<span class="token punctuation">,</span> mirrorPod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> start time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token comment">// Run the sync in an async worker.</span>kl<span class="token punctuation">.</span>podWorkers<span class="token punctuation">.</span><span class="token function">UpdatePod</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>UpdatePodOptions<span class="token punctuation">&#123;</span>Pod<span class="token punctuation">:</span>        pod<span class="token punctuation">,</span>MirrorPod<span class="token punctuation">:</span>  mirrorPod<span class="token punctuation">,</span>UpdateType<span class="token punctuation">:</span> syncType<span class="token punctuation">,</span>OnCompleteFunc<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>metrics<span class="token punctuation">.</span>PodWorkerLatency<span class="token punctuation">.</span><span class="token function">WithLabelValues</span><span class="token punctuation">(</span>syncType<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span><span class="token function">SinceInMicroseconds</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，该方法会封装一个<code>UpdatePodOptions</code>结构体丢给<code>podWorkers.UpdatePod</code>去执行，该文件位于 pkg/kubelet/pod_workers.go 中。我们点进去看看：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Apply the new setting to the specified pod.</span><span class="token comment">// If the options provide an OnCompleteFunc, the function is invoked if the update is accepted.</span><span class="token comment">// Update requests are ignored if a kill pod request is pending.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>podWorkers<span class="token punctuation">)</span> <span class="token function">UpdatePod</span><span class="token punctuation">(</span>options <span class="token operator">*</span>UpdatePodOptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pod <span class="token operator">:=</span> options<span class="token punctuation">.</span>Poduid <span class="token operator">:=</span> pod<span class="token punctuation">.</span>UID<span class="token keyword">var</span> podUpdates <span class="token keyword">chan</span> UpdatePodOptions<span class="token keyword">var</span> exists <span class="token builtin">bool</span>p<span class="token punctuation">.</span>podLock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> p<span class="token punctuation">.</span>podLock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">//如果该pod在podUpdates数组里面不存在，那么就创建channel，并启动异步线程</span><span class="token keyword">if</span> podUpdates<span class="token punctuation">,</span> exists <span class="token operator">=</span> p<span class="token punctuation">.</span>podUpdates<span class="token punctuation">[</span>uid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>exists <span class="token punctuation">&#123;</span><span class="token comment">// We need to have a buffer here, because checkForUpdates() method that</span><span class="token comment">// puts an update into channel is called from the same goroutine where</span><span class="token comment">// the channel is consumed. However, it is guaranteed that in such case</span><span class="token comment">// the channel is empty, so buffer of size 1 is enough.</span>podUpdates <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> UpdatePodOptions<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>podUpdates<span class="token punctuation">[</span>uid<span class="token punctuation">]</span> <span class="token operator">=</span> podUpdates<span class="token comment">// Creating a new pod worker either means this is a new pod, or that the</span><span class="token comment">// kubelet just restarted. In either case the kubelet is willing to believe</span><span class="token comment">// the status of the pod for the first pod worker sync. See corresponding</span><span class="token comment">// comment in syncPod.</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> runtime<span class="token punctuation">.</span><span class="token function">HandleCrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">managePodLoop</span><span class="token punctuation">(</span>podUpdates<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>isWorking<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>isWorking<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>podUpdates <span class="token operator">&lt;-</span> <span class="token operator">*</span>options<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// if a request to kill a pod is pending, we do not let anything overwrite that request.</span>update<span class="token punctuation">,</span> found <span class="token operator">:=</span> p<span class="token punctuation">.</span>lastUndeliveredWorkUpdate<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token operator">!</span>found <span class="token operator">||</span> update<span class="token punctuation">.</span>UpdateType <span class="token operator">!=</span> kubetypes<span class="token punctuation">.</span>SyncPodKill <span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>lastUndeliveredWorkUpdate<span class="token punctuation">[</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>options<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法会加锁之后获取<code>podUpdates</code>数组里面数据，如果不存在那么会创建一个channel然后执行一个异步协程，我们进入<code>managePodLoop</code>来看看：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>podWorkers<span class="token punctuation">)</span> <span class="token function">managePodLoop</span><span class="token punctuation">(</span>podUpdates <span class="token operator">&lt;-</span><span class="token keyword">chan</span> UpdatePodOptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> lastSyncTime time<span class="token punctuation">.</span>Time<span class="token keyword">for</span> update <span class="token operator">:=</span> <span class="token keyword">range</span> podUpdates <span class="token punctuation">&#123;</span>err <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>podUID <span class="token operator">:=</span> update<span class="token punctuation">.</span>Pod<span class="token punctuation">.</span>UID<span class="token comment">// This is a blocking call that would return only if the cache</span><span class="token comment">// has an entry for the pod that is newer than minRuntimeCache</span><span class="token comment">// Time. This ensures the worker doesn't start syncing until</span><span class="token comment">// after the cache is at least newer than the finished time of</span><span class="token comment">// the previous sync.</span>status<span class="token punctuation">,</span> err <span class="token operator">:=</span> p<span class="token punctuation">.</span>podCache<span class="token punctuation">.</span><span class="token function">GetNewerThan</span><span class="token punctuation">(</span>podUID<span class="token punctuation">,</span> lastSyncTime<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// This is the legacy event thrown by manage pod loop</span><span class="token comment">// all other events are now dispatched from syncPodFn</span>p<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedSync<span class="token punctuation">,</span> <span class="token string">"error determining status: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span>err <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">syncPodFn</span><span class="token punctuation">(</span>syncPodOptions<span class="token punctuation">&#123;</span>mirrorPod<span class="token punctuation">:</span>      update<span class="token punctuation">.</span>MirrorPod<span class="token punctuation">,</span>pod<span class="token punctuation">:</span>            update<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span>podStatus<span class="token punctuation">:</span>      status<span class="token punctuation">,</span>killPodOptions<span class="token punctuation">:</span> update<span class="token punctuation">.</span>KillPodOptions<span class="token punctuation">,</span>updateType<span class="token punctuation">:</span>     update<span class="token punctuation">.</span>UpdateType<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>lastSyncTime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// notify the call-back function if the operation succeeded or not</span><span class="token keyword">if</span> update<span class="token punctuation">.</span>OnCompleteFunc <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>update<span class="token punctuation">.</span><span class="token function">OnCompleteFunc</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// IMPORTANT: we do not log errors here, the syncPodFn is responsible for logging errors</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Error syncing pod %s (%q), skipping: %v"</span><span class="token punctuation">,</span> update<span class="token punctuation">.</span>Pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>p<span class="token punctuation">.</span><span class="token function">wrapUp</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>Pod<span class="token punctuation">.</span>UID<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法会遍历channel里面的数据，然后调用<code>syncPodFn</code>方法并传入一个<code>syncPodOptions</code>。syncPodFn是啥？实际上，kubelet会在执行<code>NewMainKubelet</code>方法时调用<code>newPodWorkers</code>方法，将syncPodFn设置为 pkg/kubelet/kubelet.go 下的<code>syncPod</code>方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewMainKubelet</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">...</span>klet <span class="token operator">:=</span> <span class="token operator">&amp;</span>Kubelet<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token operator">...</span>klet<span class="token punctuation">.</span>podWorkers <span class="token operator">=</span> <span class="token function">newPodWorkers</span><span class="token punctuation">(</span>klet<span class="token punctuation">.</span>syncPod<span class="token punctuation">,</span> kubeDeps<span class="token punctuation">.</span>Recorder<span class="token punctuation">,</span> klet<span class="token punctuation">.</span>workQueue<span class="token punctuation">,</span> klet<span class="token punctuation">.</span>resyncInterval<span class="token punctuation">,</span> backOffPeriod<span class="token punctuation">,</span> klet<span class="token punctuation">.</span>podCache<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们的重点，来到了<code>syncPod</code>中。该方法进行的工作很多很多，不过我都不知道…，以后在学吧。在该方法的注释中，这样解释到：</p><blockquote><p>// The workflow is:<br>// * If the pod is being created, record pod worker start latency<br>// * Call generateAPIPodStatus to prepare an v1.PodStatus for the pod<br>// * If the pod is being seen as running for the first time, record pod<br>//   start latency<br>// * Update the status of the pod in the status manager<br>// * Kill the pod if it should not be running<br>// * Create a mirror pod if the pod is a static pod, and does not<br>//   already have a mirror pod<br>// * Create the data directories for the pod if they do not exist<br>// * Wait for volumes to attach/mount<br>// * Fetch the pull secrets for the pod<br>// * Call the container runtime’s SyncPod callback<br>// * Update the traffic shaping for the pod’s ingress and egress limits<br>//<br>// If any step of this workflow errors, the error is returned, and is repeated<br>// on the next syncPod call.</p></blockquote><p>这些东西我们先不管，现在只需要知道，该方法会完成Pod基础目录创建（包括和volume有关的）以及对volume的挂载。也就是说，和本漏洞有关的代码，从这里开始！</p><h4 id="Volume挂载过程"><a href="#Volume挂载过程" class="headerlink" title="Volume挂载过程"></a>Volume挂载过程</h4><p>在一个Pod开始运行前，k8s需要做许多事情。首先，Kubelet为Pod在宿主机上创建了一个基础目录:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">syncPod</span><span class="token punctuation">(</span>o syncPodOptions<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token comment">// Make data directories for the pod</span><span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span><span class="token function">makePodDataDirs</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedToMakePodDataDirectories<span class="token punctuation">,</span> <span class="token string">"error making pod data directories: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to make pod data directories for pod %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span>       <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>syncPod</code>通过调用<code>makePodDataDirs</code>方法来为Pod创建基础目录，我们跟进看看：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// makePodDataDirs creates the dirs for the pod datas.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>kl <span class="token operator">*</span>Kubelet<span class="token punctuation">)</span> <span class="token function">makePodDataDirs</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>uid <span class="token operator">:=</span> pod<span class="token punctuation">.</span>UID<span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodDir</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>os<span class="token punctuation">.</span><span class="token function">IsExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodVolumesDir</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>os<span class="token punctuation">.</span><span class="token function">IsExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>kl<span class="token punctuation">.</span><span class="token function">getPodPluginsDir</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0750</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>os<span class="token punctuation">.</span><span class="token function">IsExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法一共调用了三次<code>MkdirAll</code>方法，其中第二次调用，就是关于<code>volume</code>目录的。接着，我们回到<code>synPod</code>，观察下一个方法调用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Volume manager will not mount volumes for terminated pods</span><span class="token keyword">if</span> <span class="token operator">!</span>kl<span class="token punctuation">.</span><span class="token function">podIsTerminated</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Wait for volumes to attach/mount</span>    <span class="token keyword">if</span> err <span class="token operator">:=</span> kl<span class="token punctuation">.</span>volumeManager<span class="token punctuation">.</span><span class="token function">WaitForAttachAndMount</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        kl<span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">Eventf</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> v1<span class="token punctuation">.</span>EventTypeWarning<span class="token punctuation">,</span> events<span class="token punctuation">.</span>FailedMountVolume<span class="token punctuation">,</span> <span class="token string">"Unable to mount volumes for pod %q: %v"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to mount volumes for pod %q: %v; skipping pod"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">Pod</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span> err    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，Kubelet在为Pod创建完基础目录后，会等待Kubelet Volume Manager（<code>pkg/kubelet/volumemanager</code>）将Pod声明文件中声明的卷挂载到上述Volumes目录下。</p><p>完成上述操作后，再回到<code>syncPod</code>中，它会调用<code>containerRuntime.SyncPod</code>，来真正的创建Pod。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Call the container runtime's SyncPod callback</span>result <span class="token operator">:=</span> kl<span class="token punctuation">.</span>containerRuntime<span class="token punctuation">.</span><span class="token function">SyncPod</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> apiPodStatus<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> kl<span class="token punctuation">.</span>backOff<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该文件位于 pkg/kubelet/kuberuntime/kuberuntime_manager.go。直接看该代码的第5步的核心部分：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>kubeGenericRuntimeManager<span class="token punctuation">)</span> <span class="token function">SyncPod</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token comment">// Step 5: start the init container.</span>    <span class="token operator">...</span>    <span class="token keyword">if</span> msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">startContainer</span><span class="token punctuation">(</span>podSandboxID<span class="token punctuation">,</span> podSandboxConfig<span class="token punctuation">,</span> container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> podStatus<span class="token punctuation">,</span> pullSecrets<span class="token punctuation">,</span> podIP<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>startContainerResult<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"init container start failed: %v: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>    <span class="token operator">...</span><span class="token operator">...</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入<code>startContainer</code>，发现其会调用<code>m.generateContainerConfig</code>来为<code>容器运行时</code>（Runtime）生成配置文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">containerConfig<span class="token punctuation">,</span> err <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">generateContainerConfig</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> pod<span class="token punctuation">,</span> restartCount<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> imageRef<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从<code>generateContainerConfig</code>一直往下追溯，直到位于 pkg/kubelet/kubelet_pods.go 中的<code>GenerateRunContainerOptions</code>方法。该方法会调用<code>makeMounts</code>来生成容器运行时的<code>挂载映射表</code>:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// in pkg/kubelet/kubelet_pods.go GenerateRunContainerOptions function</span>mounts<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">makeMounts</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> kl<span class="token punctuation">.</span><span class="token function">getPodDir</span><span class="token punctuation">(</span>pod<span class="token punctuation">.</span>UID<span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> hostDomainName<span class="token punctuation">,</span> podIP<span class="token punctuation">,</span> volumes<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而<code>makeMounts</code>，就是漏洞的关键所在。</p><hr><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>先进<code>makdMounts</code>里看下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// in pkg/kubelet/kubelet_pods.go</span><span class="token comment">// makeMounts determines the mount points for the given container.</span><span class="token keyword">func</span> <span class="token function">makeMounts</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">,</span> podDir <span class="token builtin">string</span><span class="token punctuation">,</span> container <span class="token operator">*</span>v1<span class="token punctuation">.</span>Container<span class="token punctuation">,</span> hostName<span class="token punctuation">,</span> hostDomain<span class="token punctuation">,</span> podIP <span class="token builtin">string</span><span class="token punctuation">,</span> podVolumes kubecontainer<span class="token punctuation">.</span>VolumeMap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>kubecontainer<span class="token punctuation">.</span>Mount<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>mounts <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>kubecontainer<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> mount <span class="token operator">:=</span> <span class="token keyword">range</span> container<span class="token punctuation">.</span>VolumeMounts <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>hostPath<span class="token punctuation">,</span> err <span class="token operator">:=</span> volume<span class="token punctuation">.</span><span class="token function">GetPath</span><span class="token punctuation">(</span>vol<span class="token punctuation">.</span>Mounter<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token keyword">if</span> mount<span class="token punctuation">.</span>SubPath <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> filepath<span class="token punctuation">.</span><span class="token function">IsAbs</span><span class="token punctuation">(</span>mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"error SubPath `%s` must not be an absolute path"</span><span class="token punctuation">,</span> mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>err <span class="token operator">=</span> volumevalidation<span class="token punctuation">.</span><span class="token function">ValidatePathNoBacksteps</span><span class="token punctuation">(</span>mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unable to provision SubPath `%s`: %v"</span><span class="token punctuation">,</span> mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fileinfo<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Lstat</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span>perm <span class="token operator">:=</span> fileinfo<span class="token punctuation">.</span><span class="token function">Mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 关键点1</span>hostPath <span class="token operator">=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> mount<span class="token punctuation">.</span>SubPath<span class="token punctuation">)</span><span class="token keyword">if</span> subPathExists<span class="token punctuation">,</span> err <span class="token operator">:=</span> utilfile<span class="token punctuation">.</span><span class="token function">FileOrSymlinkExists</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Could not determine if subPath %s exists; will not attempt to change its permissions"</span><span class="token punctuation">,</span> hostPath<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token operator">!</span>subPathExists <span class="token punctuation">&#123;</span><span class="token comment">// Create the sub path now because if it's auto-created later when referenced, it may have an</span><span class="token comment">// incorrect ownership and mode. For example, the sub path directory must have at least g+rwx</span><span class="token comment">// when the pod specifies an fsGroup, and if the directory is not created here, Docker will</span><span class="token comment">// later auto-create it with the incorrect mode 0750</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>glog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"failed to mkdir:%s"</span><span class="token punctuation">,</span> hostPath<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// chmod the sub path because umask may have prevented us from making the sub path with the same</span><span class="token comment">// permissions as the mounter path</span><span class="token keyword">if</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Chmod</span><span class="token punctuation">(</span>hostPath<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// ...</span>        <span class="token comment">// 关键点2</span>mounts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>mounts<span class="token punctuation">,</span> kubecontainer<span class="token punctuation">.</span>Mount<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span>           mount<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>ContainerPath<span class="token punctuation">:</span>  containerPath<span class="token punctuation">,</span>HostPath<span class="token punctuation">:</span>       hostPath<span class="token punctuation">,</span>ReadOnly<span class="token punctuation">:</span>       mount<span class="token punctuation">.</span>ReadOnly<span class="token punctuation">,</span>SELinuxRelabel<span class="token punctuation">:</span> relabelVolume<span class="token punctuation">,</span>Propagation<span class="token punctuation">:</span>    propagation<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span><span class="token keyword">return</span> mounts<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，该方法体中就出现了<code>subPath</code>这个东西。现在来分析下，在生成挂载映射表时，它是怎么处理<code>hostPath</code>和<code>subPath</code>的。假设<code>subPath</code>不为空。</p><p>首先，检验<code>subPath</code>是否为绝对路径，如果是则err，因为子路径不能为绝对路径。然后，检验<code>subPath</code>中是否有<code>..</code>这个东西，也即是否有调用上级目录的行为，如果有，则err。后者的存在至关重要，正因为该检查，使Pod无法通过<code>合法挂载目录/../</code>的方法来进行逃逸。</p><p>然后就没了。它仅仅对<code>subPath</code>做了上述两步检查，随后就直接和<code>hostPath</code>进行拼接，得到<code>subPath的</code>绝对路径，并检验是否已存在。没错，仅仅就这两步。合并完成后，Kubelet将该绝对路径加入到挂载映射表（<code>mounts</code>变量）中，最终，该表被交给Runtime来创建容器。</p><p>在一般的Pod安全策略中，会限制Pod只能挂载指定目录的卷，假设为<code>/tmp/</code>。但是，它并不会现在Pod在该卷下的<code>subPath</code>，并且通过上述源码分析可知源码内部也没有进行什么限制。</p><p>问题来了，攻击者可以通过将<code>subPath</code>设成软连接的方式，在合法的<code>hostPaht</code>中逃逸到任何想去的宿主机目录中。</p><p>比如，攻击者首先创建一个<code>Pod1</code>，将容器内目录<code>/vuln</code>合法的挂载到<code>/tmp/test</code>下，现在，他在卷中创建一个软连接，使其指向宿主机的根目录<code>/</code>，命令很简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl <span class="token builtin class-name">exec</span> -it stage-1-container -- <span class="token function">ln</span> -s / /vuln/xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样一来，在宿主机的<code>/tmp/test</code>下就多出了指向<code>/</code>的软连接<code>xxx</code>。接下来，攻击者又创建了<code>Pod2</code>，并将<code>subPath</code>设为<code>xxx</code>。基于前面的分析，Kubelet会直接在宿主机上生成指向hostPath+subPath的路径传递给Runtime，致使<code>Pod2</code>的挂载目录直接跳到了宿主机的<code>/</code>处，实现逃逸！</p>]]></content>
      
      
      <categories>
          
          <category> k8s源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> k8s </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软硬链接</title>
      <link href="/linux-ruan-ying-lian-jie/"/>
      <url>/linux-ruan-ying-lian-jie/</url>
      
        <content type="html"><![CDATA[<p>在Linux中，ln命令会在文件之间创建链接，这种操作实际上是给系统中已有的某个文件指定另外一个可用于访问它的名称，看上去就像是Windows的快捷方式。但是，链接分为两种，一种叫作<code>硬链接(Hard Link) </code>，另一种叫作<code>符号链接(Symbolic Link)</code>，后者又称为软链接。实际上，软链接才真正像是Win中的快捷方式，而硬链接却大有不同。</p><span id="more"></span><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> -s <span class="token builtin class-name">source</span> dist <span class="token comment"># 建立软链接</span><span class="token function">ln</span> <span class="token builtin class-name">source</span> dist    <span class="token comment"># 建立硬链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>要想了解软硬链接的区别，就要先明白<code>inode</code>这一概念，这里简单阐述下。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做<code>扇区(Sector)</code>，每个扇区储存512字节。操作系统在读取硬盘的时候，不会一个个扇区去读，这样效率太低了，而是一次性连续读取多个扇区，即一次读取一个<code>块(block)</code>。这种由多个扇区组成的块，是文件存取的最小单位。<code>块</code>的大小，最常见的是4KB，即连续八个sector组成一个block。</p><p>文件数据都存储的<code>块</code>中，那么很显然，我们还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等，它们能够唯一的<code>标识</code>一个文件。这种存储文件元信息的区域就叫做<code>inode</code>，中文译名为<code>索引节点</code>。</p><p>对于一个文件来说，有唯一的<code>inode</code>与之对应，而对于一个<code>inode</code>而言，可以有<code>多个</code>文件名/路径与之对应。也就是说，一个<code>inode</code>唯一标识一个文件，但是找个文件可以有多种不同的访问路径。这里啰嗦一嘴，Linux下一切皆文件，包括目录、硬盘等等。</p><p>可以使用<code>ls -i example.txt</code>来查看某文件的inode编号，同样，可以使用<code>ls -li</code>来查看当前目录下所有文件的inode编号，第一列就是。</p><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/e7e444d37978f394.png"></p><hr><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>软连接实际上是通过名字来引用另外一个文件，类似于Windows的快捷方式。软连接和目标文件有着<code>不同的inode号</code>，也就是说软链接本身是一个独立的文件。可以理解为，软链接是一个独立文件，但是这个文件存储的是目标文件的路径，起到指针的作用。</p><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/15dfc1432e96b471.png"></p><p>当系统访问软链接后，会自动跳转到对应的目标文件处进行处理。当你使用<code>vim abc_s</code>对该文件进行更改时，实质上更改的是abc.txt，当再次打开abc.txt后，发现其内容就是你刚改的东西。</p><hr><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>硬链接和软链接大不相同。硬链接是通过<code>inode</code>引用另外一个文件，因此硬链接和目标文件具有<code>相同的inode号</code>。也就是说，软链接是一个独立文件，但是硬链接和目标文件本质上就是同一个，可以理解为一个实际文件有多个文件名。</p><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/edd13d190dd04be9.png"></p><p>硬链接与文件原有的名字是平权的，在Linux看来它们是等价的。由于这个原因，硬链接不能连接两个不同文件系统上的文件，但是软链接就可以跨文件系统。</p><p>每当我们为文件创建一个硬链接，该文件的硬链接数就是增加，上图中的2就是硬链接数。可以看到，因为abc_h和abc.txt本质上是一个文件，所以它们的硬链接数都为2。硬链接数也就表示的就是指有多少个文件的名字/路径和该文件的inode产生映射关系。<code>info ln</code>中这么解释硬链接：</p><blockquote><p> A “hard link” is another name for an existing file; the link and the<br>original are indistinguishable.  Technically speaking, they share the<br>same inode, and the inode contains all the information about a<br>file–indeed, it is not incorrect to say that the inode is the file.</p></blockquote><p>Linux是不允许用户将硬链接指向的<code>目录</code>的。但是，Linux一切皆文件，包括目录，因此目录理应也可以硬链接。实际上，目录是有硬链接的，只不过这个操作只能由系统完成，用户是不能进行的。</p><hr><h2 id="目录的硬链接"><a href="#目录的硬链接" class="headerlink" title="目录的硬链接"></a>目录的硬链接</h2><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/f10172dff4a76d0c.png"></p><p>可以看到，新创建的目录默认有两个硬链接数，说明有两条路径指向这个目录文件的inode。很显然，<code>/home/sakura/test/testDir</code>也即这个目录本身是一个，那么另一个是什么呢？</p><p>我们知道，每个目录都可以通过<code>.</code>来表明当前目录，也就是指向它自己。进入<code>testDir</code>内部，使用<code>ln -ali</code>来查看更详细的信息，发现<code>.</code>的inode号和<code>testDir</code>的inode号一模一样。也就是说，目录文件初始的两个硬链接，一个是其本身，另一个就是其下的<code>.</code></p><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/99fedeb837365ac9.png"></p><p>现在，我们在<code>testDir</code>下再新建一个目录，重新查看其硬链接数，发现变为了3。</p><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/89772db97f5081aa.png"></p><p>这是因为，新的目录下的<code>..</code>指向该目录的上级目录，就是<code>testDir</code>，它也是testDir的inode的一条路径，所以硬链接数变为了3。更一般的，一个新建的目录初始硬链接数为2，每当在该目录下新建一个子目录，其硬链接数就会加一，关系可以归为下图：</p><p><img src="/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/e3a1dcff818eb9d3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础(三): 容器数据卷</title>
      <link href="/docker-ji-chu-san-rong-qi-shu-ju-juan/"/>
      <url>/docker-ji-chu-san-rong-qi-shu-ju-juan/</url>
      
        <content type="html"><![CDATA[<p>想象一下，你的公司使用docker在容器中部署了一个电商项目，数据全部存在容器中。现在，你一不小心把这个容器删了，里面的数据全没了，再也无法恢复。完了，公司的核心资产被你搞没了，猜猜你能在牢里蹲多久？</p><span id="more"></span><h2 id="啥是数据卷"><a href="#啥是数据卷" class="headerlink" title="啥是数据卷"></a>啥是数据卷</h2><p>当然，一个公司业务不可能这么脆弱，但是容器天生就有数据不持久的特点，数据随容器即生即灭，那有什么方法能让其中的重要数据持久化呢？答案就是<code>备份</code>。前面讲过，docker可以通过cp命令和export将容器中的数据备份到主机上，这不失是一种方法。但是，这种操作是一次性的，也即每需要备份时都要手动执行一次，当业务大时，这是不可想象的。那么有没有一种办法，使容器中特定目录和主机之间建立一个持久性的联系，实现自动备份？有的，这就是docker容器数据卷，简称<code>容器卷</code>，或<code>数据卷</code>，或<code>卷</code>。</p><p>所谓卷，就是在主机的指定目录和容器内指定目录之间建立一个<code>双向</code>的管道，二者中的数据完全相同，且任意一者的更改都会同步到另一者之中，实现实时备份与数据共享。</p><blockquote><p><strong>数据卷(Data Volumes)<strong>是一个可供容器使用的特殊目录，它将主机OS目录直接映射进容器，类似于Linux的</strong>mount</strong>行为。</p><p>​    ■ 数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便；</p><p>​    ■ 对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</p><p>​    ■ 对数据卷的更新不会影响镜像，解耦开应用和数据；</p><p>​    ■ 卷会一直存在，直到没有容器使用，可以安全卸载它；</p></blockquote><hr><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><p>Docker提供<code>volume</code>子命令来管理数据卷，如下命令可以在本地创建一个名为test的数据卷：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> volume create -d <span class="token builtin class-name">local</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该数据卷存在本地主机的 <code>/var/lib/docker/volumes</code> 路径下，在该路径下会新建一个名为test的目录，就是创建的数据卷。使用<code>inspect</code>查看卷的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> voulme inpect <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到如下结果，</p><img src="https://i.bmp.ovh/imgs/2022/01/0569fbc976e494b7.png" style="zoom: 80%;" /><p>可以看到，<code>Mountpoint</code>值为<code>/var/lib/docker/volumes/test/_data</code>，说明改卷会将选定的容器目录映射进主机的该目录中。如果想要让容器使用该卷，使用<code>run -v test:...</code>来绑定该卷即可。</p><p>出来create和inspect，docker volume还支持<code>ls</code>（列出已有数据卷）、<code>prune</code>（清理无用数据卷）、<code>rm</code>（删除数据卷）等，当然这些命令都比较简单。</p><hr><h2 id="绑定数据卷"><a href="#绑定数据卷" class="headerlink" title="绑定数据卷"></a>绑定数据卷</h2><p>创建完数据卷后，使用<code>run</code>的<code>-v</code>（volume）选项来将容器的指定目录绑定上该数据卷，建立容器目录和主机目录之间的双向映射，以数据卷test为例，具体命令为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -v test:/data --name<span class="token operator">=</span>r3 redits:6.0.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令将会创建容器r3，并将r3的<code>/data</code>目录映射到主机<code>/var/lib/docker/volumes/test/_data</code>目录中，当对r3的该目录进行操作时，主机也会进行同步。</p><img src="https://i.bmp.ovh/imgs/2022/01/ccdd351da2233cae.png" style="zoom:80%;" /><p>同样，在主机的对应目录下进行操作，/data也会同步。比如，前者创建一个文件或目录，后者也会跟着创建一个文件或目录，前者对某个文件进行更改，后者的该文件也会相应更新。</p><p>现在你肯定想问，能不能不预先创建数据卷，直接在<code>run</code>时创建数据卷，进行目录映射，且指定主机目录？当然可以，依然使用<code>-v</code>选项，以r1的/data目录为例，命令形式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -v 主机目录:/data --name<span class="token operator">=</span>r1 redits:6.0.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以用<code>--mount</code>选项来进行绑定。比如，使用 training/webapp 镜像创建 Web 容器，并创建一个数据卷挂载到容器的/opt/webapp 目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -P --name web --mount <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span>/webapp,destination<span class="token operator">=</span>/opt/ webapp training/webapp python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，<code>-v</code>是可以同时创建多个数据卷的，完成多对目录的映射（–mount应该也可以，没试过）。命令形式也很间，用多个-v就行了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -v 主机目录1:容器目录1 -v 主机目录2:容器目录2 --name<span class="token operator">=</span>r1 redits:6.0.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里建议，在使用存储类服务时，一定要记得用数据卷，尤其是<strong>mysql</strong>这种！在用mysql创建容器时，一般都会将<code>log</code>、<code>data</code>、<code>config</code>均创建一个数据卷进行备份，因此，创建mysql容器通常用命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">3307</span>:3306 --name mysql-master <span class="token punctuation">\</span>-v /mydata/mysql-master/log:/var/log/mysql <span class="token punctuation">\</span>-v /mydata/mysql-master/data:/var/lib/mysql <span class="token punctuation">\</span>-v /mydata/mysql-master/conf:/etc/mysql <span class="token punctuation">\</span>-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span>-d mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>数据卷有两种权限，一是<code>rw</code>（读写），一是<code>ro</code>（只读）。这里的权限是只针对容器而不针对主机的。比如，<code>rw</code>指容器对主机相应目录可读可写，<code>ro</code>指容器对主机相应目录只能读不能写。</p><p>容器使用数据卷的默认权限是<code>rw</code>，如果想要用<code>ro</code>，对命令进行如下更改即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -v 主机目录:/data:ro --name<span class="token operator">=</span>r1 redits:6.0.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，当使用<code>ro</code>后，不是指容器内的写操作不会被映射，而是指容器已经无法对该目录（容器内）进行任何写操作了，因为它是一个<code>Read-only file system</code>。</p><p><img src="https://i.bmp.ovh/imgs/2022/01/3aa48b47a02047be.png"></p><hr><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果你需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门提供数据卷给其他容器挂载。</p><p>首先，创建一个容器dbdata，并在其中创建一个数据卷挂载到主机的/dbdata目录下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it -v /dbdata:/ --name dbdata ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，可以在其他容器中使用<code>--volumes-from</code>来挂载dbdata容器中的数据卷，例如创建db1和db2两个容器，并从dbdata容器挂载数据卷：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it --volumes-from dbdata --name db1 ubuntu<span class="token function">docker</span> run -it --volumes-from dbdata --name db2 ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时，容器db1和db2都挂载同一个数据卷到相同的/dbdata目录中，三个容器任何一方在该目录下的写入，其他容器都可以看到，当然，主机也能看到。</p><p>从<code>--volumes-from</code>这个名字就可以看出来，这种关系可以理解为数据卷的<strong>继承</strong>。既然如此，那么可不可以层层继承？答案是可以的。比如，在上面的基础上，我们可以在创建一个容器db3，它将从db1处继承容器卷，这样一来，四台容器和主机都会互相连通。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it --volumes-from db1 --name db3 ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果删除了”父类“容器（包括dbdata、db1和db2），数据卷并不会被删除，这意味着db3依然能够通过其与主机进行映射，即使其”父类“已经消失了。更好玩的是，当你停止了dbdata、db1和db2（并没有删除），然后在主机相应目录或db3相应目录进行写入，比如创建一个a.txt。然后再打开上面上个容器，它们仍然会同步这些数据，即出现a.txt。</p><hr><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>我挺好奇数据卷的实现原理的，比如它到底是对多个空间进行相互拷贝还是建立了一个共享空间，又比如它不属于联合文件系统（Union File System）到底是什么意思，这点我还没搞懂，而且也没查到相关的资料。等我搞懂了会补上，如果有大佬知道千万要告诉我，蟹蟹!</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础(二): 基础命令</title>
      <link href="/docker-ji-chu-er-ji-chu-ming-ling/"/>
      <url>/docker-ji-chu-er-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>如题，本文将总结常用的Docker基础命令，包括但不限于：<em>帮助启动类命名</em>；<em>镜像命令</em>；<em>容器命令</em>。</p><span id="more"></span><hr><h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><p>启动docker：<code>systemctl start docker</code></p><p>停止docker：<code>systemctl stop docker</code></p><p>重启docker：<code>systemctl restart docker</code></p><p>开即自启：<code>systemctl enable docker</code></p><p>查看docker概要信息：<code>docker info</code></p><p>docker帮助文档：<code>docker --help</code></p><p>docker某一命令帮助文档：<code>docker 命令 --help</code></p><hr><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>列出本地主机上的镜像：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>​    -a：列出本地全部的镜像(all)</p><p>​    -q：只显示镜像ID (quiet，静默模式)</p><p>​    返回结果中，<code>REPOSITORY</code>代表仓库名，即镜像名，<code>TAG</code>指镜像的版本号。</p></blockquote><p><strong>去docker仓库中搜索镜像：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回结果有5个参数，分别指：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>NAME</td><td>镜像名称</td></tr><tr><td>DESCRIPTION</td><td>镜像说明</td></tr><tr><td>STARS</td><td>点赞数量</td></tr><tr><td>OFFICIAL</td><td>是否官方</td></tr><tr><td>AUTOMATED</td><td>是否为自动构建的</td></tr></tbody></table><p><strong>拉取镜像：</strong><code>docker pull 镜像名</code>，完整形式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 镜像名:TAG<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只写了镜像名，则默认TAG为latest，即最新发布版。</p><p><strong>删除指定本地镜像：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 镜像名<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只写了镜像名，则默认TAG为latest，但如果你的本地没有该镜像的latest版本，就会删除失败。</p><blockquote><p>删除单个：<code>docker rmi 镜像名[:TAG]/ID</code></p><p>删除多个：<code>docker rmi 镜像名1:TAG/ID 镜像名2:TAG/ID</code></p><p>强制删除：-f ，会直接删除镜像的所有容器</p><p>删除全部：<code>docker rmi -f $(docker images -qa)</code>    ==&gt; 小心坐牢</p></blockquote><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>新建+启动容器：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 镜像 <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，OPTIONS非常重要，几个最常用的有：</p><blockquote><p>–name=”容器名字”：  为容器起名，不起的化随机</p><p>-i：以交互模式运行容器，通过与-t同时使用</p><p>-t：为容器重新分配一个伪输入终端，通过与-i同时使用</p><p>-it 也即交互式容器（前台有伪终端，等待交互）</p><p>-d：后台运行容器并返回容器ID，也即启动守护式容器（后台运行）</p><p>-p：指定端口映射，小写p，如<code>-p 3306:3306</code>指将主机的3306端口映射到该容器内的3306端口</p><p>-P：随机端口映射，大写P</p><p>-e：创建环境变量</p></blockquote><p>注意，并不是所有的镜像都能够以<code>-d</code>来后台运行，比如ubuntu、centos这些交互式镜像，就需要有一个前台来交互，所以对他们而已，使用<code>-d</code>并不能使其持久化。但是，那些服务类的镜像，比如tomcat、mysql、redis等等，虽然镜像是构建在Linux文件系统上的，但是他们可以通过<code>-d</code>来后台运行。</p><p>另外，有镜像才能创建容器，当运行run时，会首先在本地寻找是否有该镜像，如果没有，就去docker仓库中将该镜像拉取到本地，然后在创建容器。</p><p>可以通过<code>-e</code>来在改容器中创建一个指定值的环境变量，之后每次进入该容器都可以直接使用，如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name<span class="token operator">=</span>r2 -e <span class="token assign-left variable">A</span><span class="token operator">=</span><span class="token number">123</span> redis:6.0.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.bmp.ovh/imgs/2022/01/c1208f0d47eab09e.png"></p><p><strong>列出当前所有在运行中的容器：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>-a：列出当前所有正在运行的容器+历史上运行过的容器（如果容器没被删除）</p><p>-l：显示最近创建的容器</p><p>-n：显示最近n个创建的容器</p><p>-q：只显示容器编号</p></blockquote><p><strong>停止容器：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> stop 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>启动停止的容器：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> start 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重启容器：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> restart 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>从容器中退出：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>. exit：退出容器并使容器停止<span class="token number">2</span>. ctrl+p+1：退出容器但容器不会停止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>删除容器：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>强制删除：-f，如果不加的化，只能删除停止的容器</p><p>删除全部容器：<code>docker rm -f $(docker ps -a -q)</code>  ==&gt; 小心坐牢</p></blockquote><p><strong>查看容器日志：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看容器内的进程信息：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">top</span> 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，top查看的是容器中的进程在<code>宿主机OS</code>中的信息，比如查到的PID是该进程在宿主机上的PID，而不是在容器内部的信息，这就意味着这些信息是可以在宿主机的<code>ps -ef</code>中找到的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span><span class="token comment"># docker top redis2</span><span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDpolkitd             <span class="token number">18650</span>               <span class="token number">18630</span>               <span class="token number">0</span>                   <span class="token number">15</span>:41               ?                   00:00:00            redis-server *:6379<span class="token punctuation">[</span>root@master test<span class="token punctuation">]</span><span class="token comment"># ps -ef | grep 18650</span>polkitd   <span class="token number">18650</span>  <span class="token number">18630</span>  <span class="token number">0</span> <span class="token number">15</span>:41 ?        00:00:00 redis-server *:6379root      <span class="token number">25347</span>   <span class="token number">7737</span>  <span class="token number">0</span> <span class="token number">15</span>:52 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto <span class="token number">18650</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要查后者，用命令<code>docker exec 容器名/ID ps -ef</code>，不过前提是容器要安装ps。至于为什么一个进程会有不止一个信息，这就涉及到Container的进程管理机制了，主要为<code>PID namespace</code>，这个以后再说。</p><p><strong>查看容器内部细节：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 容器名/ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在容器内部运行指令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 容器名/ID COMMAND <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>docker exec</code> 会在容器内部运行COMMAND指令。实际上，容器就是个极小的Linux环境，它包含最必须的文件系统，因此实则时该Linux环境在执行这条命令。每个容器都会有一个默认的工作目录，该目录会在镜像的<code>Dockerfile</code>中指定，如果不另外指定的化，容器将在该目录下执行指令。</p><blockquote><p>COMMAND should be an executable, a chained or a quoted command will not work. Example: <code>docker exec -ti my_container &quot;echo a &amp;&amp; echo b&quot;</code> will not work, but <code>docker exec -ti my_container sh -c &quot;echo a &amp;&amp; echo b&quot;</code> will.</p></blockquote><p>比如，在mysql镜像构建的容器中使用命令date：</p><p><img src="https://i.bmp.ovh/imgs/2022/01/01abdf861dbf6295.png"></p><p>最关键的，之前有提到退出容器，那么退出容器后怎么再次进入呢？答案就是<code>exec</code>。进入容器，实际上就是使用容器的终端，因此首先要让容器打开一个终端，故将COMMAND设为<code>/bin/bash</code>或简写为<code>bash</code>。但是此时我们并不能进入这个终端，因为容器并不是交互时运行的，因此还需要使用OPTIONS<code>-it</code>来指定其为交互式运行，才能进入这个容器内的终端。故命令为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker exec -it 容器名/ID /bin/bash</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器名/ID <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://i.bmp.ovh/imgs/2022/01/dd2d0756e06ff06c.png"></p><p>当然，类似于<code>run</code> ，<code>exec</code>也可以通过<code>-e</code>来在容器中创建一个环境变量。但是不同于前者，<code>exec</code>创建的环境变量只能在本次执行过程中使用，一旦退出容器，下次再进入就没有该变量了。</p><p><img src="https://i.bmp.ovh/imgs/2022/01/0558c72736debfb8.png"></p><p>另一个非常重要的特性是，使用<code>exec -it .. bash</code>进入的容器，在<code>exit</code>退出之后，<strong>不会停止</strong>！与其相对应的，是<code>attach</code>命令，该命令也可也进入容器，但是用<code>exit</code>退出之后会导致容器的停止。</p><p><strong>从容器内拷贝文件到主机上：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> 容器名/ID:容器内路径 目的主机路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令会将指令的容器内路径中的所有文件，全部拷贝到目的主机，是简单的备份方式。</p><p><strong>导入和导出容器</strong></p><p><code>export</code>可以导出容器的内容留作一个<code>tar</code>归档文件。<code>import</code>可以从<code>tar</code>包中的内容创建一个新的文件系统再导入为镜像，注意，是生成镜像，而不是创建容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">export</span> 容器名/ID <span class="token operator">></span> 文件名.tar<span class="token function">cat</span> 文件名.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - <span class="token punctuation">[</span>镜像用户/<span class="token punctuation">]</span>镜像名<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://i.bmp.ovh/imgs/2022/01/4377aec9248f12ff.png"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://i.bmp.ovh/imgs/2022/01/999500d8cc65b5cf.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础(一): 初识</title>
      <link href="/docker-ji-chu-yi-chu-shi/"/>
      <url>/docker-ji-chu-yi-chu-shi/</url>
      
        <content type="html"><![CDATA[<p>假设你已经开发了一个Java项目，你所用的开发设备上已经配好了所有的相关环境，比如java8/mysql/redis等等。现在，你需要将你的源码交付给其他开发人员和测试人员或者直接打成jar包部署上线。问题来了，每个人机器上的环境都不一样，而你开发的项目依赖于你所选的环境和某些配置文件，这样一来其他人就需要为你的项目重新配好环境，非常麻烦。那么有没有什么办法可以避免这种头疼的配置协调问题呢？</p><span id="more"></span><p>试想，如果你将jar包或者源码和整个项目需要的所有配置环境和依赖一并打包，使你交付的东西不仅拥有项目本身，还拥有整个环境，这样拉下来之后直接可以运行，问题不就解决了吗。而这，就是 <code>docker</code> 的核心思想！</p><hr><h3 id="Docker的意义"><a href="#Docker的意义" class="headerlink" title="Docker的意义"></a>Docker的意义</h3><p>在docker出来之前，开发和运维的对调是很麻烦的，经常出现开发者的项目没问题，但是到了运维那就跑不起来了，基本都是环境的问题。比如，你使用java8写了一个项目，但是运维那里用的是java11，你使用mysql5.7.17，但是运维那用mysql8.0.26。</p><p>好在，你和运维关系很好，没吵架，他愿意和你协调。于是，你把项目需要的所有配置列成清单给他，他一看，麻了。清单上列的慢慢的环境配置，和他现在用的都不一样，得一个个重新配。很明显，传统项目交接有两个很头痛的毛病</p><blockquote><p>1&gt;  环境不一样</p><p>2&gt;  安装啰嗦，配置麻烦</p></blockquote><p>你以为这样就结束了？不对！假设你写的项目是一个电商平台，每天的数据量非常大，redis必须使用集群。到了双十一附近，交易量猛增，集群必须要迅速的扩容，从原来的3主3从扩到5主5从。在传统的方式中，运维撑破天也无法在<code>秒级</code>完成这种扩缩容。这就暴露出了第三个缺点：</p><blockquote><p>3&gt;  扩缩容慢</p></blockquote><p>Docker的出现得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心、运作应用程序所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</p><hr><h3 id="Docker与虚拟机的对比"><a href="#Docker与虚拟机的对比" class="headerlink" title="Docker与虚拟机的对比"></a>Docker与虚拟机的对比</h3><p>docker并不是第一个采用这种思想的技术，在docker出来之前，业界的网红是 <code>虚拟机(virtual machine)</code>， 它也是一个典型的带环境安装的方案。不管你的物理机是什么系统，只要下载下来OS的镜像(.iso)，在VMWare上一跑就行了。</p><p>比如Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。需要注意的是，虚拟机是要虚拟出一整套<code>硬件</code>的，然后在其上运行一整个完整的OS。</p><p><img src="https://i.bmp.ovh/imgs/2022/01/fef1097b924d5562.png"></p><p>正因为虚拟机是硬件层面上的虚拟，且要模拟出整套OS，因此体量非常大，故缺点很多，比如：</p><blockquote><p>​    &gt; 内存占用大</p><p>​    &gt; 启动慢</p><p>​    &gt; 冗余步骤多，麻烦</p></blockquote><p>由于虚拟机存在这些缺点，Linux发展出了另一种虚拟化技术：</p><blockquote><p>Linux容器（Linux Containers，缩写为LXC）</p></blockquote><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需要的所有资源打包到一个隔离的容器中。容器于虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和配置，也就是<strong>最小的最必须的环境</strong>。系统因此变得高效而轻量，并保证部署在任何环境中的软件都能始终如一地运行。实际上，这个Linux容器技术，后来就发展成了<code>docker</code>。</p><p>Docker容器是在 <code>OS层面</code> 上虚拟化的，直接复用本地主机的OS。与虚拟机相比，Docker启动快速、体积小。</p><table><thead><tr><th align="center"></th><th align="center">Virtual Machine</th><th align="center">Docker</th></tr></thead><tbody><tr><td align="center">大小</td><td align="center">GB-TB</td><td align="center">KB-MB</td></tr><tr><td align="center">启动速度</td><td align="center">分钟级</td><td align="center">秒级</td></tr><tr><td align="center">虚拟层面</td><td align="center">硬件</td><td align="center">OS</td></tr><tr><td align="center">隔离级别</td><td align="center">OS级</td><td align="center">进程级</td></tr><tr><td align="center">集群规模</td><td align="center">上百</td><td align="center">上万</td></tr></tbody></table><p>总结一下就是：</p><blockquote><p>​    &gt; 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整OS，在该系统上在运行所需应用进程</p><p>​    &gt; 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。</p><p>​    &gt; 每个容器之间互相隔离，各自有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p></blockquote><hr><h3 id="Docker的诞生"><a href="#Docker的诞生" class="headerlink" title="Docker的诞生"></a>Docker的诞生</h3><p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。这家公司主要提供基于PaaS的云计算技术服务，具体来说，就是和前面提到的<code>LXC</code>有关的容器技术。后来，dotCloud公司将自己的容器技术进行了简化和标准化，并将该技术命名为——<strong>Docker</strong>。</p><p><img src="https://i.bmp.ovh/imgs/2022/01/887208c6d030f816.png"></p><p>很可惜，Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。那怎么办呢？==&gt; 办不下去就开源！</p><p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes决定，将Docker技术开源。不开则已，一开惊人。越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入了Docker开源社区。Docker人气迅速攀升，开源当月，Docker 0.1发布，在此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p><p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc。</p><p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。这个时候，K8S出现了！</p><blockquote><p>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes，8是代表中间8个字母。</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/01/fd0878675fafdd67.png"></p><p>和Docker不同，K8S的创造者，是众人皆知的行业巨头——Google。然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的<strong>Borg</strong>系统。</p><p>其实，在很早之前，Google就用了容器化的技术，并拥有一套完善的集群管理系统——Borg，且不开源。慢慢地，对这种管理系统的需求越来越多，但Google迟迟不开源，没办法，需求者只能自己写。唉，这个时候，Google怕了，万一这种技术出现了，那自己垄断Borg的优势不久荡然无存了。怎么办？ ==&gt; 打不过就加入，我开源还不行嘛。于是乎，Google用Go重写了一遍Borg，更名为K8S，将其开源，继续作为领域的领跑者。</p><p>2014年6月，Google公司正式公布K8S并宣布开源的。之后的一年内，VMware、HP、Intel等公司，也陆续加入。2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。</p><p>K8S的架构，相对来说很复杂，组件比较多，交互也复杂，具体的之后再说吧。</p><hr><h3 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h3><blockquote><p>​    &gt; 镜像（image）</p><p>​    &gt; 容器（container）</p><p>​    &gt; 仓库（repository）</p></blockquote><p>可以用java做一个粗略的类比，所谓镜像，就是java中的一个个class，所谓容器，就是用class来new出来的一个个对象（实例），所谓仓库，就是存储那些镜像的地方。</p><p>再生动一些，你住的房子就是你现在所处的容器，假设你要搬家，但是还想住一个和现在一摸一样的家，于是你找来了女巫，女巫用魔法通过你的房子生成了一个一摸一样的模型，整个模型就是<code>镜像</code>。你将该模型带了一片空地上，女巫瞬间用改模型在地上建立了一个和之前那个一摸一样的新房子，连地基都一样，这个新房子就是一个新的<code>容器</code>。现在，女巫告诉你她有一个<code>仓库</code>，你可以将自己房子的镜像上传上去，也可以拉取别人的镜像，里面有中式四合院、欧式别墅、大豪宅、甚至还有非洲茅草屋，只要拉取了镜像，直接可以带地基生成一个完整的房子，岂不美哉？</p><blockquote><p>Docker镜像（image）就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器，也可以通过容器来构造一个新的镜像。它也相当于是一个root文件系统，比如官方镜像centos:7就包含了完整的一套centos:7最小系统的root文件系统。</p><p>容器就是一个简易版的Linux环境，包括root用户权限、进程空间、用户空间和网络空间等等，外加在其中运行的应用程序。</p></blockquote><p>要注意，Docker本身并不是容器，它是创建容器的工具，是应用容器引擎，即Docker Engine。</p><p>至于仓库，就是docker hub，类似于github，官方仓库为：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="https://i.bmp.ovh/imgs/2022/01/6dba028887a78da1.png"></p><p>基于此，Docker提出了它的两句口号</p><blockquote><p>1&gt;  Build, Ship and Run； 即“构建，发送，运行”三板斧</p><p>2&gt;  Build once, Run anywhere； 即构建一次，处处能用</p></blockquote><hr><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p><img src="https://i.bmp.ovh/imgs/2022/01/7ce065860607102a.png"></p><p>Docker是一个<code>C/S模式的架构</code>，后端是一个松耦合架构，众多模块各司其职，Docker运行的基本流程为：</p><p>1&gt;  用户使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</p><p>2&gt;  Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接收Docker Client的请求。</p><p>3&gt;  Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式存在的。比如，用<code>docker run 镜像</code> 命令来创建一个容器，就是一个Job。</p><p>4&gt;  Job运行过程中，当需要镜像时，就会在本地中找，如果本地没有，就去Docker Registry中拉取镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储在本地。</p><p>5&gt;  当需要为Docker容器创建环境时，通过网络管理驱动Network Driver创建并配置Docker容器网络环境。详细情况会在后续Docker network博客讲述。</p><p>6&gt;  当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec Driver来完成。主要为命令：<code>docker exec [OPTIONS] 容器名/ID [CMD] </code>，详见后续docker基础命令博客。</p><p>7&gt;  Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p><p><img src="/docker-ji-chu-yi-chu-shi/docker-ar.png" alt="docker-ar"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo(一): Github部署</title>
      <link href="/hexo-github-bu-shu/"/>
      <url>/hexo-github-bu-shu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2022/01/19ac51e4df9b7946.png"></p><p>Hexo是一个快速、简洁且高效的博客框架，默认使用MarkDown解析文章，用选定的主题渲染出静态页面。使用<code>JavaScript</code>进行逻辑控制，没有后端，直接通过Url访问页面即可。通过github仓库来存储Hexo需要的文件(包括<code>资源文件</code>和<code>Html页面</code>)，即可搭建公网博客。</p><span id="more"></span><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装Hexo很简单，不过要先装上<code>Node.js</code>和<code>Git</code></p><blockquote><p>​    &gt; Node.js</p><p>​    &gt; Git</p><p>​    &gt; Hexo</p></blockquote><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo基于JavaScript，因此首先要安装<code>Node.js</code>，版本不能低于10.13。Hexo建议使用最新版本，Node.js建议使用<code>v12.22</code>版本，版本过高会导致一些插件无法适配。</p><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低兼容 Node.js 版本</th></tr></thead><tbody><tr><td align="left">6.0+</td><td align="left">12.13.0</td></tr><tr><td align="left">5.0+</td><td align="left">10.13.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td></tr></tbody></table><p>​    安装好后，将Node换成<code>国内源</code>，非必须，不过npm下载会很慢。这里使用淘宝的镜像源：</p><ul><li>临时换源</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> --registry https://registry.npm.taobao.org <span class="token function">install</span> express<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>永久换源</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看源</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><blockquote><p><strong>Mac用户</strong></p><p>如果在编译时可能会遇到问题，请先到 App Store 安装 <code>Xcode</code>，安装完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。</p></blockquote><blockquote><p><strong>Windows用户</strong></p><p>对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p></blockquote><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装完Node.js和Git之后，即可安装Hexo，建议全局安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看Hexo版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><p>在部署前，需要在本地对Hexo进行一些操作，包括目录的初始化、静态页面的生成和预览等。</p><h3 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init Blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入上述命令，会在当前目录下生成一个<code>Blog</code>目录(名字可以自己取)。目录中结构大致为：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>_config.yml</code>为博客的根配置文件，配置信息参照：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a> <code>source</code>目录下存放博客的md文件以及博客需要的资源文件。<code>theme</code>目录下存放下载的资源文件，可在根_config.yml中指定选用的主题。</p><p>进入该文件夹，安装必备的node组件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会有WARN，不过没有影响。</p><h3 id="静态网页生成与预览"><a href="#静态网页生成与预览" class="headerlink" title="静态网页生成与预览"></a>静态网页生成与预览</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令将根据Blog文件夹中的资源和配置生成静态网页，命令可可简写为<code>hexo g</code></p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">INFO  Start processingINFO  Files loaded in 356 msINFO  Generated: index.htmlINFO  Generated: archives/index.htmlINFO  Generated: fancybox/fancybox_loading@2x.gifINFO  Generated: fancybox/jquery.fancybox.cssINFO  Generated: fancybox/fancybox_loading.gifINFO  Generated: fancybox/blank.gifINFO  Generated: fancybox/helpers/fancybox_buttons.pngINFO  Generated: js/script.jsINFO  Generated: fancybox/fancybox_overlay.pngINFO  Generated: fancybox/fancybox_sprite.pngINFO  Generated: fancybox/fancybox_sprite@2x.pngINFO  Generated: archives/2019/06/index.htmlINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO  Generated: fancybox/jquery.fancybox.pack.jsINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO  Generated: css/style.cssINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO  Generated: archives/2019/index.htmlINFO  Generated: fancybox/helpers/jquery.fancybox-media.jsINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: 2019/06/08/hello-world/index.htmlINFO  Generated: fancybox/jquery.fancybox.jsINFO  Generated: css/images/banner.jpgINFO  28 files generated in 715 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于现在还没有进行Git部署，所以只能在本地预览：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以简写为<code>hexo s</code>，该命令将开启本地服务。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">INFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Hexo默认4000端口，因此打开 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客啦。</p><p><img src="https://i.bmp.ovh/imgs/2022/01/9da67a7fd947625c.png"></p><hr><h2 id="Github部署"><a href="#Github部署" class="headerlink" title="Github部署"></a>Github部署</h2><p>我们需要一个远程仓库来存储Hexo需要的文件并托管博客，Github就很适合。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>点击<code>New repository </code>创建一个新的仓库，给仓库取名</p><p><img src="https://i.bmp.ovh/imgs/2022/01/06e303b4485eb91b.png"></p><ul><li>Rep name一定要严格按照 <code>Account Name</code>.github.io的形式来命名，只有这样的仓库名称才能在公网上以静态页面的形式展示。</li><li>访问权限设为Public</li></ul><h3 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h3><p><code>SSH Key</code>(Secure Shell)是一个公私钥对，这里用于Git仓库和本地机器的绑定。使用SSH Key，就可以不用每次更新都需要输入令牌，方便很多。</p><blockquote><p>​    &gt; 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题</p><p>​    &gt; 如果换了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上</p><p>​    &gt; 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key</p></blockquote><p>SSH Key是针对机器而非特定目录的，所以在任意一个目录下打开<code>Git Bash</code>，输入<code>ssh</code>检查机器是否装有SSH。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]           [-i identity_file] [-J [user@]host[:port]] [-L address]           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]           [-w local_tun[:remote_tun]] destination [command]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，在本地生成SHH公私钥对，输入命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"github的注册邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>键入四个回车就行，用默认选项。完成后，该命令会在用户文件夹下生成一个<code>.ssh</code>目录，路径为：C:\Users\用户名\.ssh。目录下有两个文件，分别为：</p><blockquote><p>​    &gt; id_rsa：SSH私钥</p><p>​    &gt; id_rsa.pub：SSH公钥</p></blockquote><p>生成完毕后，将SSH公钥注册进Github中。在<code>Settings</code>-&gt;<code>SSH and GPG keys</code>-&gt;<code>New SSh key</code>中新建一个SSH公钥：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/bf1d95fb3fe3d2d5.png"></p><p>Titile可以随便取，但是Key一定要要原封不动的复制id_rsa.pub中的内容，空格和换行都不能动。注册成功后，SSH Keys中就可以看到该公钥：</p><p><img src="https://i.bmp.ovh/imgs/2022/01/cbcaf19961dd2f30.png"></p><p>最后，验证本地与仓库是否绑定成功，输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会得到下面这句话：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">Hi sakura-ysy! You've successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>but后面的这里不用关注。</p><h3 id="本地推送"><a href="#本地推送" class="headerlink" title="本地推送"></a>本地推送</h3><p>在根<code>_config.yml</code>中进行部署配置，将<code>deploy</code>中的内容全部改为：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/sakura<span class="token punctuation">-</span>ysy/sakura<span class="token punctuation">-</span>ysy.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>type是固定的，rep指仓库地址，branch可以自己选要用哪个分支部署。注意，github的主分支由原来的master变为了main。</p><p>然后，在博客根目录下打开<code>Git Bash</code>，安装Git部署工具:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完后就可以在本地生成页面并推送。</p><p>在生成新的页面之前，先用 <code>hexo clean</code> 清除缓存文件与之前生成的静态文件目录public。清除完毕后，使用<code>hexo g</code>生成静态页面。</p><p>最后，即可开始推送并部署，使用命令<code>hexo d</code> ，全称为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在第一次推送时，要进行身份验证从2021.08.13开始， GitHub不再支持账号和密码的方式进行身份验证了，取而代之的是官方推出的<code>Personal access tokens</code>。</p><p>在Github中的 <code>Seqttings</code>-&gt;<code>Developer settings</code>-&gt;<code>Personal access tokens</code>-&gt;<code>Personal access tokens</code> 生成一个新的令牌：</p><p><img src="https://i.bmp.ovh/imgs/2022/01/57a82e42da55b911.png"></p><p>权限可以全部选上，没关系。完成后，即生成了一串序列号，它就是我们用于代替密码的令牌：</p><p><img src="https://i.bmp.ovh/imgs/2022/01/4c06520619a2bb09.png"></p><p>在第一次<code>hexo d</code>需要验证身份时，输入上述令牌即可。</p><p>上面工作全部完成后，即可通过公网访问博客，网址就是仓库名：<a href="http://sakura-ysy.github.io/">http://sakura-ysy.github.io</a></p><hr><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><p>MarkDown中存储的是图片本地文件路径，要想在公网展示，必须将图片存储在云端并在md中使用该路径，有两个较好用的方法：</p><blockquote><p>​    &gt; 图片存在Git仓库</p><p>​    &gt; 使用图床</p></blockquote><h3 id="图片存在Git仓库"><a href="#图片存在Git仓库" class="headerlink" title="图片存在Git仓库"></a>图片存在Git仓库</h3><p>首先安装插件hexo-renderer-marked：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-marked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，在根_config.yml中新增如下配置 :</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">marked</span><span class="token punctuation">:</span>  <span class="token key atrule">prependRoot</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">postAsset</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样以来，当我们使用 <code>hexo new post &#39;文章名&#39;</code> 时，在source/_post目录下除了生成对应的md文件，还会生成一个同名的目录。将所有图片存在该目录下，并使用相对路径引用该目录中的图片即可。</p><p>但是，上述插件只会生成一个空目录，并不会自动将图片放进去，所有操作需要手动执行，非常麻烦，那怎么让它自动执行？这里就要用到强大的<strong>Typora</strong>了</p><p>打开Typora的偏好设置，使图片在插入时会复制到指定路径，由于目标目录名和文章名相同，因此复制到<code>./$&#123;filename&#125;</code>处即可。</p><p><img src="https://s2.loli.net/2022/01/15/xBvwpgXJFE9oqeW.png" alt="image.png"></p><p>使用该配置后，插入到Typora中的图片，会直接复制该到文章资源文件夹，同时在md中自动更改路径。如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p><p>但是在部署后的路径和本地路径是不一样的，它会直接在文章的资源文件夹中找，因此路径中的<code>文章名/</code> 需要删掉，即更改为<code>[]image.jpg)</code>，这样虽然在本地md中路径错误，但是部署后即正确。</p><p>为了方便，可以在Typora编写完博客后，使用Ctrl+F全局搜索<code>文章名/</code>，然后将其替换成空串即可。</p><h3 id="使用图床"><a href="#使用图床" class="headerlink" title="使用图床"></a>使用图床</h3><p>将图片存在Git上有两个缺点，一是本地寻址不出来，二是图片加载很慢，为了解决这两个问题，可以使用图床来存储图片。</p><p>所谓图床，就是公网上的存储空间，将本地文件上传上去后会返回该图片在网络上的URL，使用该URL作为图片路径即可。</p><p>如果有已备案域名的话，推荐使用七牛云，因为它是国内服务商，速度快且稳定，不用担心被封，用户也有免费的10G空间可用。</p><p>如果没有的话，直接使用现成的公共图床也可，不同的图床速度和空间都不一样，根据需求选用，可以参考：<a href="https://zhuanlan.zhihu.com/p/58863378">https://zhuanlan.zhihu.com/p/58863378</a></p><p>比如使用<a href="https://sm.ms/">sm.ms</a>图床，上传后返回图片的网络地址和不同的引用格式，在md文件中引用就行。</p><p><img src="https://s2.loli.net/2022/01/15/jLJsXgzFWA7Hlvp.png" alt="image.png"></p><p>建议使用具有CDN加速的图床，这样会很快。</p><p>不过公共图床毕竟是公共的，免不了被封的风险，且自己也没法管理上传的内容。所以如果想折腾的话，建议用自己的服务器搭图床。</p><hr><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>.github.io这个域名后缀着实不好看，并且前面必须用git账户名，所以给它绑个域名最好。首先得租一个域名，可以直接去阿里万网那租。租完后，就需要将新域名和原域名进行绑定，这个操作在服务商端和Git端都要进行，可以理解为一种双向同意。</p><h3 id="服务商端"><a href="#服务商端" class="headerlink" title="服务商端"></a>服务商端</h3><p>以阿里万网为例，点击<code>解析</code>进入解析设置。</p><p><img src="https://s2.loli.net/2022/01/15/PTl2WvhfyNaEKRL.png" alt="MAIJUE8AS_SJ2G1A_M90MZC.png"></p><p>将记录类型设为<code>CNAME</code>，意为用该域名指向另一个域名。记录值填原域名，即sakura-ysy.github.io。其他值默认就行。</p><p><img src="https://s2.loli.net/2022/01/15/AfwcSEl5U9gHRBF.png" alt="image.png"></p><p>当然，记录类型也可以选择A，即直接让域名执行Git的IPv4，可以通过<code>ping sakura-ysy.github.io</code> 来获得该IP。</p><p>至于主机记录，其实就是域名前缀，常见用法有：</p><blockquote><ul><li><p><strong>www：</strong>解析后的域名为<a href="http://www.aliyun.com./">www.aliyun.com。</a></p></li><li><p><strong>@：</strong>直接解析主域名 aliyun.com。</p></li><li><p>*<strong>：</strong>泛解析，匹配其他所有域名 *.aliyun.com。</p></li><li><p><strong>mail：</strong>将域名解析为mail.aliyun.com，通常用于解析邮箱服务器。</p></li><li><p><strong>二级域名：</strong>如：abc.aliyun.com，填写abc。</p></li><li><p><strong>手机网站：</strong>如：m.aliyun.com，填写m。</p></li><li><p><strong>显性URL：</strong>不支持泛解析（泛解析：将所有子域名解析到同一地址）</p></li></ul></blockquote><h3 id="Git端"><a href="#Git端" class="headerlink" title="Git端"></a>Git端</h3><p>只需要在Git仓库中添加一个无后缀文件<code>CNAME</code>，内容只有一行，为绑定的域名，即<code>yesiyuan.cn</code>。当然，也可以直接在Settings-&gt;Pages中的Custom domain中绑定该域名。</p><p><img src="https://s2.loli.net/2022/01/15/MyLpC91z3tTYi5l.png" alt="image.png"></p><p>两端都完成配置后，即可使用新域名来访问博客啦。</p><h3 id="使用HTTPS"><a href="#使用HTTPS" class="headerlink" title="使用HTTPS"></a>使用HTTPS</h3><p>这个我还没弄</p><p>未完待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><span id="more"></span><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
